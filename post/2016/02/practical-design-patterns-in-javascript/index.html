<!doctype html>
<html>
<head>
    <base href="./">
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no">
<meta name="author" content="Orest Prystayko">


<link rel="apple-touch-icon" sizes="180x180" href="../../../../favicon/apple-touch-icon.png">
<link rel="icon" type="image/png" href="../../../../favicon/favicon-32x32.png" sizes="32x32">
<link rel="icon" type="image/png" href="../../../../favicon/favicon-16x16.png" sizes="16x16">
<link rel="manifest" href="../../../../favicon/manifest.json">
<link rel="mask-icon" href="../../../../favicon/safari-pinned-tab.svg" color="#5bbad5">
<meta name="theme-color" content="#ffffff">



<meta name="description" content="">

<title>Practical design patterns in JavaScript</title>
<meta name="generator" content="Hugo 0.27.1" />
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.1.0/styles/pojoaque.min.css">
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.1.0/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad();</script>

<link href="https://fonts.googleapis.com/css?family=Source+Code+Pro:400,700" rel="stylesheet" type="text/css">
<link  href="https://qetr1ck-op.github.io/blog/css/theme.min.css" rel="stylesheet" type="text/css">

</head>
<body>
<div class="page-container container-fluid">
<div class="col-md-3 menu">
    <nav class="col-md-3">
    <h3 class="home-link">
        <a href="../../../../">Root</a>
        <a href="../../../../about">About</a>
        <a href="../../../../search">
            <i class="search-btn"></i>
        </a>
    </h3>
    <div id="last-posts" class="open">
        <h3 data-open="last-posts">OP blog - Most recent posts</h3>
        <ul>
            
            <li><a href="https://qetr1ck-op.github.io/blog/post/2017/06/react-app-with-express-in-production/">React app with Express in production</a></li>
            
            <li><a href="https://qetr1ck-op.github.io/blog/post/2017/05/interview-question-nodejs-part-2/">Interview question: NodeJS, part 2</a></li>
            
            <li><a href="https://qetr1ck-op.github.io/blog/post/2017/05/what-is-load-balancing/">What is Load Balancing?</a></li>
            
            <li><a href="https://qetr1ck-op.github.io/blog/post/2017/05/interview-question-nodejs-part-1/">Interview question: NodeJS, part 1</a></li>
            
            <li><a href="https://qetr1ck-op.github.io/blog/post/2017/05/asynchronous-javascript-with-async-await/">Asynchronous Javascript with async/await</a></li>
            
        </ul>
    </div>

    

    
    <div id="categories" class="open">
        <h3 data-open="categories">Categories</h3>
        <ul class="categories">
            
            <li><a href="../../../../categories/angularjs">angularjs</a></li>
            
            <li><a href="../../../../categories/architecture">architecture</a></li>
            
            <li><a href="../../../../categories/books">books</a></li>
            
            <li><a href="../../../../categories/build-tools">build-tools</a></li>
            
            <li><a href="../../../../categories/cli">cli</a></li>
            
            <li><a href="../../../../categories/css">css</a></li>
            
            <li><a href="../../../../categories/deploy">deploy</a></li>
            
            <li><a href="../../../../categories/dom-api">dom-api</a></li>
            
            <li><a href="../../../../categories/es2015&#43;">es2015&#43;</a></li>
            
            <li><a href="../../../../categories/flux/redux">flux/redux</a></li>
            
            <li><a href="../../../../categories/git">git</a></li>
            
            <li><a href="../../../../categories/http">http</a></li>
            
            <li><a href="../../../../categories/javascript">javascript</a></li>
            
            <li><a href="../../../../categories/katas">katas</a></li>
            
            <li><a href="../../../../categories/nodejs">nodejs</a></li>
            
            <li><a href="../../../../categories/oop">oop</a></li>
            
            <li><a href="../../../../categories/patterns">patterns</a></li>
            
            <li><a href="../../../../categories/performance">performance</a></li>
            
            <li><a href="../../../../categories/react">react</a></li>
            
            <li><a href="../../../../categories/regexp">regexp</a></li>
            
            <li><a href="../../../../categories/web-api">web-api</a></li>
            
        </ul>
    </div>
    
</nav>

</div>
<div class="col-md-9 content">

<h1>Practical design patterns in JavaScript</h1>
<h4>Published 2016-02-03</h4>



<article>
    <nav id="TableOfContents">
<ul>
<li><a href="#why-is-it-important-to-understand-patterns-and-be-familiar-with-them">Why is it important to understand patterns and be familiar with them?</a></li>
<li><a href="#categories-of-design-pattern">Categories Of Design Pattern</a>
<ul>
<li><a href="#creation-design-patterns">Creation Design Patterns</a></li>
<li><a href="#structural-design-patterns">Structural Design Patterns</a></li>
<li><a href="#behavioral-design-patterns">Behavioral Design Patterns</a></li>
<li><a href="#table-of-23-design-patterns-mentioned-by-the-gof">Table of 23 Design Patterns mentioned by the GoF</a></li>
</ul></li>
<li><a href="#creation-design-patterns-in-depth">Creation Design Patterns in depth</a>
<ul>
<li><a href="#the-constructor-pattern">The Constructor Pattern</a>
<ul>
<li><a href="#object-creation">Object Creation</a></li>
<li><a href="#basic-constructors">Basic Constructors</a></li>
<li><a href="#constructors-with-prototypes">Constructors With Prototypes</a></li>
<li><a href="#constructors-with-es6-class">Constructors with ES6 class</a></li>
<li><a href="#constructors-with-es6-class-for-node-js">Constructors with ES6 class for Node.js</a></li>
<li><a href="#constructors-in-angular1-x">Constructors in Angular1.x</a></li>
</ul></li>
<li><a href="#the-module-pattern">The Module Pattern</a>
<ul>
<li><a href="#the-revealing-module-pattern">The Revealing Module Pattern</a></li>
<li><a href="#the-module-pattern-for-node-js">The Module Pattern for Node.js</a></li>
<li><a href="#the-module-pattern-for-angular1-x">The Module Pattern for Angular1.x</a></li>
</ul></li>
<li><a href="#the-singleton-pattern">The Singleton Pattern</a>
<ul>
<li><a href="#the-singleton-pattern-for-node-js">The Singleton Pattern for Node.js</a></li>
<li><a href="#the-singleton-pattern-for-angular1-x">The Singleton Pattern for Angular1.x</a></li>
</ul></li>
<li><a href="#the-factory-pattern">The Factory Pattern</a>
<ul>
<li><a href="#abstract-factories">Abstract Factories</a></li>
</ul></li>
</ul></li>
<li><a href="#structural-design-patterns-in-depth">Structural Design Patterns in depth</a>
<ul>
<li><a href="#mixins">Mixins</a>
<ul>
<li><a href="#mixins-with-es6">Mixins with ES6</a></li>
</ul></li>
<li><a href="#the-decorator-pattern">The Decorator Pattern</a>
<ul>
<li><a href="#the-decorator-pattern-in-angular1-x">The Decorator Pattern in Angular1.x</a></li>
</ul></li>
<li><a href="#sub-classing">Sub-classing</a></li>
<li><a href="#sub-classing-with-es6">Sub-classing with ES6</a></li>
<li><a href="#the-facade-pattern">The Facade Pattern</a></li>
<li><a href="#flyweight">Flyweight</a></li>
</ul></li>
<li><a href="#behavior-design-patterns-in-depth">Behavior Design Patterns in depth</a>
<ul>
<li><a href="#the-observer">The observer</a></li>
<li><a href="#differences-between-the-observer-and-publish-subscribe-pattern">Differences Between The Observer And Publish/Subscribe Pattern</a></li>
</ul></li>
</ul>
</nav>
    <p>One of the most important aspects of writing maintainable code is being able to notice the repeating themes in that code and optimize them. This is an area where knowledge of design patterns can prove invaluable.</p>

<p>I take a look at a number of popular JavaScript design patterns and explore why certain patterns may be suitable for your projects.</p>

<p></p>

<h1 id="why-is-it-important-to-understand-patterns-and-be-familiar-with-them">Why is it important to understand patterns and be familiar with them?</h1>

<p>So, why is it important to understand patterns and be familiar with them? Design patterns have three main benefits:</p>

<ol>
<li>Patterns are proven solutions: They provide solid approaches to solving issues in software development using proven techniques that reflect the experience and insights the developers that helped define them bring to the pattern.</li>
<li>Patterns can be easily reused: A pattern usually reflects an out of the box solution that can be adapted to suit our own needs.</li>
<li>Patterns can be expressive: When we look at a pattern there’s generally a set structure and vocabulary to the solution presented that can help express rather large solutions quite elegantly.</li>
</ol>

<h1 id="categories-of-design-pattern">Categories Of Design Pattern</h1>

<p>Design patterns can be broken down into a number of different categories. In this section we’ll review three of these categories:</p>

<h2 id="creation-design-patterns">Creation Design Patterns</h2>

<p>The basic approach to object creation might otherwise lead to added complexity in a project whilst these patterns aim to solve this problem by <strong>controlling</strong> the creation process.</p>

<p>Some of the patterns that fall under this category are: <strong>Constructor</strong>, <strong>Factory</strong>, <strong>Prototype</strong>, <strong>Singleton</strong>.</p>

<h2 id="structural-design-patterns">Structural Design Patterns</h2>

<p>Typically identify simple ways to realize relationships between different objects.</p>

<p>Patterns that fall under this category include: <strong>Decorator</strong>, <strong>Facade</strong>, <strong>Flyweight</strong>.</p>

<h2 id="behavioral-design-patterns">Behavioral Design Patterns</h2>

<p>Behavioral patterns focus on improving the communication between disparate objects in a system.</p>

<p>Some behavioral patterns include: <strong>Mediator</strong>, <strong>Observer</strong>.</p>

<h2 id="table-of-23-design-patterns-mentioned-by-the-gof">Table of 23 Design Patterns mentioned by the GoF</h2>

<p>I personally found the following table a very useful reminder of what a number of patterns has to offer - it covers the 23 Design Patterns mentioned by the GoF:</p>

<p><img src="../../../../images/posts/Practical-design-patterns-in-JavaScript/img.jpg" alt="" /></p>

<h1 id="creation-design-patterns-in-depth">Creation Design Patterns in depth</h1>

<p>Developers commonly wonder whether there is an ideal pattern or set of patterns they should be using in their workflow. There isn&rsquo;t a true single answer to this question; each script and web application we work on is likely to have its own individual needs and we need to think about where we feel a pattern can offer real value to an implementation.</p>

<h2 id="the-constructor-pattern">The Constructor Pattern</h2>

<p>In classical object-oriented programming languages, a <strong>constructor</strong> is a special method used to initialize a newly created object once memory has been allocated for it.</p>

<p>In JavaScript, as almost everything is an object, we&rsquo;re most often interested in object constructors.</p>

<h3 id="object-creation">Object Creation</h3>

<pre><code class="language-js">// Each of the following options will create a new empty object:
const newObject = {};
 
// or
const newObject = Object.create( Object.prototype );
 
// or
const newObject = new Object();
</code></pre>

<p>Where the <code>Object</code> constructor in the final example creates an object wrapper for a specific value, or where no value is passed, it will create an empty object and return it.</p>

<h3 id="basic-constructors">Basic Constructors</h3>

<p>By simply prefixing a call to a constructor function with the keyword <code>new</code>, we can tell JavaScript we would like the function to behave like a constructor and instantiate a new object with the members defined by that function.</p>

<p>Inside a <code>constructor</code>, the keyword <code>this</code> references the new object that&rsquo;s being created:</p>

<pre><code class="language-js">function Car( model, year, miles ) {
 
  Object.assign(this, { model, year, miles });
 
  this.toString = function () {
    return `${this.model} has done ${this.miles} miles`;
  };
}
 
// Usage:
const civic = new Car( &quot;Honda Civic&quot;, 2009, 20000 );
const mondeo = new Car( &quot;Ford Mondeo&quot;, 2010, 5000 );
 
console.log( civic.toString() );
console.log( mondeo.toString() );
</code></pre>

<h3 id="constructors-with-prototypes">Constructors With Prototypes</h3>

<p>Functions, like almost all objects in JavaScript, contain a <code>prototype</code> object. When we call a JavaScript constructor to create an object, all the properties of the constructor&rsquo;s prototype are then made available to the new object:</p>

<pre><code class="language-js">function Car( model, year, miles ) {
 
  Object.assign(this, { model, year, miles });
 
}
 
// Note here that we are using Object.prototype.newMethod rather than
// Object.prototype so as to avoid redefining the prototype object
Car.prototype.toString = () =&gt; `${this.model} has done ${this.miles} miles`;
 
// Usage:
const civic = new Car( &quot;Honda Civic&quot;, 2009, 20000 );
const mondeo = new Car( &quot;Ford Mondeo&quot;, 2010, 5000 );
 
console.log( civic.toString() );
console.log( mondeo.toString() );
</code></pre>

<h3 id="constructors-with-es6-class">Constructors with ES6 class</h3>

<pre><code class="language-js">const Car = class {
    constructor(props) {
        Object.assign(this, props);
    }

    toString() {
        return `${this.model} has done ${this.miles} miles`;
    }
}

// Usage:
 
const civic = new Car( {model: &quot;Honda Civic&quot;, year: 2009, miles: 20000} );
const mondeo = new Car( {model: &quot;Honda Civic&quot;, year: 2009, miles: 20000} );
 
console.log( civic.toString() );
console.log( mondeo.toString() );
</code></pre>

<h3 id="constructors-with-es6-class-for-node-js">Constructors with ES6 class for Node.js</h3>

<pre><code class="language-js">// in the end/or better on the beginning share you constructor
module.exports = Car;
</code></pre>

<h3 id="constructors-in-angular1-x">Constructors in Angular1.x</h3>

<pre><code class="language-js">// Task.factory.js
const app = angular.module('taskManager');

app.factory('Task', () =&gt; {
    const Task = class {
        constructor(name) {
            this.name = name;
            this.completed = false;
        }

        complete() {
            this.complete = true;
            console.log(`compete task: ${this.name}`);
        }

        save() {
            console.log(`save task: ${this.name}`); 
        }
    }

    return Task;
})
</code></pre>

<h2 id="the-module-pattern">The Module Pattern</h2>

<p>Modules are an integral piece of any robust application&rsquo;s architecture and typically help in keeping the units of code for a project both cleanly separated and organized.</p>

<p>In JavaScript, there are several options for implementing modules. These include:</p>

<ul>
<li>The Module pattern</li>
<li>Object literal notation</li>
<li>AMD modules</li>
<li>CommonJS modules</li>
<li>ES6 modules</li>
</ul>

<h3 id="the-revealing-module-pattern">The Revealing Module Pattern</h3>

<p>We would simply define all of our functions and variables in the private scope and return an anonymous object with pointers to the private functionality we wished to reveal as public:</p>

<pre><code class="language-js">var myRevealingModule = (function () {
    var privateVar = &quot;Ben Cherry&quot;,
        publicVar = &quot;Hey there!&quot;;

    function privateFunction() {
        console.log( &quot;Name:&quot; + privateVar );
    }

    function publicSetName( strName ) {
        privateVar = strName;
    }

    function publicGetName() {
        privateFunction();
    }


    // Reveal public pointers to
    // private functions and properties

    return {
        setName: publicSetName,
        greeting: publicVar,
        getName: publicGetName
    };

})();

myRevealingModule.setName( &quot;Paul Kinlan&quot; );
</code></pre>

<h3 id="the-module-pattern-for-node-js">The Module Pattern for Node.js</h3>

<pre><code class="language-js">// just export what you need

module.exports = myRevealingModule();
</code></pre>

<pre><code class="language-js">// Usage:
var myModule = require('./myRevealingModule');

// module.setName...
</code></pre>

<h3 id="the-module-pattern-for-angular1-x">The Module Pattern for Angular1.x</h3>

<pre><code class="language-js">// taskRepo.factory.js
const = app.module(taskManager);

app.factory(taskRepo);

function taskRepo($http) {
    const db = {};

    const get = (id) =&gt; {
        log(`Getting task ${id}`);
    }

    const save = (task) =&gt; {
        log(`Save ${task.nae} to the db`);
    }

    return { get, save };
}
taskRepo.$inject = ['$http'];
</code></pre>

<h2 id="the-singleton-pattern">The Singleton Pattern</h2>

<p>In JavaScript, <strong>Singletons</strong> serve as a shared resource namespace which isolate implementation code from the global namespace so as to provide a single point of access for functions:</p>

<pre><code class="language-js">class Singleton {

  static instance;

  constructor(){
    if(instance){
      return instance;
    }

    this.state = &quot;duke&quot;;
    this.instance = this;
  }

}

// usage
const first = new Singleton();
const second = new Singleton();

console.log(first === second); // true
</code></pre>

<h3 id="the-singleton-pattern-for-node-js">The Singleton Pattern for Node.js</h3>

<p>From <strong>Node.js</strong> docs information about <a href="https://nodejs.org/dist/latest-v5.x/docs/api/modules.html#modules_caching">caching modules</a>:</p>

<p>Modules are cached after the first time they are loaded. This means (among other things) that every call to <code>require('foo')</code> will get exactly the same object returned, if it would resolve to the same file.</p>

<p>If you want to have a module execute code multiple times, then export a function, and call that function.</p>

<pre><code class="language-js">// repo.js
// just return a function call
// for singleton

module.exports = repo();
</code></pre>

<pre><code class="language-js">// import a singleton
const require = repo();
</code></pre>

<h3 id="the-singleton-pattern-for-angular1-x">The Singleton Pattern for Angular1.x</h3>

<p>By default all service all singleton, because they are providers, more info <a href="https://docs.angularjs.org/guide/providers">here</a>.</p>

<h2 id="the-factory-pattern">The Factory Pattern</h2>

<p>Factory provide a generic interface for creating objects, where we can specify the type of factory object we wish to be created.</p>

<p>Imagine that we have a UI factory where we are asked to create a type of UI component. Rather than creating this component directly using the new operator or via another creation constructor, we ask a Factory object for a new component instead. We inform the Factory what type of object is required (e.g <em>Button</em>, <em>Panel</em>) and it instantiates this, returning it to us for use:</p>

<pre><code class="language-js">// Types.js - Constructors used behind the scenes
 
// A constructor for defining new cars
function Car( options ) {
 
  // some defaults
  this.doors = options.doors || 4;
  this.state = options.state || &quot;brand new&quot;;
  this.color = options.color || &quot;silver&quot;;
 
}
 
// A constructor for defining new trucks
function Truck( options){
 
  this.state = options.state || &quot;used&quot;;
  this.wheelSize = options.wheelSize || &quot;large&quot;;
  this.color = options.color || &quot;blue&quot;;
}
 
 
// FactoryExample.js
 
// Define a skeleton vehicle factory
function VehicleFactory() {}
 
// Define the prototypes and utilities for this factory
 
// Our default vehicleClass is Car
VehicleFactory.prototype.vehicleClass = Car;
 
// Our Factory method for creating new Vehicle instances
VehicleFactory.prototype.createVehicle = function ( options ) {
 
  switch(options.vehicleType){
    case &quot;car&quot;:
      this.vehicleClass = Car;
      break;
    case &quot;truck&quot;:
      this.vehicleClass = Truck;
      break;
    //defaults to VehicleFactory.prototype.vehicleClass (Car)
  }
 
  return new this.vehicleClass( options );
 
};
 
// Create an instance of our factory that makes cars
var carFactory = new VehicleFactory();
var car = carFactory.createVehicle( {
            vehicleType: &quot;car&quot;,
            color: &quot;yellow&quot;,
            doors: 6 } );
 
// Test to confirm our car was created using the vehicleClass/prototype Car
 
// Outputs: true
console.log( car instanceof Car );
 
// Outputs: Car object of color &quot;yellow&quot;, doors: 6 in a &quot;brand new&quot; state
console.log( car );
</code></pre>

<h3 id="abstract-factories">Abstract Factories</h3>

<p>It is also useful to be aware of the Abstract Factory pattern, which aims to encapsulate a group of individual factories with a common goal.</p>

<p>It separates the details of implementation of a set of objects from their general usage:</p>

<pre><code class="language-js">var abstractVehicleFactory = (function () {
 
  // Storage for our vehicle types
  var types = {};
 
  return {
      getVehicle: function ( type, customizations ) {
          var Vehicle = types[type];
 
          return (Vehicle ? new Vehicle(customizations) : null);
      },
 
      registerVehicle: function ( type, Vehicle ) {
          var proto = Vehicle.prototype;
 
          // only register classes that fulfill the vehicle contract
          if ( proto.drive &amp;&amp; proto.breakDown ) {
              types[type] = Vehicle;
          }
 
          return abstractVehicleFactory;
      }
  };
})();
 
 
// Usage:
abstractVehicleFactory.registerVehicle( &quot;car&quot;, Car );
abstractVehicleFactory.registerVehicle( &quot;truck&quot;, Truck );
 
// Instantiate a new car based on the abstract vehicle type
var car = abstractVehicleFactory.getVehicle( &quot;car&quot;, {
            color: &quot;lime green&quot;,
            state: &quot;like new&quot; } );
 
// Instantiate a new truck in a similar manner
var truck = abstractVehicleFactory.getVehicle( &quot;truck&quot;, {
            wheelSize: &quot;medium&quot;,
            color: &quot;neon yellow&quot; } );
</code></pre>

<h1 id="structural-design-patterns-in-depth">Structural Design Patterns in depth</h1>

<p>Structural design patterns are ones that focus on easing the relationship between different components of an application. They help to provide stability by ensuring that if one part of the app changes, the entire thing doesn&rsquo;t need to as well.</p>

<h2 id="mixins">Mixins</h2>

<p>Mixins allow objects to borrow (or inherit) functionality from them with a minimal amount of complexity.</p>

<p>Imagine that we define a Mixin containing utility functions in a standard object literal as follows:</p>

<pre><code class="language-js">var myMixins = {
 
  moveUp: function(){
    console.log( &quot;move up&quot; );
  },
 
  moveDown: function(){
    console.log( &quot;move down&quot; );
  },
 
  stop: function(){
    console.log( &quot;stop! in the name of love!&quot; );
  }
 
};
</code></pre>

<p>We can then easily extend the prototype of existing constructor functions to include this behavior using a helper such as the Underscore.js <code>_.extend()</code> method:</p>

<pre><code class="language-js">// A skeleton carAnimator constructor
function CarAnimator(){
  this.moveLeft = function(){
    console.log( &quot;move left&quot; );
  };
}
 
// A skeleton personAnimator constructor
function PersonAnimator(){
  this.moveRandomly = function(){ /*..*/ };
}
 
// Extend both constructors with our Mixin
_.extend( CarAnimator.prototype, myMixins );
_.extend( PersonAnimator.prototype, myMixins );
 
// Create a new instance of carAnimator
var myAnimator = new CarAnimator();
myAnimator.moveLeft();
myAnimator.moveDown();
myAnimator.stop();
 
// Outputs:
// move left
// move down
// stop! in the name of love!
</code></pre>

<h3 id="mixins-with-es6">Mixins with ES6</h3>

<pre><code class="language-js">Object.assign( CarAnimator.prototype, myMixins );
Object.assign( PersonAnimator.prototype, myMixins );
</code></pre>

<h2 id="the-decorator-pattern">The Decorator Pattern</h2>

<p>The Decorator pattern isn&rsquo;t heavily tied to how objects are created but instead focuses on the problem of extending their functionality.</p>

<p>Adding new attributes to objects in JavaScript is a very straight-forward process so with this in mind, a very simplistic decorator may be implemented as follows:</p>

<pre><code class="language-js">// The constructor to decorate
function MacBook() {
 
  this.cost = function () { return 997; };
  this.screenSize = function () { return 11.6; };
 
}
 
// Decorator 1
function memory( macbook ) {
 
  var v = macbook.cost();
  macbook.cost = function() {
    return v + 75;
  };
 
}
 
// Decorator 2
function engraving( macbook ){
 
  var v = macbook.cost();
  macbook.cost = function(){
    return v + 200;
  };
 
}
 
// Decorator 3
function insurance( macbook ){
 
  var v = macbook.cost();
  macbook.cost = function(){
     return v + 250;
  };
 
}
 
var mb = new MacBook();
memory( mb );
engraving( mb );
insurance( mb );
 
// Outputs: 1522
console.log( mb.cost() );
 
// Outputs: 11.6
console.log( mb.screenSize() );
</code></pre>

<h3 id="the-decorator-pattern-in-angular1-x">The Decorator Pattern in Angular1.x</h3>

<p>More information about <code>decorator</code> method in <a href="https://docs.angularjs.org/api/auto/service/$provide#decorator">off documentation</a> or <a href="http://www.bennadel.com/blog/2870-using-module-decorator-in-angularjs-1-4.htm">here</a></p>

<pre><code class="language-js">angular.module( &quot;Demo&quot;, [] );

angular.module( &quot;Demo&quot; ).run(
    function runBlock( greeting ) {
        console.log( greeting( &quot;Joanna&quot; ) );
    }
);  

angular.module( &quot;Demo&quot; ).factory(
    &quot;greeting&quot;,
    function greetingFactory() {
        return( greeting );
        // I return a greeting for the given name.
        function greeting( name ) {
            return( &quot;Hello &quot; + name + &quot;.&quot; );
        }
    }
);

angular.module( &quot;Demo&quot; ).decorator(
    &quot;greeting&quot;,
    function greetingDecorator( $delegate ) {
        // Return the decorated service.
        return( decoratedGreeting );
        // I append a new message to the existing greeting.
        function decoratedGreeting( name ) {
            return( $delegate( name ) + &quot; How are you doing?&quot; );
        }
    }
);
</code></pre>

<h2 id="sub-classing">Sub-classing</h2>

<p>Sub-classing is a term that refers to inheriting properties for a new object from a base or superclass object. In traditional object-oriented programming, a class <code>B</code> is able to extend another class <code>A</code>. Here we consider <code>A</code> a superclass and <code>B</code> a subclass of <code>A</code>. As such, all instances of <code>B</code> inherit the methods from <code>A</code>. <code>B</code> is however still able to define its own methods, including those that override methods originally defined by <code>A</code>.</p>

<p>We first need a base object:</p>

<pre><code class="language-js">var Person = function( firstName, lastName ){
 
  this.firstName = firstName;
  this.lastName = lastName;
  this.gender = &quot;male&quot;;
 
};
</code></pre>

<p>Next, we&rsquo;ll want to specify a new class (object) that&rsquo;s a subclass of the existing Person object:</p>

<pre><code class="language-js">// a new instance of Person can then easily be created as follows:
var clark = new Person( &quot;Clark&quot;, &quot;Kent&quot; );
 
// Define a subclass constructor for for &quot;Superhero&quot;:
var Superhero = function( firstName, lastName, powers ){
 
    // Invoke the superclass constructor on the new object
    // then use .call() to invoke the constructor as a method of
    // the object to be initialized.
 
    Person.apply( this, arguments );
 
    // Finally, store their powers, a new array of traits not found in a normal &quot;Person&quot;
    this.powers = powers;
};
 
Superhero.prototype = Object.create( Person.prototype );
var superman = new Superhero( &quot;Clark&quot;, &quot;Kent&quot;, [&quot;flight&quot;,&quot;heat-vision&quot;] );
</code></pre>

<h2 id="sub-classing-with-es6">Sub-classing with ES6</h2>

<pre><code class="language-js">class Person {
  constructor ( firstName, lastName, gender = &quot;male&quot; ){
  
    Object.assign(this, { firstName, lastName, gender });
  
  };
}

class Superhero extends Person {
  constructor ( firstName, lastName, gender, powers ){
    super(firstName, lastName, gender);
    this.powers = powers;
  };
}

// usage
const superman = new Superhero( &quot;Clark&quot;, &quot;Kent&quot;, &quot;female&quot;, [&quot;flight&quot;,&quot;heat-vision&quot;] );
</code></pre>

<h2 id="the-facade-pattern">The Facade Pattern</h2>

<p>This pattern provides a convenient higher-level interface to a larger body of code, hiding its true underlying complexity.</p>

<p>Whenever we use jQuery&rsquo;s <code>$(el).css()</code> or <code>$(el).animate()</code> methods, we&rsquo;re actually using a Facade - the simpler public interface that avoids us having to manually call the many internal methods in jQuery core required to get some behavior working.</p>

<p>In a similar manner, we&rsquo;re all familiar with jQuery&rsquo;s <code>$(document).ready(..)</code>. Internally, this is actually being powered by a method called <code>bindReady()</code>, which is doing this:</p>

<pre><code class="language-js">bindReady: function() {
    ...
    if ( document.addEventListener ) {
      // Use the handy event callback
      document.addEventListener( &quot;DOMContentLoaded&quot;, DOMContentLoaded, false );
 
      // A fallback to window.onload, that will always work
      window.addEventListener( &quot;load&quot;, jQuery.ready, false );
 
    // If IE event model is used
    } else if ( document.attachEvent ) {
 
      document.attachEvent( &quot;onreadystatechange&quot;, DOMContentLoaded );
 
      // A fallback to window.onload, that will always work
      window.attachEvent( &quot;onload&quot;, jQuery.ready );
               ...
</code></pre>

<h2 id="flyweight">Flyweight</h2>

<p>The Flyweight pattern is a classical structural solution for optimizing code that is repetitive, slow and inefficiently shares data. It aims to minimize the use of memory in an application by sharing as much data as possible with related objects</p>

<p>There are two ways in which the Flyweight pattern can be applied. The first is at the <strong>data-layer</strong>, where we deal with the concept of sharing data between large quantities of similar objects stored in memory.</p>

<p>The second is at the <strong>DOM-layer</strong> where the Flyweight can be used as a central event-manager to avoid attaching event handlers to every child element in a parent container we wish to have some similar behavior.</p>

<h1 id="behavior-design-patterns-in-depth">Behavior Design Patterns in depth</h1>

<h2 id="the-observer">The observer</h2>

<p>The Observer is a design pattern where an object (known as a subject) maintains a list of objects depending on it (observers), automatically notifying them of any changes to state.</p>

<p>We can now expand on what we&rsquo;ve learned to implement the Observer pattern with the following components:</p>

<ul>
<li>Subject: maintains a list of observers, facilitates adding or removing observers</li>
<li>Observer: provides a update interface for objects that need to be notified of a Subject&rsquo;s changes of state</li>
<li>ConcreteSubject: broadcasts notifications to observers on changes of state, stores the state of ConcreteObservers</li>
<li>ConcreteObserver: stores a reference to the ConcreteSubject, implements an update interface for the Observer to ensure state is consistent with the Subject&rsquo;s</li>
</ul>

<p>First, let&rsquo;s model the list of dependent Observers a subject may have:</p>

<pre><code class="language-js">function ObserverList(){
  this.observerList = [];
}
 
ObserverList.prototype.add = function( obj ){
  return this.observerList.push( obj );
};
 
ObserverList.prototype.count = function(){
  return this.observerList.length;
};
 
ObserverList.prototype.get = function( index ){
  if( index &gt; -1 &amp;&amp; index &lt; this.observerList.length ){
    return this.observerList[ index ];
  }
};
 
ObserverList.prototype.indexOf = function( obj, startIndex ){
  var i = startIndex;
 
  while( i &lt; this.observerList.length ){
    if( this.observerList[i] === obj ){
      return i;
    }
    i++;
  }
 
  return -1;
};
 
ObserverList.prototype.removeAt = function( index ){
  this.observerList.splice( index, 1 );
};
</code></pre>

<p>The Subject and the ability to add, remove or notify observers on the observer list:</p>

<pre><code class="language-js">function Subject(){
  this.observers = new ObserverList();
}
 
Subject.prototype.addObserver = function( observer ){
  this.observers.add( observer );
};
 
Subject.prototype.removeObserver = function( observer ){
  this.observers.removeAt( this.observers.indexOf( observer, 0 ) );
};
 
Subject.prototype.notify = function( context ){
  var observerCount = this.observers.count();
  for(var i=0; i &lt; observerCount; i++){
    this.observers.get(i).update( context );
  }
};
</code></pre>

<p>Full example <a href="http://plnkr.co/edit/w0wkN2BPIWK1PF3Nt8ZD">here</a></p>

<h2 id="differences-between-the-observer-and-publish-subscribe-pattern">Differences Between The Observer And Publish/Subscribe Pattern</h2>

<p>Whilst the <em>Observer</em> pattern is useful to be aware of, quite often in the JavaScript world, we&rsquo;ll find it commonly implemented using a variation known as the <em>Publish/Subscribe</em> pattern.</p>

<p>The Publish/Subscribe pattern however uses a topic/event channel which sits between the objects wishing to receive notifications (subscribers) and the object firing the event (the publisher).</p>

<p>This event system allows code to define application specific events which can pass custom arguments containing values needed by the subscriber. The idea here is to avoid dependencies between the subscriber and publisher.</p>

<p>Here is an example of how one might use the Publish/Subscribe if provided with a functional implementation powering <code>publish()</code>,<code>subscribe()</code> and <code>unsubscribe()</code> behind the scenes:</p>

<pre><code class="language-js">var eventBus = (function(){
  var topics = Object.create({});
  
  return {
    subscribe: function(topic, listener) {
      // Create the topic's object if not yet created
      if(!topics[topic]) topics[topic] = [];

      // Add the listener to queue
      var index = topics[topic].push(listener) -1;

      // Provide handle back for removal of topic
      return {
        unsubscribe: function() {
          delete topics[topic][index];
        }
      };
    },
    publish: function(topic, info) {
      // If the topic doesn't exist, or there's no listeners in queue, just leave
      if(!topics[topic]) return;

      // Cycle through topics queue, fire!
      topics[topic].forEach(function(item) {
            item(info != undefined ? info : {});
      });
    }
  };
})();
</code></pre>

<p>Subscribe in order to be notified for events:</p>

<pre><code>var subscription = events.subscribe('/page/load', function(obj) {
    // Do something now that the event has occurred
});

// ...sometime later where I no longer want subscription...
subscription.unsubscribe();
</code></pre>

<p>Publishing:</p>

<pre><code class="language-js">events.publish('/page/load', {
    url: '/some/url/path' // any arguments
});
</code></pre>
</article>



</div>
</div>
<script src="../../../../js/theme.min.js" type="text/javascript"></script>


</body>
</html>

