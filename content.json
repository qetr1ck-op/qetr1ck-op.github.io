{"meta":{"title":"Blog | qetr1ck-op","subtitle":null,"description":null,"author":"Orest Prystayko","url":"http://qetr1ck-op.github.io"},"pages":[{"title":"all-categories","date":"2016-01-31T20:58:58.524Z","updated":"2016-01-31T20:58:58.524Z","comments":true,"path":"all-categories/index.html","permalink":"http://qetr1ck-op.github.io/all-categories/index.html","excerpt":"","text":""},{"title":"all-tags","date":"2016-01-31T20:58:58.525Z","updated":"2016-01-31T20:58:58.525Z","comments":true,"path":"all-tags/index.html","permalink":"http://qetr1ck-op.github.io/all-tags/index.html","excerpt":"","text":""},{"title":"all-archives","date":"2016-01-31T20:58:58.524Z","updated":"2016-01-31T20:58:58.524Z","comments":true,"path":"all-archives/index.html","permalink":"http://qetr1ck-op.github.io/all-archives/index.html","excerpt":"","text":""}],"posts":[{"title":"Reset, Checkout and Revert","slug":"Reset-Checkout-and-Revert","date":"2016-11-06T09:24:39.000Z","updated":"2016-11-06T11:22:08.727Z","comments":true,"path":"2016/11/06/Reset-Checkout-and-Revert/","link":"","permalink":"http://qetr1ck-op.github.io/2016/11/06/Reset-Checkout-and-Revert/","excerpt":"The git reset, git checkout and git revert let you to undo changes in repository, and the first two can be use to manipulate either commits or individual files.","text":"The git reset, git checkout and git revert let you to undo changes in repository, and the first two can be use to manipulate either commits or individual files. The image bellow will help to think about each command in terms of their effect on the three main components of Git workflow. Keep this components always in mind when you’re working with this commands. ResetOn the commit-level, resetting is way to move a tip of a branch to a different commit. This can be used to remove commits from the current branch. Following command moves branch backwards by two commits: 12git checkout hotfixgit reset HEAD~2 In other words, you’re saying that you want to throw away this commits: This usage of git reset is a simple way to undo changes that haven’t been shared with any one else. I use this command when I’ve started working on feature find myself thinking that, “Oh crap, what am I doing? I should start over”. There are following flags: --soft - the stage and working areas are not altered in this way --mixed - only the staged area is affected. This is option be default --hard - the stage and working are both updated to match the specific commit It’s easer to thing of these modes by their scope: The command is often used with HEAD or with serious of commits hash as the parameter: 1234567891011121314# has effect on unstaging all changes, but leaves them in a working directorygit reset --mixed HEAD# completely throw away all changesgit reset --hard HEAD# reset a specif commitgit reset --hard &lt;commit-hash&gt;# reset a series using ancestor notationgit reset dev~5..dev# reset a series using commit hashesgit reset --no-edit ffffffff..12345678 Be careful when passing other than HEAD, since this re-writes the current branch history CheckoutWhen passed a branch name, it lets you to switch between branches: 1git checkout hotfix Internally it moves HEAD to a different branch updates the working directory to match. Since this has a potential to overwrite local changes, Git forces you to commit or stash any changes in a working directory. Unlike git reset it doesn’t move any branches around. I can also check arbitrary commits by passing the commit reference of the branch: 1git checkout HEAD~2 This is useful for quickly inspecting an old version of your project. However, since there are no reference to the current HEAD, this puts you in a detached HEAD state. This can be dangerous if you start adding new commits, because there won’t be a way to get back them after you switch to an another branch. For this reason, you should always create a new branch before adding commits to a detached HEAD. RevertReverting undoes a commit by creating a new commit. This is a safe way to undo changes, as it has no change of re-writing the commit history. For example, the following command will figure out the changes in the 2nd to last commit, create a new commit to undoing these changes: 12git checkout hotfixgit revert HEAD~2 That can be visualized as following: Contrast this with git reset, which does alter the existing commit history. For this reason git revert should be used to undo changes on a public branch and git reset should be reserved for undoing changes on a private branch. You can also think of a git revert as a tool for undoing committed changes, while git reset HEAD is for undoing uncommitted changes. If I just want to revert with a specific commit I use --no-commit: 123# -n is shortcut for --no-commitgit revert -n &lt;commit hash&gt;git commit -m 'the commit message' Another flow can be if you want to revert multiple commits: 1234git revert --no-commit &lt;commit hash A&gt;git revert --no-commit &lt;commit hash B&gt;git revert --no-commit &lt;commit hash C&gt;git commit -m 'the commit message' If there are sequence of commits which I want to revert: 1234git revert --no-commit HEAD~3..# orgit revert --no-commit A..HEAD git commit -m 'the commit message' The problem can be appeared when you want to revert a merge commit. The -m parameter specified the parent number. This is need because a merge commit has more than one parent, and Git doesn’t know which parent was the mainline, and which parent was the branch you want to un-merge. 123git revert -m 1 &lt;commit-hash&gt; git commit -m \"Reverting the last merge-commit which messed the repo.\"git push -u origin master The dedicating answer about how to revert merged commit which has been pushed on remote here Save my day: Advanced Git Tutorials","categories":[],"tags":[]},{"title":"Node.js design pattern book review","slug":"Node-js-design-pattern-book-review","date":"2016-10-06T18:11:33.000Z","updated":"2016-11-13T21:08:51.323Z","comments":true,"path":"2016/10/06/Node-js-design-pattern-book-review/","link":"","permalink":"http://qetr1ck-op.github.io/2016/10/06/Node-js-design-pattern-book-review/","excerpt":"“How could I organize my code?”, “What is the best way to design this?”, “How can I make my application more modular?”, “How do I handle a set of asynchronous call effectively?”, “How can I make sure that my application will not collapse while it grows?”. If you have such questions without answers, that book is definitely for you! The aim of this book is to guide you through this emerging world of patterns, techniques and practices, showing proven solution to the common problem.","text":"“How could I organize my code?”, “What is the best way to design this?”, “How can I make my application more modular?”, “How do I handle a set of asynchronous call effectively?”, “How can I make sure that my application will not collapse while it grows?”. If you have such questions without answers, that book is definitely for you! The aim of this book is to guide you through this emerging world of patterns, techniques and practices, showing proven solution to the common problem. Chapter 1: Welcome to the Node.js platformThe Node.js philosophySome of these principles arise from the technology itself, some of them are enabled by its ecosystem, some are just trends in community, some directly comes from its creator, another are influenced by the Unix culture. Small core Small modules Small surface area Simplicity and pragmatism I/O is slowI/O is definitely the slowest among the fundamental operations of a computer. Accessing to RAM is in the order of nanoseconds, while accessing data on disk the network is in order of milliseconds. For the bandwidth is the same story. RAM has a transfer rate consistently in the order of GB/s, while disk and network varies from MB/s to, optimistically, GB/s. On the top of that, we also have to consider the human factor. Often input of an application comes from a real person, so the speed or frequency of I/O doesn’t only depend on technical aspects. Blocking I/OIn traditional blocking I/O programming the function call corresponding to an I/O request will block the execution of the thread until the operation completes. 1234// block the thread until the data is availabledata = socket.read()// data is availableprint(data) It’s trivial to notice how web-server which is using blocking I/O will not be able to handle multiple connection in the same thread. Each operation will block the processing of any other connection: The preceding image emphasis on the amount of time each thread is idle, waiting for new data to be received from associated connection. Also we need to consider how much time of I/O can possibly block a request, for example, while interacting with database or with filesystem. Non-blocking I/O with “busy-waiting”In this operation mode, the system call always returns immediately without waiting for data to be read or written. If no result are available at the moment of call, the function will simply return a predefined constant, indicating that there is no data available to return at the moment. The most basic pattern for accessing this kind of non-blocking I/O is busy-waiting - it actively poll the resource within a loop until some actual data is returned. 1234567891011121314151617181920resource = [socketA, socketB, pipeA]while(!resources.isEmpty()) &#123; foreach resource in resources &#123; // try to read let data = resource.read() if (data === NO_DATA_AVAILABLE) &#123; // there is no data to read at the moment continue &#125; if (data === RESOUCE_CLOSED) &#123; // there was closed, remove it from list resources.remove(resource) &#125; else &#123; // data was received, proceed it consumeData(data) &#125; &#125;&#125; With this technique it’s already possible to achieve handling different resources in the same thread, but still it isn’t efficient. Event demultiplexingLuckily, most modern operation systems provide a mechanism to handle concurrent, non-blocking resources in efficient way. It’s a synchronous event demultiplexing or event notification interface - it’s collect and queues I/O events that come from set of watched resources, and block until new events are available for process. 12345678910111213141516171819watchedList.add(socketA, FOR_READ)watchedList.add(socketB, FOR_READ)watchedList.add(pipeA, FOR_READ) // [1]while(events = demultiplexer.watch(watchedList)) &#123; // [2] // event loop foreach (event in events) &#123; // [3] // this read operation won't never block // and we will always return data data = event.resource.read() if (data === RESOUCE_CLOSED) &#123; // remove from watched list demultiplexer.unwatch(event.resource) &#125; else &#123; // data was received, proceed it consumeData(data) &#125; &#125;&#125; The resources was added to a data structure, associated with specific operation The event notifier is set up with the group of resources to be watched. This call is synchronous and blocks until any of watched resource is ready for read operation. When the resource is ready for an operation the event demultiplexer returns from the call new set of events. Each event is proceed. At this point, the resource associated with each event is guaranteed to be ready to processing and not to block during the operation. When all events are processed, the flow will be blocked again on the event demultiplexer until new events are again available to be proceed. This is called the event loop It’s interesting that with this pattern, we can now handle several I/O operation inside a single thread. How web-server will handle multiple requests using synchronous event demultiplexer with single thread: The reactor patternThe main idea behind it is to have a handler (which in Node.js is represented by callback function) associated with each I/O operation, which will be invoked as soon as an event is produces and processed by event loop: What’s happen when application use the reactor patter: The application generates a new I/O operation by submitting a request to event demultiplexer. Also application specified a handler, which will be invoked when the operation is completes. Submitting a new request is non-blocking call and it immediately returns control to the application When set of I/O operation completes, the event demultiplexer pushes the new events into the event loop At this point, event loop iterates over the items of the event queue For each event, the associated handler is invoked (a) The handler which is a part of application code, will give control to event loop when it’s execution completes. (b) However, new asynchronous operation might be requested during the execution of handler, causing new operation to registered in the event demultiplexer, before control is given back to event loop When all items are processed in event queue, the loop will blocked again on event demultiplexer which will trigger another cycle of when a new events are available A Node.js application will exit automatically when there are no more pending operation in event demultiplexer and no more events to be processed in event queue Pattern Reactor handles I/O by blocking until new events are available from a set of observable resources and then reacts by dispatching each event with associated handler. The non-blocking I/O engine of Node.js-libuvEach operation system has its own interface for the event demultiplexer. Besides that, each I/O operation can behave quite differently depending on type of resource, even within the same OS. All this inconsistencies required a higher abstraction for event demultiplexer. This is exactly why Node.js core created a C library called libuv with objective to make Node.js compatible with all the major platform and normalize the non-blocking behavior of the different types of resource. The building blocks of Node.js platformThe reactor pattern and libuv are the basic building blocks but we need the following three other components to build the full platform: a set of bindings responsible for wrapping and expose libuv and other low-level functionality to Javascript V8 the Javascript engine, this one of the reason why Node.js is so fast and efficient a node-core that implements the high-level Node.js API Chapter 2: Node.js essential patternsIn this chapter, we’ll use two of the most important asynchronous patterns: callback and event-emitter The callback patternCallbacks are materialization of the handlers of the reactor pattern. Callback is a function that is invoked to propagate the result of an operation and this is exactly what we need when we dealing with asynchronous operation. Another ideal construct for implementing callbacks is closure The continue-passing style In Javascript, a callback is a function that is passed as an argument to another function and is invoked with the result when operation is complete. Meanwhile, in function programming, this way of propagating the result is called continuation-passing style (CPS) To clarify the concept lets see a direct style: 123function add(a, b) &#123; return a + b;&#125; The equivalent continue-passing style would be as follow: 123function add(a, b, callback) &#123; callback(a + b);&#125; Since add() is a synchronous CPS function the result will be: 1234567console.log('before');add(1, 2, result =&gt; console.log(`Result $&#123;result&#125;`));console.log('after');// before// Result 3// after Asynchronous continue-passing styleLets consider a case where the add() function is asynchronous: 1234567891011function addAsync(a, b, callback) &#123; setTimeout(callback(a + b));&#125;console.log('before');addAsync(1, 2, result =&gt; console.log(`Result $&#123;result&#125;`));console.log('after');// before// after// Result 3 Since setTimeout() triggers an asynchronous operation, it won’t wait for the callback to be executed, but instead, it returns immediately, giving control back to addAsync() and then back to its caller. This is crucial and following image shows how it works: The execution will start from the event loop so it will have a fresh stack. Thanks to closure it’s trivial to maintain the context of the caller in asynchronous function. Synchronous or asynchronous?The following is an analysis of these two paradigms and their pitfalls. An unpredictable functionOne of the most dangerous situation is to have API that behaves synchronously under certain conditions and asynchronous under others: 123456789101112131415const fs = require('fs');const cache = &#123;&#125;;function inconsistentRead(filename, callback) &#123; if (cache[filename]) &#123; // invoked synchronously callback(cache[filename]); &#125; else &#123; // async call fs.readFile(filename, 'utf8', (err, data) =&gt; &#123; cache[filename] = data; callback(data); &#125;) &#125;&#125; Unleashing ZalgoNow lets see how to use an unpredictable function, such as to easily break an application: 1234567891011function createFileReader(filename) &#123; const listeners = []; incosistentRead(filename, value =&gt; &#123; listeners.forEach(listener =&gt; listener(value)); &#125;) return &#123; onDateReady: listener =&gt; listeners.push(listener) &#125;&#125; When the preceding function is invoked, it creates a new object that acts as notifier, allowing us to set multiple listeners for a file read operation. All listeners will be invoked at once when the read operation completes and the data is available: 123456789101112const reader1 = createFileReader('data.txt');reader1.onDateReady(data =&gt; &#123; console.log(`First data call ready: $&#123;data&#125;`); // same time letter we try to read the same file again const reader2 = createFileReader('data.txt'); reader2.onDateReady(data =&gt; &#123; console.log(`Second data call ready: $&#123;data&#125;`); &#125;)&#125;) The result output is: 1First data call ready: foo bar here! You can see the callback of the second operation is never invoked. Lets see why: During the creation of reader1, our inconsistentRead() function behaves asynchronously, because there isn’t cached result. Therefore, we have all time in the world to register our listener, as it will invoked later in another cycle of event loop, when the read operation is complete. Then the reader2 is created when requested file is in the cache. In this case the inner call of inconsistentRead() will be synchronous. So its call back will be invoked immediately, which mean that listener of reader2 will be invoked synchronously as well. However, we registering the listeners after creation of reader2, so they will never be invoked! Using synchronous APIsOne suitable fix for our inconsistentRead() function is to make it totally synchronous: 12345678910const fs = require('fs');const cache = &#123;&#125;;function consistentRead(filename) &#123; if (cache[filename]) &#123; return cache[filename]; &#125; cache[filename] = fs.readFileSync(filename, 'utf8'); return cache[filename];&#125; There is no reason for a function to have a continue-passing style it’s synchronous. In fact, it’s always a best practice to implement synchronous API using a direct style. Pattern:Prefer direct style for purely synchronous function Bear in mind, that changing an API from CPS to a direct style (from asynchronous to synchronous or vice versa) require a change of style of all code using: 1234567891011function createFileReader(filename) &#123; const listeners = []; const fileData = consistentRead(filename) return &#123; onDateReady: listener =&gt; &#123; listeners.push(listener); listeners.forEach(listener =&gt; listener(fileData)); &#125; &#125;&#125; Using asynchronous operation with deferred executionThe trick here is to schedule the synchronous callback invocation to be executed “in the future”, instead of being run immediately in the same event loop cycle. In Node.js this is possible using process.nextTick(), which defers the execution of a function until next the event loop cycle. This function is a very simple, it takes a callback and pushes it to the top of event queue, in front of any pending I/O event, and returns control immediately. So callback will run be invoked as soon as the event loop runs again. Apply this technique to fix inconsistentRead(): 123456789101112131415const fs = require('fs');const cache = &#123;&#125;;function inconsistentRead(filename, callback) &#123; if (cache[filename]) &#123; // now invoked asynchronously process.nextTick(() =&gt; callback(cache[filename])); &#125; else &#123; // async call fs.readFile(filename, 'utf8', (err, data) =&gt; &#123; cache[filename] = data; callback(data); &#125;) &#125;&#125; Now, our function is guaranteed to invoke its callback asynchronous, under any circumstances. Another API for deferring the execution is setImmediate(). While their purposes are very similar, their semantics are quite different. Callback deferred with process.nextTick() run before any other I/O event fired, while with setImmediate(), the execution is queued behind any I/O event that is already in the queue. Since process.nextTick() runs before any already scheduled I/O, it might cause I/O starvation under certain circumstances, for example, a recursive invocation, this can never happen with setImmediate() Pattern:We guarantee that a callback is invoked asynchronously be deferring it execution using process.nextTick() Node.js callback conventionCPS APIs and callbacks follows a set of specific convention. Callback come lastIn all core Node.js methods, the standard convention is that when a function accept callback as input, this has to be passed as last parameter: 1fs.readFile(filename[, options], callback) Error comes firstIn Node.js, any errors produced by a CPS function is always passed as first argument of the callback, and any actual result is passed starting from the second argument. It the operation is succeeds without errors, the first error will be null or undefined: 1234567fs.readFile('foo.txt', 'utf8', (err, data) =&gt; &#123; if (err) &#123; handleError(err); &#125; else &#123; handleData(data); &#125;&#125;) Propagation errorsPropagation errors in synchronous, direct function is done with well-known throw statement. In CPS style however, proper propagation is done by passing the error to the next callback in the chain: 12345678910111213141516171819function readJson(filename, callback) &#123; fs.readFile(filename, 'utf8', (err, data) =&gt; &#123; let parsed; if (err) &#123; // propagate the error and exit return callback(err); &#125; try &#123; parsed = JSON.parse(data); &#125; catch(err) &#123; // catch parsing error return callback(err); &#125; // no error propagate just data callback(null, parsed); &#125;)&#125; The module system and its patternModules are bricks for structuring non-trivial application, but also the main mechanism to enforce hiding information by keeping private all the function and variable that are not explicitly marked to be exported. The revealing module patternOnce of the major problem in Javascript is an absence of namespacing. A popular technique to solve this issue is called the revealing module pattern: 1234567891011const module = (() =&gt; &#123; const privateFoo = () =&gt; &#123;&#125;; const privateBar = []; const exported = &#123; publicFoo: 'dataFoo', publicBar: 'dataBar', &#125; return export&#125;()) We have a private scope and exporting only the parts that are meant to be public. As we’ll see at the moment, the idea behind this pattern is used as a base for a Node.js module system. Node.js modules explainedCommonJS is a group with the aim to standardize the Javascript ecosystem, and one of their most popular proposal is CommonJS module system. Node.js built its module system on the top of this specification, with the addition of some custom extensions. A homemade module loaderTo explain how Node.js modules work let’s built a similar system from scratch. The code mimics a subset of functionality of original require: 1234567function loadModule(filename, module, require) &#123; const wrappedSrc = `function(module, module, require) &#123; $&#123;fs.readFileSync(filename, 'utf8')&#125; &#125;(module, module.exports, require)`; eval(wrappedSrc);&#125; Bear in mind, that this code is only for example, feature such as eval() or vm module can be easily used in a wrong way or with a wrong input to inject attack. They should be used always with extreme care. Now implementation of our require() function: 123456789101112131415161718192021222324252627function require(moduleName) &#123; console.log(`Require invoked for module: $&#123;moduleName&#125;`); const id = require.resolve(moduleName); // [1] if (require.cache[id]) &#123; // [2] return require.cache[id].exports; &#125; // module metadata const module = &#123; // [3] exports: &#123;&#125;, id &#125;; // update the cache require.cache[id] = module; // [4] // load the module loadModule(id, module, require); // [5] // return exported variables return module.exports; // [6]&#125;require.cache = &#123;&#125;;require.resolve = function(moduleName) &#123; // resolve a full module id from the moduleName&#125; What our homemade module system does is explain as follows: Module name is accepted as input, and the very first thing that we do is resolve the full path of module, and receive module id. It’s implementing by special resolving algorithm of require.resolve() If the module has already been loaded it should be available in the cache. If the module hasn’t loaded yet, we set up environment for the first load. The property module.exports will be used to export public API. The module object is cached. The loadModule() code reads from its file, and the code is evaluated. We provide the module with module object that we just created, and a reference to require() function. The module exports its public API by manipulation or replacing the module.exports object. Finally the content of module.exports is returned from caller. Defining a modulesBy looking how us require() works be are able to define a module: 1234567891011// module.js// load another module-dependencyconst dependency = require('./anotherModule');// private sectionfunction privateFoo() &#123;&#125;// the exported APImodule.exports.run = function publicBar() &#123; privateFoo()&#125; The essential concept to remember that everything in the module is private unless it’s assigned to module.exports Defining globalsIt’s still possible to define a global variable, in fact, module system exposes a special variable global, which can be used for this purpose “module.exports” VS “exports”A common source of confusion is the difference between using module.exports and exports to expose the public API. The code of our custom require function should again clear any doubts. The variable exports is just a reference to initial value of module.exports, essentially it’s an empty object before the module is loaded. This means that we can only attach new properties referencing by exports variable: 1exports.hello = () =&gt; &#123; console.log('Hello') &#125;; Reassigning the exports variable doesn’t have any sense, because it doesn’t change content of module.exports. That’s how object in Javascript works. The following code therefore is wrong: 1exports.hello = () =&gt; &#123; console.log('Hello') &#125;; If we want to export something other than an object literal, we can reassigning module.exports as follow: 1module.exports = () =&gt; &#123; console.log('Hello') &#125;; The “require” function is synchronousWe should take into account that our homemade require is synchronous. In fact, it returns the module contents using simple direct style therefore no callback is required. This is true for original Node.js require function too. As a consequence any assignments to module.exports must be synchronous. The following code is incorrect: 123setTimeout(() =&gt; &#123; module.exports = () =&gt; &#123;&#125;&#125;, 100); This is one of the important reasons why Node.js libraries offer synchronous APIs as alternative to asynchronous ones. The resolving algorithmNode.js solver the dependency hell elegantly by loading different version of module depending on where the module is loaded from. As we saw the resolve() function takes a module name (moduleName in our loader) as input, and it returns the full path of module. This path is used to load its code and to identify the module uniquely. The resolving algorithm can be divided into the following three major branches: file modules core modules package modules The resolving algorithm can be be found at official spec. The node_modules directory is where npm installs the dependencies of each package. Based on the algorithm, each package can have its own private dependencies. Consider the following structure: 123456789101112131415myApp├── foo.js└── node_modules ├── depA │ └── index.js ├── depB │ ├── bar.js │ └── node_modules │ └── depA │ └── index.js └── depC ├── foobar.js └── node_modules └── depA └── index.js Following rules of resolving algorithm, using require(&#39;depA&#39;) will load a different file depending on the module that requires it: Calling require(&#39;depA&#39;) from /myApp/foo.js will load /myApp/node_modules/depA/index.js Calling require(&#39;depA&#39;) from /myApp/node_modules/depB/bar.js will load /myApp/node_modules/depB/node_modules/depA/index.js Calling require(&#39;depA&#39;) from /myApp/node_modules/depC/foobar.js will load /myApp/node_modules/depc/node_modules/depA/index.js The module cacheEach module is only loaded and evaluated the first time it’s required, since any subsequent call of require() will return the cached version. Again, it should be clear by looking at the code of homemade require() function. The module cache is exposed via the require.cache reference, so it’s possible to directly access it if needed. Module definition patternsThe module system besides being a mechanism for loading dependencies, is also a tool for defining APIs. To aim is to maximize information hading and API usability, with balancing with other software quality such as code reuse and extensibility. Named exportsThe most basic method for exposing public API is using named exports, which consist to assignment all the public values to object referenced by exports or module.exports. Most of the Node.js core modules use this pattern. 1234567891011121314// file logger.jsexports.info = (msg) = &#123; console.log(`info: $&#123;msg&#125;`)&#125;;exports.verbose = (msg) = &#123; console.log(`verbose: $&#123;msg&#125;`)&#125;;// file main.jsconst logger = require('./logger');logger.info('Info massage');logger.verbose('Verbose massage'); Exporting a functionOne of the most popular module definition pattern consists of reassigning of the whole module.exports variable to the function. The main goal to provide a clear entry point for the module, making it simpler to understand and use. It also honors the principle of small area surface. This way of defining modules also is known as the substack pattern. 1234// file logger.jsmodule.exports = (msg) = &#123; console.log(`info: $&#123;msg&#125;`)&#125;; A possible extension for this pattern is using the exported function as namespace for other public APIs. This is a very powerful technique, because it still gives clarity of a single entry point. 12345678910// the same file logger.jsmodule.exports.verbose = (msg) = &#123; console.log(`verbose: $&#123;msg&#125;`)&#125;;// file main.jsconst logger = require('./logger');logger('Info massage');logger.verbose('Verbose massage'); Pattern:Substack or Single Responsibility Principle (SRP)Expose the main functionality of a module by exporting only one function. Use the exported function as a namespace to expose any auxiliary functionality Exporting a constructorThe difference is with this approach we allow user to create a new instance using the constructor with ability to extend its prototype and forge new classes. 1234567891011121314151617181920// file logger.jsclass Logger &#123; constructor(name) &#123; this.name = name; &#125; log(msg) &#123; console.log(`[$&#123;this.name&#125;] $&#123;msg&#125;`) &#125; info(msg) &#123; console.log(`info: $&#123;msg&#125;`) &#125; verbose(msg) &#123; console.log(`info: $&#123;msg&#125;`) &#125;&#125;module.exports = Logger; A variation of this pattern consists of applying a security check against invocation that doesn’t use new directive. This a little trick allows us to use our module as factory: 123456function LoggerFactory(name) &#123; if (!this instanceof Logger) &#123; return new Logger(name) &#125; return new Logger(name);&#125; A much cleaner approach is offered by ES6 new.targer which is available starting from Node.js v6. The syntax expose the new.targer which is called meta property, made available inside all the function, end evaluates to true at runtime if the function was called using the new directive. 123456function LoggerFactory(name) &#123; if (!new.target) &#123; return new Logger(name); &#125; return new Logger(name);&#125; Exporting an instanceWe can leverage the caching mechanism of require() to define stateful instance with a state created from a constructor or factory, shared across different modules: 123456789101112131415161718// file logger.jsclass Logger &#123; constructor(name) &#123; this.name = name; this.count = 0; &#125; log(msg) &#123; this.count++; console.log(`[$&#123;this.name&#125;] $&#123;msg&#125;`) &#125;&#125;module.exports = new Logger('default');// file main.jsconst logger = require('./logger.js');logger.log('test the singleton'); This is much like a singleton pattern, however it doesn’t guarantee the uniqueness of the instance across the whole application, as it happens with traditional singleton pattern. When analyzing the resolving algorithm, we have seen in fact, that a module might be installed multiple times inside the dependency tree of an application. Modifying other modules or the global scopeA module can even export nothing. We should not forger that module can modify the global scope and the object in it, including other modules in the cache. In general it’s considering as a bad practice. Pattern:Monkey patching is when module can modify other modules or object in global scope. It change the existing objects at runtime to change or extend their behavior or apply temporary fixes How we can add a new function to another module: 12345678// file patcher.jsrequire('./logger').customMessage = () =&gt; console.log('this is a new functionality');// main.jsrequire('./patcher');const logger = require('./logger');logger.customMessage(); The technique is dangerous, because it affects the state of entire app. The observer patternTogether with the reactor, callbacks and modules, the observer pattern is one of the pillars of the platform and is used by mane Node.js core and user-land modules. Pattern Observer:Defines an object (subject), which can notify a set of observers (listeners) when change is occur. The main difference from the callback pattern is that the subject can notify multiple observers, while a traditional CPS will propagate its result to only one listener, the callback. The EventEmitter classThe observer pattern built into core and it’s available through the EventEmitter class. It allows to register one or multiple function as listeners, which will be notified when a particular event type is fired. The following explains the concept: How to require EventEmitter from core events module: 12const EventEmitter = require('events');const eeInstance = new EventEmitter; The API is in official Node.js specification. We can already see that there is a big difference between a listener and a traditional Node.js callback, in particular, the first argument isn’t an error, but any data which is passed to emit() at the moment of invocation. Creating and using EventEmitterThe following code shows a function that uses EventEmitter to notify its subscribers in real time when a particular pattern is found in a list of files: 123456789101112131415161718192021222324const EventEmitter = require('events');const fs = require('fs');function findPattern(files, regexp) &#123; const emitter = new EventEmitter; files.forEach(file =&gt; &#123; fs.readFile(file, 'utf8', (err, content) =&gt; &#123; let match; if (err) &#123; emitter.emit('error', err); &#125; emitter.emit('fileread', file); if (match = content.match(regexp)) &#123; match.forEach(elem =&gt; emitter.emit('found', file, elem)) &#125; &#125;) &#125;) return emitter;&#125; Lets see how findPattern can be used: 1234567findPattern( ['data1.txt', 'data2.txt'], /foo \\w+/g) .on('fileread', file =&gt; console.log(`$&#123;file&#125; was read`)) .on('found', (file, match) =&gt; console.log(`matched $&#123;match&#125; in file $&#123;file&#125;`)) .on('error', err =&gt; console.log(`Error: $&#123;err&#125;`)) Extends from EventEmitter classTo demonstrate the pattern lets implement the functionality of the findPattern(): 1234567891011121314151617181920212223242526272829303132333435const EventEmitter = require('events');const fs = require('fs');class FindPattern extends EventEmitter &#123; constructor(regexp) &#123; super(); this.regexp = regexp; this.files = []; &#125; addFile(file) &#123; this.files.push(file); return this; &#125; find() &#123; this.files.forEach(file =&gt; &#123; fs.readFile(file, 'utf8', (err, content) =&gt; &#123; let match; if (err) &#123; this.emit('error', err); &#125; this.emit('fileread', content); if (match = content.match(this.regexp)) &#123; match.forEach(elem =&gt; this.emit('found', file, elem); ) &#125; &#125;) &#125;) return this; &#125;&#125; The FindPattern prototype extends EventEmitter. In this way it becomes a fully-fledged observable class. The usage: 12345678const findPatternObj = new FindPattern(/hello \\w+/g);findPatternObj .addFile('data1.txt') .addFile('data2.txt') .on('fileread', file =&gt; console.log(`$&#123;file&#125; was read`)) .on('found', (file, match) =&gt; console.log(`matched $&#123;match&#125; in file $&#123;file&#125;`)) .on('error', err =&gt; console.log(`Error: $&#123;err&#125;`)) This is a pretty common pattern in the Node.js ecosystem, for example, the Server object of the core HTTP module defines methods such as listen(), close(), setTimeout() and internally it inherits from the EventEmitter function. It allows to produce events such as request when a new connection is received, or connection when a new connection is established, or close when server is shut down. Combining callbacks with EventEmitterThere are also circumstances where EventEmitter can be combining with a callback. One example of this pattern is offered by the node-glob module, which performs a glob-style searching. The function glob(pattern, [options], callback) takes a callback that is invoked with the list of all files which are matched by the providing pattern. At the same time it returns EventEmitter that provides an interface to report over the state of the process: 1234const glob = require('glob');glob('*.txt', (err, files) =&gt; console.log(`Founded files: $&#123;JSON.stringify(files)&#125;`)) .on('match', match =&gt; console.log(`Matched files: $&#123;match&#125;`)) Chapter 3: Asynchronous control flow patterns with callbacksOne of the common mistake is to fail into the trap of the callback hell and see how the code is growing horizontally rather than vertically, with the nesting which makes even simple routine hard to read and maintain. In this chapter we we’ll see how it’s actually possible to tame callbacks and write clean, manageable asynchronous code with the aid of some patterns. Creating a simple web spiderTo explain the problem we’ll create a little CLI application that takes a web URL as input and downloads its contents locally into file. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273// file spider.jsconst fs = require('fs');const path = require('path');const request = require('request'); // HTTP request clientconst mkdirp = require('mkdirp'); // Recursively mkdir, like mkdir -pconst chalk = require('chalk'); // Terminal string styling done right.const utils = require('./utils');function spider(url, cb) &#123; const filePath = utils.urlToFilePath(url); const fileName = utils.urlToFileName(url); let isFileExists = false; fs.stat(filePath, (err, stats) =&gt; &#123; // [1] if (stats) &#123; cb(null, fileName, isFileExists = true); &#125; else &#123; request(url, (err, response, body) =&gt; &#123; // [2] if (err) &#123; cb(err); &#125; else &#123; mkdirp(filePath, err =&gt; &#123; // [3] if (err) &#123; cb(err); &#125; else &#123; fs.writeFile(path.join(filePath, fileName), body, err =&gt; &#123; // [3] if (err) &#123; cb(err); &#125; else &#123; cb(null, fileName, isFileExists); &#125; &#125;) &#125; &#125;) &#125; &#125;) &#125; &#125;)&#125;spider(process.argv[2], (err, fileName, fileExists) =&gt; &#123; if (err) &#123; console.log(chalk.red(`Error: $&#123;err&#125;`)); &#125; else if (fileExists) &#123; console.log(chalk.blue(`File: $&#123;fileName&#125; exists`)); &#125; else &#123; console.log(chalk.green(`File: $&#123;fileName&#125; is downloaded`)); &#125;&#125;)// file utils.js/** Converts urls to simplified strings*/const slugifyUrl = require('slugify-url');exports.urlToFilePath = urlToFilePath;exports.urlToFileName = urlToFileName;function urlToFilePath(url) &#123; // http://example.com/bar const slashChar = '/'; return slugifyUrl(url, &#123; slashChar &#125;); // example.com/bar&#125;function urlToFileName(url) &#123; // http://example.com/bar const slashChar = '/'; const parsedUrl = slugifyUrl(url, &#123; slashChar &#125;).split('/'); return parsedUrl[parsedUrl.length - 1]; // bar&#125; The preceding functions execute the following tasks: Check if the URL was already downloaded by verifying that corresponding file hasn’t already created. If the file is not found, it would download content of provided URL Then it creates recursively directories Finally, it writes the body of HTTP response to file system The callback hellWe can surely notice that even though the algorithm was straightforward, the resulting code has several level of indentation and it’s very hard to read. Implementing a similar function in direct style would more straightforward, and it would be very few chances to make it look so wrong. However, using CPS is another story, and making bad use of closure may lead to to incredible bad code. That’s known as callback hell or piramid of domm. The typical structure of code affected by the problem looks like the following: 1234567asyncFoo(err =&gt; &#123; asyncBar(err2 =&gt; &#123; asyncFooBar(err3 =&gt; &#123; // ... &#125;) &#125;)&#125;) Another problem is caused by overlapping of the variable names used in each scope. Some people try to avoid it with variation of variables error, err, err2. Also we should keep in mind that closure can create memory leaks that are not so easy to identify. We shouldn’t forget that any context referenced by an active closure is retained from garbage collector. Applying the callback disciplineBasic principles that can help to keep the nesting level low and improve the organization of our code in general: you must exit as soon as possible. Use return, continue or break, depending on context to immediately exit the current statement create a named function for callbacks. Will keep our code shallow and better look for stack trace modularize the code. Create a small, reusable function whenever it’s possible After applying the following recommendation our spider() would look as following: 123456789101112131415161718192021222324252627282930313233343536373839404142function spider(url, cb) &#123; const filePath = utils.urlToFilePath(url); const fileName = utils.urlToFileName(url); let isFileExists = false; fs.stat(filePath, (err, stats) =&gt; &#123; if (stats) &#123; return cb(null, fileName, isFileExists = true); // [!] &#125; download(url, filePath, fileName, isFileExists, cb); &#125;)&#125;function download(url, filePath, fileName, isFileExists, cb) &#123; request(url, (err, response, body) =&gt; &#123; if (err) &#123; return cb(err); // [!] &#125; else &#123; saveFile(filePath, fileName, body, isFileExists, cb); // [!] &#125; &#125;)&#125;function saveFile(filePath, fileName, content, isFileExists, cb) &#123; mkdirp(filePath, err =&gt; &#123; if (err) &#123; return cb(err); // [!] &#125; else &#123; writeContent(filePath, fileName, content, isFileExists, cb); &#125; &#125;)&#125;function writeContent(filePath, fileName, content, isFileExists, cb) &#123; fs.writeFile(path.join(filePath, fileName), content, err =&gt; &#123; if (err) &#123; return cb(err); // [!] &#125; else &#123; return cb(null, fileName, isFileExists); // [!] &#125; &#125;)&#125; Sequential executionExecuting a set of task in sequence means running them one at time, one ofter other. The order of execution matters. The concept: There are different variation of this flow: execution a set of known task in sequence, without chaining and propagate the result using output of task as the input to the next task, also known as chain, pipe, or waterfall iterating over a collection while running an asynchronous task on each element, one ofter other Execution a set of known task in sequenceWe’ve already met a sequential execution while implementing the spider() function. Taking that code as guideline we can generalize the solution into the following pattern: 1234567891011121314151617function task1(cb) &#123; asyncOperation(() =&gt; task2(cb))&#125;function task2(cb) &#123; asyncOperation(() =&gt; task3(cb))&#125;function task3(cb) &#123; asyncOperation(() =&gt; cb()) // finally executes the callback&#125;function asyncOperation(cb) &#123; // emulates asynchronous operation setTimeout(() =&gt; cb());&#125;task1(() =&gt; console.log('task 1, 2 and 3 executed')); Sequential iteration with crawling of linksWhat if we want to invoke an asynchronous operation for each file in a collection? With new feature, downloading all the links contained in the web-page recursively. To do that, we are going to extract all links from the page and than trigger our web spider on each of them recursively and in sequence. The new version of spider() is as following: 12345678910111213141516171819202122232425262728293031323334353637383940function spider(url, nesting, callback) &#123; const filename = utilities.urlToFilename(url); fs.readFile(filename, 'utf8', (err, body) =&gt; &#123; if(err) &#123; if(err.code ! == 'ENOENT') &#123; return callback(err); &#125; return download(url, filename, (err, body) =&gt; &#123; if(err) &#123; return callback(err); &#125; spiderLinks(url, body, nesting, callback); &#125;); &#125; spiderLinks(url, body, nesting, callback); &#125;);&#125;function spiderLink(url, body, nesting, cb) &#123; if (nesting === 0) &#123; return process.nextTick(cb); &#125; // require('get-urls') const links = utils.getUrls(body); // [1] function iterate(index) &#123; // [2] if (index === links.length) &#123; return cb(); &#125; spider(links[index], nesting - 1, err =&gt; &#123; // [3] if (err) &#123; return cb(err); &#125; iterate(index - 1); &#125;) &#125; iterate(0); // [4]&#125; The important steps to understand: Obtain the list of all links on the page using the utils.getUrls(). This links should return only with the same hostname Iterate through links via local function iterate(). The first thing it checks if the index is equal to the length of links, in which case it immediately invokes the cb() as it means it proceeds all items At this point everything is ready to processing the links. It invokes the spider() function by decreasing the nesting level and invoking the next step of iteration then the operation is complete It’s a bootstrapping the iteration by iterate(0) The pattern “sequential iteration”It can be generalize as follow: 12345678910111213141516function iterate(index) &#123; if (index === tasks.length) &#123; return finish(); &#125; const task = tasks[index]; task(function() &#123; iterate(index + 1); &#125;)&#125;function finish() &#123; // iteration completed&#125;iterate(0); It’s important to notice that these type of algorithm become really recursive if task() is an asynchronous operation. In such a case there might be a risk of hitting the maximum call stack limit. Pattern sequential iterator:execute a list of tasks in sequence by creating a function iterate() which invokes the next available task in the collection and makes sure to invoke next step of iteration when the current task is completed Parallel executionThere is some situation when the order of execution of the set of asynchronous tasks is not important and we want just to be notified when all these running tasks are completed. We realize that even thought we have one thread we can still achieve concurrency, thanks to not-blocking nature of Node.js. In fact, the word parallel is used improperly in this case, as it doesn’t mean that the task run simultaneously, but rather their execution is carried out by an underlying non-blocking API and invoked by the event loop. As we know, a task gives control back to the event loop when it request a new asynchronous operation, allowing the event loop to execute another task. The proper word is to use for this kind of flow is concurrency, but we still use parallel for simplicity sake. Concurrency vs Parallelism The following diagram shows how two asynchronous tasks can run in parallel in a Node.js program: We have Main function that executes two asynchronous tasks: The Main function triggers the execution of Task1 and Task2. As they are asynchronous operations the immediately return control to Main, which then returns to event loop When the asynchronous operation of Task1 is completed, the event loop gives control to it. When task1 completes the internal synchronous operation processing as well, it notifies the Main The same as described in p2 but now with event loop triggers the Task2. At this point Main function knows that Task1 and Task2 are completed, so it can continue the execution or return the result of the operation to another callback. Execution with “spiderLinks”So far application is executing the recursive download of the linked pages in a sequential fashion. We can easily improve performance of this process by downloading all the linked pages in parallel: 123456789101112131415161718192021222324252627function spiderLink(url, body, nesting, cb) &#123; if (nesting === 0) &#123; return process.nextTick(cb); &#125; const links = utils.getUrls(body); if (links.length === 0) &#123; return process.nextTick(cb) &#125; let completed = 0; let hasErrors = false; function done(err) &#123; if (err) &#123; hasErrors = true; return cb(err); &#125; if (++completed === links.length &amp;&amp; !hasErrors) &#123; return cb() &#125; &#125; links.forEach(link =&gt; &#123; spider(link, nesting - 1, done); &#125;)&#125; The trick to make our application to wait for all the task to complete is to invoke the spider() with a special callback done(). The done() increases a counter when a spider() task completes. When the number of completed downloads reaches the size of links[], the final callback is invoked. The pattern “unlimited parallel execution”We can represent a generic version of the pattern: 1234567891011121314const tasks = [ /*...*/ ];let completed = 0;tasks.forEach(task =&gt; &#123; task(() =&gt; &#123; if (++competed === tasks.length) &#123; finish(); &#125; &#125;)&#125;)function finish() &#123; // all tasks are completed&#125; Pattern unlimited parallel executionRun a set of asynchronous tasks in parallel by spawning them all at once, and then waiting for all of them to complete by counting the number of the times their callback are invoked Limited parallel executionImagine having thousands of files to read, URLs to access, or DB queries run in parallel. A common problem in such situation is running out of memory. In all such situation its a good idea to limit the number of tasks that can run in the same time. The following diagram show a situation where we have five tasks that run in parallel with an concurrency limit of 2: The algorithm to execute a set of given tasks in parallel with limited concurrency: 123456789101112131415161718192021222324252627const tasks = [ /*...*/ ];let concurrency = 0;let running = 0;let completed = 0;let index = 0;function next() &#123; while(running &lt; concurrency &amp;&amp; index &lt; tasks.length) &#123; const task = tasks[index]; running++; task(() =&gt; &#123; if (completed === tasks.length) &#123; return finish(); &#125; completed++; running--; next(); &#125;) &#125;&#125;next();function finish() &#123; // all tasks are completed&#125; “TaskQueue” to rescueWe are now going to implement a simple class which will combine a queue algorithm we presented before: 123456789101112131415161718192021222324class TaskQueue &#123; constructor(concurrency) &#123; this.concurrency = concurrency; this.running = 0; this.queue = []; &#125; pushTask(taks) &#123; this.queue.push(task); this.next(); &#125; next() &#123; while(this.running &lt; this.concurrency &amp;&amp; this.queue.length) &#123; const task = this.queue.shift(); this.running++; task(() =&gt; &#123; this.running--; this.next(); &#125;) &#125; &#125;&#125; Now we can update our spiderLink() to execute tasks in a limited parallel flow: 12345678910111213141516171819202122const TaskQueue = require('./task-queue');const downloadQueue = new TaskQueue(2);function spiderLink(url, body, nesting, cb) &#123; if (nesting === 0) &#123; return process.nextTick(cb); &#125; const links = utils.getUrls(body); if (links.length === 0) &#123; return process.nextTick(cb) &#125; let completed = 0; let hasErrors = false; links.forEach(link =&gt; &#123; downloadQueue.pushTask(done =&gt; &#123; spider(link, nesting - 1, done); &#125;) &#125;)&#125; Chapter 4: Asynchronous Control Flow with ES6 and beyondWe are going to explore some of the most famous alternatives, promises, generators and an innovative syntax of ES7 the async await. Historically, there have been many different implementation of promise libraries, and most of them aren’t compatible between each other. The JS community worked hard to sort out this limitation and these efforts leads to creation of Promise/A+ spec. The several poplar libraries which implement the Promise/A+ spec: Bluebird Q RSVP When.js ES6 promises ES6 Promises techniquesPromisifying a Node.js style functionIn JS not all the asynchronous functions and libraries support promises out-of-box. We can convert a typical callback-based function into one that returns a promise, this process is also known as promisification: 1234567891011121314151617181920module.exports.promisify = function(fn) &#123; return function promisified(...callArgs) &#123; return new Promise((resolve, reject) =&gt; &#123; //[1] callArgs.push((err, result, ...restResults) =&gt; &#123; //[2] if (err) &#123; return reject(err); //[3] &#125; console.log(callArgs) if (callArgs.length &lt;= 2) &#123; //[4] resolve(result); &#125; else &#123; resolve([result, ...restResults]); &#125; &#125;); // the same as fn.apply(null, callArgs) fn(...callArgs); //[5] &#125;); &#125;&#125;; This is how it works: The promisified() creates a new promise using Promise constructor and immediately return it to caller We make sure to pass a special callback to fn(). As we know that the callback always comes last, we append it to the arguments (args) provided to the promisified() In the special callback if we receive an error we immediately reject an error If no error, we resolve the promise with a value or an array of values, depending how many results are passing to callback Finally, we simply invoke the fs() with the list of arguments we have built Another approach is to use one of the ready-production npm packages, for example tini-promisify Sequential executionWe are now ready to convert our web spider application to use promises: 1234567891011121314151617181920212223242526272829303132333435363738394041const utilities = require('utilities');const promisify = utilities.promisify;// const fs = require(fs);const request = promisify(require('request'));const makedirp = promisify(require('makedirp'));const readFile = promisify(require(fs.readFile));const writeFile = promisify(require(fs.writeFile));function spider(url, nesting) &#123; const filePath = utils.urlToFilePath(url); const fileName = utils.urlToFileName(url); return readFile(path.join(filePath, fileName), 'utf8') .then(body =&gt; spiderLink(url, body, nesting)) .catch((err) =&gt; &#123; if (err) &#123; if (err.code === 'ENOENT') &#123; return download(url, fileName); &#125; &#125; &#125;) .then(body =&gt; &#123; spiderLink(url, body, nesting) &#125;)&#125;function download(url, filename) &#123; let body = body; return request(url) .then(resp =&gt; &#123; body = resp.body; return mkdirp(path.dirname(url)); &#125;) .then(() =&gt; writeFile(filename, body)) .then(() =&gt; &#123; console.log(`Download and saved $&#123;fileName&#125; from $&#123;url&#125;`); return body; &#125;)&#125; Also we modify its invocation as follow: 123spider(url, 5) .then(() =&gt; console.log(chalk.green(`Download and saved from $&#123;url&#125;`))) .catch((err) =&gt; console.log(chalk.red(`Error: $&#123;err&#125;`))); If we look again at code we have written so far, we would be pleasantly surprised by the fact that we haven’t include any error propagation logic, as we would be forced to do with callbacks. This is clearly a huge advantage, as it reduced boilerplate in our code. Sequential iterationSo far it was shown how simple and elegant is to implement sequential execution flow using promises. However code involves only the execution of a well known set of asynchronous operation. So, we missing peace that will complete our exploration of sequential execution flow with implementation of asynchronous iteration using promises 1234567891011121314function spiderLink(url, body, nesting) &#123; const links = utils.getUrls(body); let promise = Promise.resolve(); if (nesting === 0) &#123; return promise; &#125; links.forEach(link =&gt; &#123; promise = promise.then(() =&gt; spider(link, nesting--;)) &#125;) return promise;&#125; To iterate asynchronously over links we had dynamically build a chain of promises: Starting with an “empty” promise, resolving to undefined. This is a starting point to build our chain Then, in the loop, we’re updating the promise variable with a new promise which is invoked from then() on the previous promise in the chain. This is actually our asynchronous iteration pattern using promises. Let’s extract a pattern for a sequential execution using promises: 123456789101112131415const tasks = [/*...*/];let promise = Promise.resolve();tasks.forEach(task =&gt; &#123; promise = promise.then(() =&gt; task());&#125;)// an alternative with \"reduce()\"/*tasks.reduce((prev, task) =&gt; &#123; return prev.then(() =&gt; task());&#125;, Promise.resolve())*/promise.then(() =&gt; /*all task are completed*/) The pattern: sequential iteration with promisesDynamically builds a chain of promises in a loop Parallel executionAnother execution flow is become trivial with promises is the parallel execution flow using Promise.all(). This static method creates promise which fulfills only when all the promises received as input are fulfilled: 1234567891011function spiderLink(url, body, nesting) &#123; const links = utils.getUrls(body); if (nesting === 0) &#123; Promise.resolve() &#125; let promises = links.map(link =&gt; spider(link, --nesting)); return Promise.all(promises);&#125; Limited parallel executionIn fact, the pattern we’ve implemented in TaskQueue class can be easily adapted to support tasks that return a promise. This can be achieve by modifying next(): 12345678910111213next() &#123; while(this.running &lt; this.concurrency &amp;&amp; this.queue.length) &#123; const task = this.queue.shift(); this.running++; task().then(() =&gt; &#123; completed++; running--; this.next(); &#125;) &#125;&#125; Then we can modify the spideLinks() to achieve limit of concurrency: 1234567891011121314151617181920212223242526272829303132333435const TaskQueue = require('./task-queue');const downloadQueue = new TaskQueue(2);function spiderLink(url, body, nesting) &#123; if (nesting === 0 || links.length === 0) &#123; return Promise.resolve; &#125; const links = utils.getUrls(body); let completed = 0; let hasErrors = false; return Promise((resolve, reject) =&gt; &#123; let completed = 0; let error = false; links.forEach(link =&gt; &#123; let task = () =&gt; &#123; return spider(link, --nesting) .then(() =&gt; &#123; if (++completed === links.length) &#123; resolve() &#125; &#125;) .catch((err) =&gt; &#123; if (!error) &#123; error = true; reject(); &#125; &#125;) &#125;; downloadQueue.pushTask(task) &#125;) &#125;)&#125; Exposing callbacks and promises in public APIsNow let’s imagine that we want to build a public library that performs asynchronous operations. Do we need to create CPS API or a promise-oriented one? The first approach is used by popular libraries such as request, redis and mysql, consists of offering a simply API that is only based on callbacks and leaves the developer the option to promisify the exposed functionality of needed. Some of these libraries provides helpers to achieve a such behavior. The second approach is more transparent. It offers the developers a callback-oriented API, but it makes the callback argument optional. When the callback is not passed, the function will immediately return a Promise object. This approach gives possibility to choose at call time what interface to adopt, without any needs to promisify the functionality in advance. Many libraries, such as mongoose or sequelize, support this approach. A dummy module that executes division asynchronously: 1234567891011121314151617181920212223242526272829//divider.jsmodule.exports = (divident, divisor, cb) &#123; return new Promise(resolve, reject) =&gt; &#123; process.nextTich(() =&gt; &#123; const result = divident / divisor; if (!Number.isInteger(result)) &#123; const err = new Error('Invalid operands'); if (cb) return cb(err); reject(err); &#125; if (cb) return cb(null, result); resolve(result); &#125;) &#125;&#125;//main.jsconst divider = require('./divider')divider(10, 0, (err, res) =&gt; &#123; if (err) return console.error(err); console.log(res);&#125;);divider(10, 2) .then(res =&gt; console.log(res)) .catch(err =&gt; console.error(err)); GeneratorsIn fact, in a normal function we can only have one entry point which corresponds to the invocation of function itself. A generator is similar to a function, but in addition, it can be suspended (using the yield statement) and then resumed at a later time. Asynchronous control flow with generatorsTo demonstrate how generator will help us with this by creating a special function that accepts a generator as an argument and allows us to use asynchronous code inside the generator. The function take care to resume the execution of the generator when the asynchronous operation is complete: 1234567891011121314function asyncFlow(generatorFn) &#123; const generator = generatorFn(cb); generator.next(); // special callback to resume/stop the generator // resume by passing back the result receiving in the cb function function cb(err, ...result) &#123; if (err) &#123; return generator.throw(err); &#125; generator.next(result); &#125;&#125; To demonstrate the power of this simple function with new module: 1234567891011// clone.jsconst fs = require('fs');const path = require('path');asyncFlow(function* (cb) &#123; const filename = path.basename(__filename); const content = yield fs.readFile(filename, 'utf8', cb); yield fs.writeFile(`clone_of_$&#123;filename&#125;`, content, cb); console.log('clone created');&#125;) Remarkable with help of asyncFlow() we were able to write asynchronous code using the linear approach, as we using blocking function! The callback passed to each asynchronous function will in turn resume the generator as soon as a asynchronous operation is complete. There are two other variation of these technique, one involves to use promises and other use thunks. A thunk used in the generator based control flow it’s just a function which partially applies all the arguments of original function except its callback. An example of thunkified version of fs.readFile(): 12345function readFileThunk(filename, options) &#123; return function(cb) &#123; fs.readFile(filename, options, cb); &#125;&#125; Both promises and thunks allow us to create generators that do not need a callback argument. Thunkfied version of asynkFlow(): 12345678910111213141516171819202122232425262728293031323334353637383940const fs = require('fs');const path = require('path');asyncFlowWithThunks(function* () &#123; const filename = path.basename(__filename); const content = yield readFileThunk(filename, 'utf8'); yield writeFileThunk(`clone_of_$&#123;filename&#125;`, content); console.log('clone created');&#125;)function readFileThunk(filename, options) &#123; return function(cb) &#123; fs.readFile(filename, options, cb); &#125;&#125;function writeFileThunk(filename, constent) &#123; return function(cb) &#123; fs.writeFile(filename, constent, cb); &#125;&#125;function asyncFlow(generatorFn) &#123; const generator = generatorFn(); const thunk = generator.next().value; thunk &amp;&amp; thunk(cb); function cb(err, ...result) &#123; let thunk; if (err) &#123; return generator.throw(err); &#125; thunk = generator.next(result).value; thunk &amp;&amp; thunk(cb); &#125;&#125; In the same way we could implement a version with promises: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061const fs = require('fs');const path = require('path');asyncFlowWithPromises(function* () &#123; const filename = path.basename(__filename); const content = yield readFilePromise(filename, 'utf8'); yield writeFilePromise(`clone_of_$&#123;filename&#125;`, content); console.log('clone created');&#125;)function readFilePromise(filename, options) &#123; const readFile = promisify(fs.readFile); return (cb) =&gt; &#123; fs.readFile(filename, options, cb); &#125;;&#125;function writeFilePromise(filename, content) &#123; const readFile = promisify(fs.writeFile); return (cb) =&gt; &#123; fs.writeFile(filename, content, cb); &#125;;&#125;function promisify(fn) &#123; return function promisified(...callArgs) &#123; return new Promise((resolve, reject) =&gt; &#123; callArgs.push((err, result, ...restResults) =&gt; &#123; if (err) &#123; return reject(err); &#125; console.log(callArgs) if (callArgs.length &lt;= 2) &#123; resolve(result); &#125; else &#123; resolve([result, ...restResults]); &#125; &#125;); fn(...callArgs); &#125;); &#125;&#125;function asyncFlow(generatorFn) &#123; const generator = generatorFn(); const thunk = generator.next().value; thunk &amp;&amp; thunk(cb); function cb(err, ...result) &#123; let thunk; if (err) &#123; return generator.throw(err); &#125; thunk = generator.next(result).value; thunk &amp;&amp; thunk(cb); &#125;&#125; Generator based control flow using “co” In this section we chose to use co. It supports several types of yieldables: thunks promises array (parallel execution) object (parallel execution) generators (delegation) generator function (delegation) To convert Node.js style function to thunks, we are going to library thunkify Sequential executionLoad and convert all dependencies: 1234567891011// spider.jsconst thunkify = require('thunkify');const co = require('co');const path = require('path');const request = thunkify(require('request'));const fs = require('fs');const mkdirp = thunkify(require('mkdirp'));const readFile = thunkify(fs.readFile);const writeFile = thunkify(fs.writeFile);const nextTick = thunkify(process.nextTick); Is interesting to point out if we decided to use the promisified version of our function instead of their thunkified alternatives, so code would be remain exactly the same, thanks to the fact that co supports both promises and thunks yiedlable objects. Now implementation of download() and spider() becomes trivial: 1234567891011121314151617181920212223242526function* download(url, filename) &#123; console.log(`download $&#123;url&#125;`); const response = yield request(url); const body = response[1]; yield mkdirp(path.dirname(filename)); yield writeFile(filename, body); console.log(`downloaded and saved file $&#123;filename&#125;`); return body;&#125;function* spider(url, nesting) &#123; const filename = utilities.urlToFilename(url); let body; try &#123; body = yield readFile(url, 'utf8'); &#125; catch(e) &#123; if (e.code !== 'ENOENT') &#123; throw e; &#125; body = yield download(url, filename); &#125; yield spiderLink(url, body, nesting);&#125; The interesting detail to notice that we’re able to use a try...catch and propagate error with throw! Another remarkable line is where we use yield download() which is not a promise nor a thunk, but just another generator. This is possible thanks to co. Converting spiderLinks() becomes trivial as well: 12345678910function spiderLinks(url, body, nesting) &#123; if (nesting === 0) &#123; return nextTick(); &#125; const links = utilities.getPageLinks(body); links.forEach(link =&gt; &#123; yield spider(link, nesting - 1); &#125;)&#125; The is no pattern to show for sequential iteration, generators and co are doing the all dirty work for us, so we’re able to write asynchronous iteration as we were using blocking, direct APIs. Now an important entry point: 12345678co(function* () &#123; const nesting = 1; try &#123; yield spider(process.argv[2], nesting); &#125; catch(e) &#123; console.log(e); &#125;&#125;) The whole implementation: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960const thunkify = require('thunkify');const co = require('co');const path = require('path');const request = thunkify(require('request'));const fs = require('fs');const mkdirp = thunkify(require('mkdirp'));const readFile = thunkify(fs.readFile);const writeFile = thunkify(fs.writeFile);const nextTick = thunkify(process.nextTick);const utilities = require('./utils');co(function* () &#123; const nesting = 1; try &#123; yield spider(process.argv[2], nesting); &#125; catch(e) &#123; console.log(e); &#125;&#125;)function* download(url, filename) &#123; console.log(`download $&#123;url&#125;`); const response = yield request(url); const body = response[1]; yield mkdirp(path.dirname(filename)); yield writeFile(filename, body); console.log(`downloaded and saved file $&#123;filename&#125;`); return body;&#125;function* spider(url, nesting) &#123; const filename = utilities.urlToFileName(url); let body; try &#123; body = yield readFile(filename, 'utf8'); &#125; catch(e) &#123; if (e.code !== 'ENOENT') &#123; throw e; &#125; body = yield download(url, filename); &#125; yield spiderLinks(filename, body, nesting);&#125;function* spiderLinks(url, body, nesting) &#123; if (nesting === 0) &#123; return nextTick(); &#125; const links = utilities.getUrls(body); for (var i = 0; i &lt; links.length; i++) &#123; yield spider(links[i], nesting - 1); &#125;&#125; Parallel executionThe bad news about generators is that they are good to write sequential algorithm, they can’t be used to parallelize the execution of set of tasks. Luckily, for the specific case of the unlimited parallel execution, co already allows us to obtain it natively by simpling yielding an array of promises, thunks, etc. 123456789function* spiderLinks(url, body, nesting) &#123; if (nesting === 0) &#123; return nextTick(); &#125; const links = utilities.getUrls(body); const tasks = links.map(link =&gt; spider(link, nesting - 1)); yield tasks;&#125; What we just did was just to collect all the download tasks, which are essentially generators, and then yield on the resulting array. All these task will be executed by co in parallel and then execution will be resumed when all tasks finish running. Limited parallel executionThe main straightforward approach for me is to use co-limiter 12345678910111213141516const co = require('co');const wait = require('co-wait');const limiter = require('co-limiter');const limit = limiter(2);const job = function *() &#123; console.log('Doing something...'); yield wait(1000);&#125;for (let i = 0; i &lt; 10; i++) &#123; co(function *() &#123; yield limit(job()); &#125;)();&#125; “async…await” with BabelPreparation: 12345678# install babel cli$ npm install -D babel-cli# extension to support \"async...await\" parsing$ npm install -D babel-plugin-syntax-async-functionsbabel-plugin-transform-async-to-generator# run the example$ node_modules\\.bin\\babel-node --plugins\"syntax-async-functions,transform-async-to-generator\" index.js The problem is that generator function are designed to deal mostly as iterators and their usage with asynchronous operations feel a bit cumbersome. It might be hard to understand, leading to code that hard to read and maintain. The async function specification aims to dramatically improve the language model for waiting asynchronous code by introducing async and await directives: 12345678910111213141516const promisify = require('tiny-promisify');const request = promisify(require('request'));function getPage(url) &#123; return request(url).then(res =&gt; &#123; return res.body; &#125;);&#125;async function main() &#123; const html = await getPage('http://example.com'); console.log(html);&#125;main();console.log('loading...'); Comparison Table Plain JS Pros: Does not require any additional libraries or technology Offer the best performance Provides the best compatibility with 3-th party libraries Allows creation of ad hoc and more advanced algorithms Cons: Require extra code and relatively complex algorithms Promises Pros: Simplify the most common control flow patters Robust error handling Part of ES6 spec Cons: Require promisify callback-based APIs A small performance hit Generators: Pros: Makes non-blocking code looks like a blocking one Simplify error handling Part of ES6 spec Cons: Require a complementary control flow library Require callback or promises to implement non-sequential flows Require thunkify or promisify nongenerator-based APIs Async await Pros: Makes a non-blocking code looks like blocking Clean and intuitive syntax Future part of spec Cons: Not yet a standard Require transpilers such as Babel Codding with StreamsBuffering vs streamingSpatial efficiencyMore about gzip. 12345678910111213// gzip-with-buffer.jsconst fs = require('fs');const zlib = require('zlib');const filename = process.argv[2];fs.readFile(filename, (err, content) =&gt; &#123; zlib.gzip(content, (err, gzipedContent) =&gt; &#123; fs.writeFile(`$&#123;filename&#125;.gz`, gzipedContent, err =&gt; &#123; console.log('file compresed'); &#125;) &#125;)&#125;) 123456789101112// gzip-with-streams.jsconst fs = require('fs');const zlib = require('zlib');const filename = process.argv[2];fs.createReadStream(filename) .pipe(zlib.createGzip()) .pipe(fs.createWriteStream(`$&#123;filename&#125;.gz`)) .on('finish', () =&gt; &#123; console.log('file compresed'); &#125;); Time efficiency123456789101112131415161718192021222324252627// server-gzip-receive.js/*[1] server receive the data chunks from the network[2] decompress them[3] save them as soon as they received[4] returns a new instance of \"http.Server\"[5] begin accepting connections on the specified port and hostname*/const fs = require('fs');const zlib = require('zlib');const http = require('http');const server = http.createServer((req, res) =&gt; &#123; const filename = req.headers.filename; // [1] console.log(`file request receive $&#123;filename&#125;`); req .pipe(zlib.createGunzip()) // [2] .pipe(fs.createWriteStream(filename)) // [3] .on('finish', () =&gt; &#123; res.writeHead(201, &#123; 'Content-Type': 'text/plain'&#125;); res.end('File was uncoded'); console.log(`file save $&#123;filename&#125;`); &#125;)&#125;);server.listen(3000, 'localhost' () =&gt; console.log('listening for requests')); //[5] 123456789101112131415161718192021222324252627282930313233343536// client-gzip-send.js/*[1] using streams to read file data[2] compress[3] send each chunk as soon as it reads from filesystem[4] returns an instance of the http.ClientRequest class. The ClientRequest instance is a writable stream.*/const fs = require('fs');const zlib = require('zlib');const http = require('http');const path = require('path');const filename = process.argv[2];const server = process.argv[3] || 'localhost';const options = &#123; hostname: server, port: 3000, path: '/', method: 'PUT', headers: &#123; filename: path.basename(filename), 'Content-Type': 'application/octet-streams', 'Content-Encoding': 'gzip' &#125;&#125;;const req = http.request(options, res =&gt; &#123; // [4] console.log(`server response: $&#123;res.statusCode&#125;`);&#125;);fs.createReadStream(filename) // [1] .pipe(zlib.createGzip()) // [2] .pipe(req) // [3] .on('finish', () =&gt; &#123; console.log(`send $&#123;filename&#125;`); &#125;) Composability12345678910111213141516171819202122232425262728293031// 5.streams-compasibility.js/*[1] module provides cryptographic functionality that includes a set of wrappers for OpenSSL's hash, HMAC, cipher, decipher, sign and verify functions[2] this is possible because streams have a uniform interface*/// ...const crypto = require('crypto'); // [1]fs.createReadStream(filename) .pipe(zlib.createGzip()) .pipe(crypto.createCipher('aes192', 'a_shared_key')) // [2] .pipe(req) .on('finish', () =&gt; &#123; console.log(`send $&#123;filename&#125;`); &#125;)// ...const crypto = require('crypto'); // [1]const server = http.createServer((req, res) =&gt; &#123; // ... req .pipe(crypto.createDecipher('aes192', 'a_shared_key')) // [2] .pipe(zlib.createGunzip()) .pipe(fs.createWriteStream(filename)) .on('finish', () =&gt; &#123; res.writeHead(201, &#123; 'Content-Type': 'text/plain'&#125;); res.end('File was uncoded'); console.log(`file save $&#123;filename&#125;`); &#125;)&#125;); Getting start with streams","categories":[{"name":"Javascript","slug":"Javascript","permalink":"http://qetr1ck-op.github.io/categories/Javascript/"},{"name":"Node.js","slug":"Javascript/Node-js","permalink":"http://qetr1ck-op.github.io/categories/Javascript/Node-js/"}],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"http://qetr1ck-op.github.io/tags/Javascript/"},{"name":"Node.js","slug":"Node-js","permalink":"http://qetr1ck-op.github.io/tags/Node-js/"},{"name":"...","slug":"","permalink":"http://qetr1ck-op.github.io/tags//"}]},{"title":"Gulp screencast overview","slug":"Gulp-screencast-overview","date":"2016-09-28T17:43:36.000Z","updated":"2016-10-14T17:03:27.863Z","comments":true,"path":"2016/09/28/Gulp-screencast-overview/","link":"","permalink":"http://qetr1ck-op.github.io/2016/09/28/Gulp-screencast-overview/","excerpt":"Depth table of contents of one of the most popular screencast about utility for managing tasks.","text":"Depth table of contents of one of the most popular screencast about utility for managing tasks. What is Gulp? Compare with Webpack.What is Gulp? Gulp as a “streaming build system”, and moreover, it’s a utility for declaring tasks 0:10 Example gruntfile.js0:53 Comparing with Grunt. 2:50 gruntfile.js vs gruntfile.js More compact config Virtual File System - Vinyl FS. No temp folders Power of streams, streams parallelism Comparing with Webpack 10:10 Deps: CommonJS, AMD, ES2015 Dynamic loading CommonsChungPlugin APIs Webpack + Gulp = 💕 16:45 Tasks: Gulp JS Build: Webpack Install and task running Installing strategies: local vs global 0:22 Installing v4 npm i -D gulpjs/gulp.git#4.0 First task 3:49 Callback for finish async operation Task name as function name Separate tasks with namespace deploy:production Strategies for finish async operations gulp.series and gulp.parallel Have to install v4 before it’s officially released Code examples Streams Vinyl-FS Example streams with coping files 0:45 gulp.src and gulp.dest output as readable/writable streams of instance Vinyl-FS 1:05 Log working files .on(&#39;data&#39;, (file) =&gt; file) 1:48 File getter properties 3:10 Control gulp.dest output 4:45 Module minimatch and popular pattens 6:48 Performance issue with globs 9:13 Summary 11:50 Code examples Basic build for styles App structure 0:25 Declaring task for stylus 1:13 Change destination directory 5.40 Concat files 7:10 Log info with gulp-debug 7:50 Create main.styl 10:31 Add source maps 11:30 Generate source maps only in dev mode 15:05 Using gulp-if 17:05 Create clean task with del 19:05 Create copy task with gulp.parallel 20:24 Result in browser with node-static 21:55 Summary 23:18 Code examples Incremental build, watch Create gulp.watch for styles 0:30 What does “incremental build” actually mean? Caching 1:55 Create gulp.watch for assets with caching with { since: gulp.lastRun(&#39;taskName&#39;) } 3:55 Module chokidar and deleting files with watch 6:49 Decoupling watch-es into separate task 8:32 Summary 9:32 Code examples Incremental and performance Filter new files for first task run with gulp-newer 0:36 Problem with gulp-remember on example with gulp-autoprefixer 3:57 Problem with returning deleted files from IDE, using gulp-cached as alternative of since 10:10 Summary 15:20 Code examples 1 Code examples 2 Browser auto-reloading, browser-sync We don’t want to every time hit F5! Flow overview 0:14 Create sync task with browser-sync 1:34 Code examples Error handling Make an error 0:20 Was error couched? 1:25 Notification for an error with gulp-notify 2:51 Catch all errors on task with gulp-plumber 6:30 Solution with multipipe 9:50 Code examples 1 Code examples 2 Creating plugins with “through2” What we need to start 0:29 A real example 3:41 Code examples 1 Code examples 2 More complex stream with “eslint”, “gulp-if”, “stream-combiner2” Example with pre-commit 1:55 Optimize repeatable checks 4:08 Performance summary 14:50 Code examples How we know Node.JS streams? A small test 0:20 Why it isn’t work? 1:05 Fix the “pause” problem 4:00 Code examples Structure of “gulpfile.js” We have problems, don’t we? 0:20 A solution is task decomposition 1:50 Adding gulp-load-plugins 5:05 Result after refactoring 6:50 Code examples A real example: styles, assets, sprites, production Goal and app structure 0:15 Improving build of styles and assets 1:55 A typical problem with preprocessors with src and fixing with resolver 4:03 Working with sprites using gulp-svg-sprites 6:20 Add production mode: minify with gulp-cssnano, resource hash with gulp-rev and gulp-rev-replace 15:13 Do we need to use long-term hashing for images? 22:17 Summary 25:35 Code examples Integration with Webpack Summary 27:16 Code examples 1 Code examples 2","categories":[],"tags":[]},{"title":"Preflighted HTTP OPTIONS requests","slug":"Preflighted-HTTP-OPTIONS-requests","date":"2016-09-18T18:02:27.000Z","updated":"2016-10-05T20:40:16.772Z","comments":true,"path":"2016/09/18/Preflighted-HTTP-OPTIONS-requests/","link":"","permalink":"http://qetr1ck-op.github.io/2016/09/18/Preflighted-HTTP-OPTIONS-requests/","excerpt":"What is not-so-simple HTTP request?","text":"What is not-so-simple HTTP request? The Cross-Origin Resource sharing short overviewThe CORS standard works by adding new HTTP headers that allows servers to describe the sets of origins that are permitted to read that information. If browser performs request with “side-effects” aka not a “simple request”, the specification says that that browser need to “preflight” an HTTP OPTIONS request. And then, upon “approval” from the server, sends the actual request. The “simple request”A simple cross-site request is one that meets all the following conditions: The only allowed methods are: GET HEAD POST Apart the headers which are set automatically by the browser (Connection, User-Agent, etc.), the only headers which are allowed to be manually set are: Accept Accept-Language Content-Language Content-Type The only allowed values for the Content-Type header are: application/x-www-form-urlencoded multipart/form-data text/plain Preflighted requestsUnlike simple requests, “preflighted” first send an HTTP request by the OPTIONS method to the resource on the server, in order to determine whether the actual request is safe to send. An example which creates XHR and an HTTP transaction log. CORS flowAn awesome diagram of processing HTTP CORS transaction","categories":[],"tags":[]},{"title":"NG6 starter for new Angular projects","slug":"NG6-starter-for-new-Angular-projects","date":"2016-09-18T16:03:17.000Z","updated":"2016-09-18T16:09:32.696Z","comments":true,"path":"2016/09/18/NG6-starter-for-new-Angular-projects/","link":"","permalink":"http://qetr1ck-op.github.io/2016/09/18/NG6-starter-for-new-Angular-projects/","excerpt":"The de-facto starter repo for building scalable apps with Angular ^1.5, ES6, Gulp and Webpack","text":"The de-facto starter repo for building scalable apps with Angular ^1.5, ES6, Gulp and Webpack Table of contents","categories":[{"name":"Javascript","slug":"Javascript","permalink":"http://qetr1ck-op.github.io/categories/Javascript/"},{"name":"Angular ^1.5","slug":"Javascript/Angular-1-5","permalink":"http://qetr1ck-op.github.io/categories/Javascript/Angular-1-5/"}],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"http://qetr1ck-op.github.io/tags/Javascript/"},{"name":"Angular ^1.5","slug":"Angular-1-5","permalink":"http://qetr1ck-op.github.io/tags/Angular-1-5/"}]},{"title":"Start new project on Angular 1.5","slug":"Start-new-project-on-Angular-1-5","date":"2016-09-18T15:42:49.000Z","updated":"2016-09-18T15:59:25.367Z","comments":true,"path":"2016/09/18/Start-new-project-on-Angular-1-5/","link":"","permalink":"http://qetr1ck-op.github.io/2016/09/18/Start-new-project-on-Angular-1-5/","excerpt":"Great series of recommendation how/why to start new “NG2 ready” Angular 1.5 app with architecture of component-oriented approach.","text":"Great series of recommendation how/why to start new “NG2 ready” Angular 1.5 app with architecture of component-oriented approach. Component communication Starting a new app in Angular 1.5, does it make sense? Angular 1.5 app as tree of components Communication between Angular 1.5 components and with API A flexible Angular 1.5 project structure (the “fractal” approach) Writing Angular 1.5 in ES6 Unit testing Angular 1.5 components","categories":[{"name":"Javascript","slug":"Javascript","permalink":"http://qetr1ck-op.github.io/categories/Javascript/"},{"name":"Angular 1.5","slug":"Javascript/Angular-1-5","permalink":"http://qetr1ck-op.github.io/categories/Javascript/Angular-1-5/"}],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"http://qetr1ck-op.github.io/tags/Javascript/"},{"name":"Angular 1.5","slug":"Angular-1-5","permalink":"http://qetr1ck-op.github.io/tags/Angular-1-5/"}]},{"title":"Lifecycle hooks in AngularJS 1.5","slug":"Lifecycle-hooks-in-AngularJS-1-5","date":"2016-09-04T07:48:03.000Z","updated":"2016-09-18T09:37:14.191Z","comments":true,"path":"2016/09/04/Lifecycle-hooks-in-AngularJS-1-5/","link":"","permalink":"http://qetr1ck-op.github.io/2016/09/04/Lifecycle-hooks-in-AngularJS-1-5/","excerpt":"Lifecycle hooks are simple functions that are called at specific points of a component’s life in Angular apps. They landed in AngularJS 1.5 and are used with .component() method and they were inspired of Angular 2 hooks.","text":"Lifecycle hooks are simple functions that are called at specific points of a component’s life in Angular apps. They landed in AngularJS 1.5 and are used with .component() method and they were inspired of Angular 2 hooks. “$onInit” + “require”Let’s create tabs component that uses $onInit and require. Full working exapmle: “$postLing”The $postLink gives as non-hacky-looking way to control link method. We can actually use the it to set an initial value for active tab: “$onChanges”This is the most important one, and allow use component architecture with one-way data flow! The $onChanges method is called for a few reasons. The first is on component in initialization - component gets initial changes object. The second reason it gets called is only when changes occur to &lt; (one-way databinding) and @ (for evaluating DOM attribute values) that are being bound the parent component. Once the $onChenges gets called, you get special changes object back: 12345678910111213141516var childComponent = &#123; bindings: &#123; user: '&lt;' &#125;, controller: function () &#123; this.$onChanges = function (changes) &#123; // `changes` is a special instance of a constructor Object, // it contains a hash of a change Object and // also contains a function called `isFirstChange()` // it's implemented in the source code using a constructor Object // and prototype method to create the function `isFirstChange()` &#125;; &#125;&#125;;angular .module('app') .component('childComponent', childComponent); In example we’re using bindings: { user: &#39;&lt;&#39; } which means we receive he data through one-way databinding under the alias of user: Cloning “changes” for “immutable” bindingsData passed through one-way databinding are not $watched by Angular, however they are passed by reference. It means that any changes we make with object (primitives are not passed by reference) it affects the parent object, which acts as two-way databinding. We can clone data which are passed for non polluting changes from child to parent: One-way data-flow + eventsTo get data back up to our parentComponent, we need to delegate a function to be used as an event callback, let’s add a function called updateUser, which expects an event back as an argument: 123456789var parentComponent = &#123; ... controller: function () &#123; ... this.updateUser = function (event) &#123; this.user = event.user; &#125;; &#125;&#125;; Instead of just passig back this.user into the function, we’re going to fake an $event object, which complies with how Angular 2 does this (using EventEmitter), and also provides global consistency between your templates to fetch data back through the $ctrl.updateUser($event); call we delegate down into the child component. The $event argument is a real thing in Angular, you can use it with ng-submit and so on: 12345678910111213var childComponent = &#123; ... controller: function () &#123; ... this.saveUser = function () &#123; this.onUpdate(&#123; $event: &#123; user: this.user &#125; &#125;); &#125;; &#125;&#125;; The full example with delegating update of object: Is two-way databinding via syntax “=” is dead?Yes. One-way bindings establishes as the best approach for data flow. React, Angular 2 and other all use it. “$onDestroy”If you’re using $postLink to set DOM event listener or any non-native Angular logic, $onDestroy is the place to clean up everything. The old $scope way was kind of this: 12345function SomeController($scope) &#123; $scope.$on('$destroy', function () &#123; // destroy event &#125;);&#125; With new school it looks like this: 1234567891011121314var childComponent = &#123; bindings: &#123; user: '&lt;' &#125;, controller: function () &#123; this.$onDestroy = function () &#123; // component scope is destroyed &#125;; &#125;&#125;;angular .module('app') .component('childComponent', childComponent); Save my day: Todd Motto","categories":[{"name":"Javascript","slug":"Javascript","permalink":"http://qetr1ck-op.github.io/categories/Javascript/"},{"name":"AngularJS 1.5","slug":"Javascript/AngularJS-1-5","permalink":"http://qetr1ck-op.github.io/categories/Javascript/AngularJS-1-5/"}],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"http://qetr1ck-op.github.io/tags/Javascript/"},{"name":"AngularJS 1.5","slug":"AngularJS-1-5","permalink":"http://qetr1ck-op.github.io/tags/AngularJS-1-5/"},{"name":"Lifecycle hooks","slug":"Lifecycle-hooks","permalink":"http://qetr1ck-op.github.io/tags/Lifecycle-hooks/"}]},{"title":"Moving from \"ngModel.$parsers\"/\"ng-if\" to \"ngModel.$validators\"/\"ngMessages\"","slug":"Moving-from-ngModel-parsers-ng-if-to-ngModel-validators-ngMessages","date":"2016-09-03T19:24:46.000Z","updated":"2016-09-18T09:37:37.925Z","comments":true,"path":"2016/09/03/Moving-from-ngModel-parsers-ng-if-to-ngModel-validators-ngMessages/","link":"","permalink":"http://qetr1ck-op.github.io/2016/09/03/Moving-from-ngModel-parsers-ng-if-to-ngModel-validators-ngMessages/","excerpt":"Implementation custom Model validation is typically done by extending the built-in $error object to ngForm models, such as a simple &lt;input. Prior to AngularJS 1.3 custom validation was done by injecting a function into the ngModel.$parsers array pipeline and manually setting validation states using $setValidity(&#39;visa&#39;, true) if the Model value matched a Visa credit card expression format. AngularJS 1.3+ has the $validators pipeline object, which requires no manual setting of validation states. Let’s take a look of old school way then we can shift to ngModel.$validators technique.","text":"Implementation custom Model validation is typically done by extending the built-in $error object to ngForm models, such as a simple &lt;input. Prior to AngularJS 1.3 custom validation was done by injecting a function into the ngModel.$parsers array pipeline and manually setting validation states using $setValidity(&#39;visa&#39;, true) if the Model value matched a Visa credit card expression format. AngularJS 1.3+ has the $validators pipeline object, which requires no manual setting of validation states. Let’s take a look of old school way then we can shift to ngModel.$validators technique. Old school “$parsers”Let’s take some basic form markup, binding name=&quot;myForm&quot; to the &lt;form&gt; element so Angular takes control of our form and validation states. Next we’ll add an &lt;input&gt; with the name creditCard, which builds up the Model Object internally so we can access myForm.creditCard and handle our validation. I’ve added a validate-visa attribute, which will serve as the Directive bound to the input, so we can capture the Model and validate it. 12345&lt;form name=\"myForm\"&gt; &lt;h3&gt;Visa validation ($parsers)&lt;/h3&gt; &lt;input type=\"text\" name=\"creditCard\" ng-model=\"creditCardModel\" validate-visa&gt; &#123;&#123; myForm.creditCard | json &#125;&#125;&lt;/form&gt; The result is something like this: 123456789101112131415161718&#123; \"$validators\": &#123;&#125;, \"$asyncValidators\": &#123;&#125;, \"$parsers\": [], \"$formatters\": [ null ], \"$viewChangeListeners\": [], \"$untouched\": true, \"$touched\": false, \"$pristine\": true, \"$dirty\": false, \"$valid\": false, \"$invalid\": true, \"$error\": &#123;&#125;, \"$name\": \"creditCard\", \"$options\": null&#125; The generated ngModel.creditCard.$error object it the place where we need to hook into. At this point we want conditionally toggle DOM based on the boolean value of this property. If myForm.creditCard.$error.visa is true create the element, otherwise false framework will remove it from DOM. 1234567&lt;form name=\"myForm\"&gt; &lt;h3&gt;Visa validation ($parsers)&lt;/h3&gt; &lt;input type=\"text\" name=\"creditCard\" ng-model=\"creditCardModel\" validate-visa&gt; &lt;p ng-if=\"myForm.creditCard.$error.visa\" class=\"invalid\"&gt; Not a valid Visa format &lt;/p&gt;&lt;/form&gt; Now we need to write logic for validate-visa directive to tie in to the ngModel and set states. Typically it’s done by using ngMode.$parsers: 12345678910111213141516171819202122232425262728293031323334353637// create a validateVisa functionfunction validateVisa() &#123; // link function function link($scope, $element, $attrs, $ctrl) &#123; // Some basic Visa Regular Expression const VISA_REGEXP = /^4[0-9]&#123;12&#125;(?:[0-9]&#123;3&#125;)?$/; // visaParser function, passing in the current viewValue function visaParser(viewValue) &#123; // a Boolean variable evaluated by RegExp.test(String) const isValid = VISA_REGEXP.test(viewValue); // Manually set the validity of the \"visa\" property on // the \"$error\" Object bound to the Model. // Note: $ctrl is the fourth argument in the \"link\" function // as we're requiring \"ngModel\" (see below in the return &#123;&#125; statement) $ctrl.$setValidity('visa', isValid); // return the \"viewValue\" if it's valid or undefined // so Angular doesn't set the value return isValid ? viewValue : undefined; &#125; // push the \"visaParser\" function into the \"$parsers\" Array $ctrl.$parsers.push(visaParser); &#125; // export the Directive Object // which requires the \"ngModel\" Controller and // binds the above \"link\" function return &#123; require: 'ngModel', link: link &#125;; &#125;angular .module('app') .directive('validateVisa', validateVisa); The syntax of pushing a function into $parsers array isn’t very slick and we also manually set the validation state passing in string or boolean, which seems a very procedural way to do a thing. At this point $error object which is bounded to the input looks like this: 1234567&#123; ... \"$error\": &#123; \"visa\": true &#125;, ...&#125; New school “$validators”In AngularJS 1.3+ we’ve a much better way of doing things! Just like before we require: &#39;ngModel&#39; into directive but instead of using $parsers we can bind a function straight to $validators object: 1234567891011121314151617181920function validateVisa() &#123; function link($scope, $element, $attrs, $ctrl) &#123; var VISA_REGEXP = /^4[0-9]&#123;12&#125;(?:[0-9]&#123;3&#125;)?$/; $ctrl.$validators.visa = function visaParser(modelValue, viewValue) &#123; var value = modelValue || viewValue; return (VISA_REGEXP.test(value)); &#125;; &#125; return &#123; require: 'ngModel', link: link &#125;; &#125;angular .module('app') .directive('validateVisa', validateVisa); The above doesn’t even need annotating, any $validator property we add becomes the property name bound to $error, and we just need to return a boolean. Super simple and much clearer to read. Usage as the Directive from an HTML perspective is identical, it’s just the difference of how we implement the validation that changes Old school “ng-if”Using ng-if is super simple, we tell to conditionally swap element based on property state bound to the $error object: 1234567891011121314151617181920212223&lt;form name=\"myForm\"&gt; &lt;h3&gt;Visa validation (ngIf)&lt;/h3&gt; &lt;input type=\"text\" name=\"creditCard\" ng-model=\"creditCardModel\" required=\"\" ng-minlength=\"13\" ng-maxlength=\"16\" validate-visa&gt; &lt;p ng-if=\"myForm.creditCard.$error.required\" class=\"invalid\"&gt; This field is required &lt;/p&gt; &lt;p ng-if=\"myForm.creditCard.$error.visa\" class=\"invalid\"&gt; Not a valid Visa format &lt;/p&gt; &lt;p ng-if=\"myForm.creditCard.$error.minlength\" class=\"invalid\"&gt; Minimum of 13 characters &lt;/p&gt; &lt;p ng-if=\"myForm.creditCard.$error.maxlength\" class=\"invalid\"&gt; Maximum of 16 characters &lt;/p&gt;&lt;/form&gt; It’s a very manual and repetitive process dealing with each $error property. New school “ngMassages”Unlike ng-if approach we’re passing myForm.creditCard.$error only once into ngMassages. The directive will look of $error object and the corresponding massage will be rendered: 12345678910111213141516171819202122232425&lt;form name=\"myForm\"&gt; &lt;h3&gt;Visa validation (ngMessages)&lt;/h3&gt; &lt;input type=\"text\" name=\"creditCard\" ng-model=\"creditCardModel\" required=\"\" ng-minlength=\"13\" ng-maxlength=\"16\" validate-visa&gt; &lt;div ng-messages=\"myForm.creditCard.$error\"&gt; &lt;p ng-message=\"required\" class=\"invalid\"&gt; This field is required &lt;/p&gt; &lt;p ng-message=\"visa\" class=\"invalid\"&gt; Not a valid Visa format &lt;/p&gt; &lt;p ng-message=\"minlength\" class=\"invalid\"&gt; Minimum of 13 characters &lt;/p&gt; &lt;p ng-message=\"maxlength\" class=\"invalid\"&gt; Maximum of 16 characters &lt;/p&gt; &lt;/div&gt;&lt;/form&gt; For reusable/generic validation states we can use ngMassagesIncule: 1234&lt;script type=\"text/ng-template\" id=\"generic-messages\"&gt; &lt;div ng-message=\"required\"&gt;This field is required&lt;/div&gt; &lt;div ng-message=\"minlength\"&gt;This field is too short&lt;/div&gt;&lt;/script&gt; And ramp up it with an existing ngMassages: 123456789101112&lt;div ng-messages=\"myForm.creditCard.$error\"&gt; &lt;div ng-messages-include=\"generic-messages\"&gt;&lt;/div&gt; &lt;p ng-message=\"visa\" class=\"invalid\"&gt; Not a valid Visa format &lt;/p&gt; &lt;p ng-message=\"minlength\" class=\"invalid\"&gt; Minimum of 13 characters &lt;/p&gt; &lt;p ng-message=\"maxlength\" class=\"invalid\"&gt; Maximum of 16 characters &lt;/p&gt;&lt;/div&gt; There are some other powerful features well worth checking out inside ngMessages, see the documentation for more. Save my day: Todd Motto","categories":[{"name":"Javascript","slug":"Javascript","permalink":"http://qetr1ck-op.github.io/categories/Javascript/"},{"name":"AngularJS","slug":"Javascript/AngularJS","permalink":"http://qetr1ck-op.github.io/categories/Javascript/AngularJS/"}],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"http://qetr1ck-op.github.io/tags/Javascript/"},{"name":"AngularJS","slug":"AngularJS","permalink":"http://qetr1ck-op.github.io/tags/AngularJS/"}]},{"title":"Front End Interview Questions","slug":"Front-End-Interview-Questions","date":"2016-08-14T08:39:13.000Z","updated":"2016-12-10T18:42:18.352Z","comments":true,"path":"2016/08/14/Front-End-Interview-Questions/","link":"","permalink":"http://qetr1ck-op.github.io/2016/08/14/Front-End-Interview-Questions/","excerpt":"To rock the interview to achieve what you deserve and to improve your concepts about front end technologies, I have consolidated a list of questions and answers. It’s a one stop solution for front end interview process.","text":"To rock the interview to achieve what you deserve and to improve your concepts about front end technologies, I have consolidated a list of questions and answers. It’s a one stop solution for front end interview process. Web CoreJavaScript: basicsTypes What are the differences between undeclared, undefined, and null? Answer: JavaScript has two distinct values for nothing, null and undefined. Also there are undeclared variables which don’t even exist. Explanation: 123456789var declaredVariable = 1;(function scoppedVariables() &#123; undeclaredVariable = 1; var declaredVariable = 2;&#125;)();undeclaredVariable;declaredVariable; A variable is undeclared when it does not use the var keyword. It gets created on the global object, thus it operates in a different space as the declared variables. undefined means, value of the variable is not defined. JavaScript has a global variable undefined whose value is “undefined” and typeof undefined is also “undefined” null means empty or non-existent value which is used by programmers to indicate “no value”. null is a primitive value and you can assign null to any variable. You cannot add properties to it. Sometimes people wrongly assume that it is an object, because typeof null returns “object”. What are the differences between == and ===? To what type == operands will be converted to if they havedifferent types? Answer: The simplest way of saying that, == will not check types and === will check whether both sides are of same type. So, == under the hood converts to number type if they have not the same type and then do the comparison. === compares the types and values. Hence, if both sides are not same type, answer is always false. For example, if you are comparing two strings, they must have identical character sets. For other primitives (number, boolean) must share the same value. Example. Will it work with use strict directive? 123456(function()&#123; var a = b = 3;&#125;)();console.log(typeof a !== 'undefined');console.log(typeof b !== 'undefined'); Answer: false true because b is declared as global variable. Won’t work. As [] is true, [] == true should also be true, right? Answer: Not. You are right about first part, [], empty array is an object and object is always truthy. However, special case about == (not-strict equal) is that it will do some implicit coercion. Since left and right side of the equality are two different types, JavaScript can’t compare them directl. JavaScript implementation will try to convert [] by using toPrimitive (of JavaScript implementation). since [].valueOf is not primitive will use toString and will get &quot;&quot;. Now you are comparing &quot;&quot; == 1 and still left and right is not same type. Hence left side will be converted again to a number and empty string will be 0. Finally, they are of same type, you are comparing 0 === 1 which will be false. Why typeof bar === object isn’t right? How can this pitfall be avoided? Answer: Use Object.prototype.toString.call(&lt;object&gt;) or use Duck Typing. What is NaN? What is its type? How can you reliably test if a value is equal to NaN? Answer: “not a number”, “number”, NaN compared to anything – even itself! to false. Use Number.isNaN Explanation: The NaN property represents a value that is “not a number”. This special value results from an operation that could not be performed either because one of the operands was non-numeric (e.g., “abc” / 4), or because the result of the operation is non-numeric (e.g., an attempt to divide by zero). ES6 offers a new Number.isNaN() function, which is a different and more reliable than the old global isNaN() function. What is the significance, and what are the benefits, of including &#39;use strict&#39; at the beginning of a JavaScript source file? Answer: &#39;use strict&#39; is a way to enforce stricter parsing and error handling on your code at runtime. Code errors that would otherwise have been ignored or would have failed silently will now generate errors or throw exceptions. Explanation: Some of the key benefits of strict mode include: Makes debugging easier. Code errors that would otherwise have been ignored or would have failed silently will now generate errors or throw exceptions, alerting you sooner to problems in your code and directing you more quickly to their source. Prevents accidental globals. Without strict mode, assigning a value to an undeclared variable automatically creates a global variable with that name. This is one of the most common errors in JavaScript. In strict mode, attempting to do so throws an error. Eliminates this coercion. Without strict mode, a reference to a this value of undefined is automatically coerced to the global. This can cause many headfakes and pull-out-your-hair kind of bugs. Disallows duplicate property names or parameter values. Strict mode throws an error when it detects a duplicate named property in an object (e.g.,var object = {foo: &quot;bar&quot;, foo: &quot;baz&quot;};) or a duplicate named argument for a function (e.g., function foo(val1, val2, val1){}), thereby catching what is almost certainly a bug in your code that you might otherwise have wasted lots of time tracking down. Throws error on invalid usage of delete. The delete operator (used to remove properties from objects) cannot be used on non-configurable properties of the object. Non-strict code will fail silently when an attempt is made to delete a non-configurable property, whereas strict mode will throw an error in such a case. Scope and hoisting, closure and functions Example. What is the result will be an error? 1234567say('World');const phrase = 'Hello';function say(name) &#123; console.log(`$&#123;name&#125;, $&#123;phrase&#125;!`);&#125; Answer: ‘undefined, World!’ Example. What is the result? What if to remove var value = false? 12345678910111213var value = 0;function f() &#123; if (1) &#123; value = true; &#125; else &#123; var value = false; &#125; console.log(value);&#125;f(); Answer: true, after remove line of code, will be changed global variable and the result will be the same. Example. What is the result? How to fix? 123456789101112131415161718192021222324fn1();fn2();fn3();fn4();function fn1() &#123; setTimeout(() =&gt; &#123; console.log('fn1') &#125;)&#125;function fn2() &#123; console.log('fn2');&#125;function fn3() &#123; Promise.resolve().then(() =&gt; &#123; console.log('fn3'); &#125;)&#125;const fn4 = function () &#123; console.log('fn4');&#125; Answer: fn4 function expression isn’t hoisted. Change to function declaration. The result should be fn2, fn4, fn3, fn1 What is a closure? What is a practical use for a closure? Provide an example. Answer: Closure is a function with all accessible variables in lexical environment. Main usage is encapsulating data from outer usage. Example. What is the result? How to make them independent? 1234567891011121314let initCount = 1;function makeCounter() &#123; return () =&gt; initCount++&#125;let counter = makeCounter();let counter2 = makeCounter();console.log( counter() ); // ?console.log( counter() ); // ?console.log( counter2() ); // ?console.log( counter2() ); // ? Closures Inside in loop with setTimeout. If log the loop counter inside setTimeout, what will be logged? 12345for(var i = 0; i &lt; 10; i++) &#123; setTimeout(function() &#123; console.log(i); &#125;, 10);&#125; Answer: The above will not output the numbers 0 through 9, but will simply print the number 10 ten times. Explanation: The console log is inside the anonymous function of setTimeout and setTimeout is executed when current call stack is over. So, the loop finishes and before setTimeout get the chance to execute. However, anonymous functions keep a reference to i by creating a closure. Since, the loop is already finished, the value i has been set to 10. You can fix it by avoiding closure. Just create a IIFE (Immediately Invoked Function Expression), it will create its own scope and you can pass i to the function. In that case i will be a local variable (will not refer to i in the closure) and value of the i in every loop will be preserved. 12345678910111213141516171819// ES5for(var i = 0; i &lt; 10; i++) &#123; setTimeout((function(i) &#123; console.log(i); &#125;)(i), 10)&#125;//orfor(var i = 0; i &lt; 10; i++) &#123; setTimeout(console.log.bind(console, i), 10);&#125;// ES6for(let i = 0; i &lt; 10; i++) &#123; setTimeout(() =&gt; &#123; console.log(i); &#125;, 10);&#125; Write a simple function to tell whether &#39;foo&#39; is passed as parameter or not? Answer: First convert arguments to an array with rest operator, after that simply use Array.prototype.includes. 123456789// ES5function isFooPassed()&#123; return Array.prototype.indexOf.call(arguments, 'foo') &gt; 0;&#125;// ES6function isFooPassed(...params) &#123; return params.includes('foo');&#125; How could you use “Math.max” to find the max value in an array? 1234Math.max(...arr); //ES5 way//Math.max.apply(Math, arr); How could you set a prefix before everything you log? for example, if you log(&#39;my message&#39;) it will log: (app) my message Answer: Just get the arguments, convert it to an array and unshift whatever prefix you want to set. Finally, use apply to pass all the arguments to console. 1234567891011// ES5function log()&#123; var args = Array.prototype.slice.call(arguments); args.unshift('(app)'); console.log.apply(console, args);&#125;// ES6 function log(...params)&#123; console.log(['(app)', ...params]);&#125; Cashing / Memoization. How could you implement cache to save calculation time for a recursive fibonacci function? 12345678910111213141516171819202122const fibonacci = (() =&gt; &#123; const memo = &#123;&#125;; function f(n) &#123; let value; if (memo[n]) &#123; value = memo[n]; &#125; else &#123; if (n === 0 || n === 1) value = n; else value = f(n - 1) + f(n - 2); memo[n] = value; &#125; return value; &#125; return f;&#125;)(); Explanation: Memoization is a programming technique which attempts to increase a function’s performance by caching its previously computed results. Because JavaScript objects behave like associative arrays, they are ideal candidates to act as caches. Each time a memoized function is called, its parameters are used to index the cache. If the data is present, then it can be returned, without executing the entire function. However, if the data is not cached, then the function is executed, and the result is added to the cache. In the following example, the original Fibonacci function is rewritten to include memoization. In the example, a self-executing anonymous function returns an inner function, f(), which is used as the Fibonacci function. When f() is returned, its closure allows it to continue to access the “memo” object, which stores all of its previous results. Each time f() is executed, it first checks to see if a result exists for the current value of “n”. If it does, then the cached value is returned. Otherwise, the original Fibonacci code is executed. Note that “memo” is defined outside of f() so that it can retain its value over multiple function calls. Recall that the original recursive function was called over 40 billion times to compute the 50th Fibonacci number. By implementing memoization, this number drops to 99. Why wrapping the entire content of a JavaScript source file in IIFE? 1(function($) &#123; /*...*/ &#125; )(jQuery); Answer: This technique creates a closure around the entire contents of the file which, perhaps most importantly, creates a private namespace and thereby helps avoid potential name clashes between different JavaScript modules and libraries. Explanation: Another feature of this technique is to allow for an easily referenceable (presumably shorter) alias for a global variable. Explain why the following doesn’t work as an IIFE: function foo(){ }(); Answer: Because foo isn’t being called! This is a function definition, it defines foo. But it’s not a function expression - that is, it’s not understood by the JS parser to actually call a function. For the parser, things look like this: 123456function foo()&#123;&#125; // ok, done with that function definition // (silly human left off the semicolon, how embarrassing!)(); // Are they trying to call something? What’s the function’s name? // PARSE ERROR In order to prep the parser that we’re actually dealing with a function expression we have to wrap things up in () like so: 1234( function foo()&#123; &#125;()); Also will work with ! and + operators: 1234567+function() &#123; &#125;();!function() &#123;&#125;(); Objects What the heck is this in JavaScript? Answer: At the time of execution of every function, JavaScript engine sets a property to the function called this which refer to the current execution context. this is always refer to an object and depends on how function is called: In the global context or inside a function this refers to the window/global object. In ES6 module or with use strict directive it’s undefined While executing a method in the context of an object, the object becomes the value of this If you use a constructor (by using new keyword) to create an object, the value of this will refer to the newly created object. Set the value of this to any arbitrary object by passing the object as the first parameter of bind, call or apply Use arrow function for use parent LexicalEnvironment. Why we need call or apply VS bind. If you want to use an arbitrary object as value of this, how will you do that? Answer: To use an arbitrary object as value of this. There are at least four different ways to doing this by using bind, call, apply and arrow function. call &amp; apply VS bind, the simplest explanation How would you compare two objects? Answer: JavaScript has two different approaches for testing equality. Primitives like strings and numbers are compared by their value, while objects like arrays, dates, and user defined objects are compared by their reference. This means it compares whether two objects are referring to the same location in memory. Equality check will check whether two objects have same value for same property. To check that, you can get the keys for both the objects. Use lodash or any npm equivalent. Or implement by own: 1234567891011121314151617function isEqual(a, b) &#123; var aProps = Object.getOwnPropertyNames(a), bProps = Object.getOwnPropertyNames(b); if (aProps.length !== bProps.length) &#123; return false; &#125; for (var i = 0; i &lt; aProps.length; i++) &#123; var propName = aProps[i]; if (a[propName] !== b[propName]) &#123; return false; &#125; &#125; return true;&#125; Extend Core Object through prototype. Example 1. How could you write a method on instance of a date which will give you next day? Answer: You need to declare a method on the prototype of Date object. To get access to the current value of the instance of the date use this 1234567Date.prototype.nextDay = function () &#123; return new Date(this.setDate(this.getDate() + 1));&#125; const date = new Date(); date; //Fri May 16 2014 20:47:14 GMT-0500 (Central Daylight Time)date.nextDay();//Sat May 17 2014 20:47:14 GMT-0500 (Central Daylight Time) Example 2. How could you make this work [1,2,3,4,5].duplicator() to return [1,2,3,4,5,1,2,3,4,5]? Answer: We need to add a method in the prototype of Array object. 12345678// ES5Array.prototype.duplicator = function()&#123; return this.concat(this);&#125;Array.prototype.duplicator = function() &#123; return [...this, ...this];&#125; In what order are logging properties in the object? 123456789var codes = &#123; // keys of country: name of country \"7\": \"Russian Federation\", \"38\": \"Ukraine\", \"1\": \"USA\", \"57\": \"Norway\"&#125;;for (var code in codes) console.log(code); // ? Answer: 1, 7, 38, 57 Explanation:If name of property is non-numeric string, such keys allways moving in the order in which they assinged. On the other hand, if the name of the property - a number or a numeric string, then all modern browsers such properties are sorted for internal optimization. Why using for...in for Array iteration is wrong? Answer: Array indexes are just enumerable properties with integer names and are otherwise identical to general Object properties. There is no guarantee that for...in will return the indexes in any particular order. The for...in loop statement will return all enumerable properties, including those with non–integer names and those that are inherited. Another point is that for (var i = 0; i &lt; arr.length; i++) is up to 10-100x time faster. OOP How prototype inheritance works? Are you aware of classical approach and with OOLO. Answer: In most languages, there are classes and objects. Classes inherit from other classes. In JavaScript, the inheritance is prototype-based. That means that there are no classes. Instead, an object inherits from another object. The main point is that one object can be prototype of another object. That means if property isn’t found in the object - than it takes from prototype object. In JavaScript this implementation is at the language level. Explanation: OOP in prototype style Example. Make a subclass from parent class Animal 123456789101112131415// parent class or abstract classfunction Animal(name) &#123; this.name = name; this.speed = 0;&#125;Animal.prototype.run = function() &#123; console.log(`$&#123;this.name&#125; run!`);&#125;function Rabbit() &#123; /*...*/&#125;/*...*/ Answer: 1234567891011121314151617181920212223242526function Animal(name) &#123; this.name = name; this.speed = 0;&#125;Animal.prototype.run = function() &#123; console.log(`$&#123;this.name&#125; run!`);&#125;function Rabbit() &#123; Animal.apply(this, arguments)&#125;Rabbit.prototype = Object.create(Animal.prototype);// optionallyRabbit.prototype.constructor = Rabbit;Rabbit.prototype.run = function() &#123; // optionally Animal.prototype.run.apply(this); console.log(`$&#123;this.name&#125; jumps!`);&#125;;var rabbit = new Rabbit('white rabbit');rabbit.run(); Rewrite previous example to ES6 classes. Answer: 12345678910111213141516171819202122class Animal &#123; constructor(name) &#123; this.name = name; this.speed = 0; &#125; run() &#123; console.log(`$&#123;this.name&#125; run!`); &#125;&#125;class Rabbit extends Animal &#123; constructor(name) &#123; super(name) &#125; run() &#123; super.run(); console.log(`$&#123;this.name&#125; jumps`); &#125;;&#125;var rabbit = new Rabbit('white rabbit');rabbit.run(); Difference between: function Person(){}, var person = Person(), and var person = new Person()? What new operator do? Answer: In the example below we define a new “class” called Person with an empty constructor. Invoke function Person() will return undefined. On the other hand invoking new Person will return an empty object {}. Explanation: JavaScript is a prototype-based language and contains no class statement, such as is found in C++ or Java. This is sometimes confusing for programmers accustomed to languages with a class statement. Instead, JavaScript uses functions as constructors for classes. Defining a class is as easy as defining a function. In the example below we define a new class called Person with an empty constructor. And the spec says, the new operator uses the internal [[Construct]] method, and it basically does the following: Initializes a new empty object (no properties) Sets the prototype of the new object to the value of the prototype property of Person. Note: The default value of prototype for a function is an object (automatically created when the function is declared) with its prototype set to Object.prototype and a constructor property pointing back to the function Person. Note: The terminology can be confusing. The property named prototype is not the same as the prototype of the object. Only functions have the property named “prototype”, but all objects have a prototype. Calls the function Person with this set to the new object, and with the supplied arguments. If calling the function Person returns an object, this object is the result of the expression. Otherwise the newly created object is the result of the expression. new F vs Object.create Answer: new F is Object.create(F.prototype) with additionally running the constructor function. And giving the constructor the chance to return the actual object that should be the result of the expression instead of this. So basically Object.create doesn’t execute the constructor. Explanation: Object.create methods allows you to easily implement differential inheritance, where objects can directly inherit from other objects. 12345678910111213141516var userB = &#123; sayHello: function() &#123; console.log('Hello '+ this.name); &#125;&#125;;var bob = Object.create(userB, &#123; // object descriptor 'id' : &#123; value: MY_GLOBAL.nextId(), enumerable:true // writable:false, configurable(deletable):false by default &#125;, 'name': &#123; value: 'Bob', enumerable: true &#125;&#125;); DOM Is there are a difference window VS document? Answer: Yes. JavaScript has a global window object and everything runs under it. document is a property of window object. Explanation: window is global object that holds global variables, global functions, location, history everything is under it. Besides, setTimeout, ajax call (XMLHttpRequest), console or localStorage are part of window. document is also under window. document represents the DOM, the object oriented representation of the html markup. All the nodes are part of document. Hence you can use getElementById or addEventListener on document. These methods are not present in the window object. How could you make sure to run some javaScript when DOM is ready like $(document).ready? Answer: There are four different ways: Put your script in the last tag of html body element. DOM would be ready by the time browser hits the script tag. Place your code inside a DOMContentLoaded handler. This event will be fired when DOM is completely loaded. Watch changes in the readyState of the document. And the last state is &quot;complete&quot; state, you can put your code there. Use jQuery $(document).ready. window.onload VS document.onload VS document.addEventListener(&#39;DOMContentLoaded&#39;). Do they fire at the same time? Answer: window.onload is fired when all page is loaded, including all resources (images, styles, iframes) document.onload is fired when DOM (DOM tree built from markup code within the document) is ready which without external content. DOMContentLoaded means that DOM has already been built, we can use handlers or search through the nodes, but resources such as images, styles don’t be loaded yet Is attribute similar to property? Answer: We operate with DOM-properties via JS. Attributes are part of HTML markup. Explanation: What is a property? JS objects have DOM-properties. These properties are kind of like instance variables for the particular element. As such, a property can be different types (boolean, string, etc.). Properties can be accessed as object properties: a.href What is an attribute? Attributes are in the HTML itself, rather than in the DOM. They are very similar to properties, but not quite as good. When a property is available it’s recommended that you work with properties rather than attributes. elem.hasAttribute(name) elem.getAttribute(name) elem.setAttribute(name, value) elem.removeAttribute(name) elem.attributes What are the different ways to get an element from DOM? Answer: You can use the following methods in document: getElementById to get a element that has the provided Id. getElementsByClassName to get a nodelist (nodelist is not an array, rather it is array-like object) by providing a class name. getElementsByTagName to get a nodelist by the provided tag name. getElementsByName to get a nodelist by name property querySelector you will pass css style selector and this will return first matched element in the DOM. querySelectorAll will return a non-live nodelist by using depth-first pre order traversal of all the matched elements. Non-live means, any changes after selecting the elements will not be reflected. There are two more options but don’t used frequently: getElementsByName returns the list of elements by the provided name of the html tag getElementsByTagNameNS returns elements with particular tag name within the provided namespace Fastest way to Query DOM: Answer: If you have an ID of an element getElmentById is the fastest way to select an element. However, you should not have so many ID in you document to avoid style repetition. getElementsByClassName is the second quickest way to select an element. Here is the list. As we go downwards through the list, it takes more time to select elements. ID (#myID) Class (.myClass) Tag (div, p) Sibling (div+p, div~p) child (div&gt;p) Descendant (div p) Universal (*) Attribute (input[type=”checkbox”]) Pseudo (p:first-child) Why querySelectorAll(&#39;.my-class&#39;) is slower than getElementsByClassName(&#39;my-class&#39;)? Answer: querySlectorAll is a generic purpose method. It is optimized for different kinds of selectors. Hence it has to check whether you put a &quot;#&quot; or &quot;.&quot; in front of the parameter you are passing. If you are just passing a class name with &quot;.&quot;, under the hood it uses getElementsByClassName (could vary based on browser implements). Whereas if you directly uses getElementsByClassName it directly uses this method and doesn’t have to go through all the initial processing of querySelectorAll. Hence to search elements with a particular class name, getElementsByClassName is faster than querySelectorAll. Why we can’t use forEach or similar array methods on a NodeList? How could you solve this problem? Answer: Both array and nodeList have length and you can loop through elements but they are not same object. Both are inherited from Object. However array has different prototype object than nodeList. forEach, map, etc are on array.prototype which doesn’t exist in the NodeList.prototype object: 123myArray --&gt; Array.prototype --&gt; Object.prototype --&gt; nullmyNodeList --&gt; NodeList.prototype --&gt; Object.prototype --&gt; null Answer: Convert NodeList to an array. After that you will have access to all array.prototype methods. 1234567891011121314151617181920// ES5var myNodeList = document.querySelectorAll('.my-class');var nodesArray = Array.prototype.slice.call(myNodeList);//use array method on nodeListnodesArray.forEach(function(el, idx)&#123; console.log(idx, el);&#125;);// ES6const myNodeList = document.querySelectorAll('.my-class');// Spread operator[...myNodeList].forEach(cb);// Array.from()Array.from(myNodeList).forEach(cb);// for...of statementfor (var el of myNodeList) cb(el); How would you add/remove/toggle a class to an element? Answer: 123el.classList.remove('my-class'); //removing a classel.classList.toggle('my-class'); // toggling a classel.classList.contains('my-class'); // checking whether class exists How to check if element isn’t empty, without children? 1234567if (!elem.childNodes.length) &#123; ... &#125;if (!elem.hasChildNodes()) &#123; ... &#125;if (!elem.firstChild) &#123; ... &#125;if (!elem.lastChild) &#123; ... &#125; How you would perform next operation: create element with content, add data-foo attribute, append newly created element to whatever you want, then move it before some element, change text of it, remove it from DOM. How to clone an element? Answer: Use the next methods document.createElement(tag), el.innerHTML, parent.appendChild(el), parent.insertBefore(el, someEl), parent.removeChild(el) For clone an element we can create function or use el.cloneNode(true) where true means deep cloning. How to delete all children of element? Answer: 123456789function removeChildren(elem) &#123; try &#123; elem.innerHTML = ''; //dont work with table cells and etc. &#125; catch (e) &#123; while (elem.firstChild) &#123; elem.removeChild(elem.firstChild); &#125; &#125;&#125; createTextNode vs innerHTML Answer: It depends on content. innerHTML inserts content as HTML, but createTextNode inserts tags as text. What is the best way to create a DOM element? Set innherHTML or use createElement? Do you know about insertAdjacentHTML? Answer: According to jsPerf option 1 is approximately 3 times slower than option 2. Explanation: appendChild does not cause a complete rebuild of the DOM or even all of the elements/nodes within the target. innerHTML does cause a complete rebuild of the content of the target element, which if you’re appending is unnecessary. Appending via innerHTML += content makes the browser run through all of the nodes in the element building an HTML string to give to the JavaScript layer. Your code then appends text to it and sets innerHTML, causing the browser to drop all of the old nodes in the target, re-parse all of that HTML, and build new nodes. So in that sense, it may not be efficient. (However, parsing HTML is what browsers do and they’re really, really fast at it.) Setting innerHTML does indeed invalidate any references to elements within the target element you may be holding - because those elements don’t exist anymore, you removed them and then put in new ones (that look very similar) when you set innerHTML. In short, if you’re appending, I’d use appendChild or insertAdjacentHTML. If you’re replacing, there are very valid situations where using innerHTML is a better option than creating the tree yourself via the DOM API. Finally, it’s worth mentioning insertAdjacentHTML, which is a function that you can use to insert nodes and elements into or next to an element using an HTML string. You can append to an element with it: theElement.insertAdjacentHTML(&quot;beforeend&quot;, &quot;the HTML goes here&quot;); What is createDocumentFragment and why you might use it? Answer: If you are changing DOM that cause expensive reflow, you can avoid it by using documentFragment as it is managed in the memory. Explanation: documentFragment a very lightweight or minimal part of a DOM or a subtree of a DOM tree. It is very helpful when you are manipulating a part of DOM for multiple times. It becomes expensive to hit a certain portion of DOM for hundreds time. You might cause reflow for hundred times. A bad practice, you are hitting the DOM every single time: 123456789//var list = ['foo', 'bar', 'baz', ... ], el, text;for (var i = 0; i &lt; list.length; i++) &#123; el = document.createElement('li'); text = document.createTextNode(list[i]); el.appendChild(text); document.body.appendChild(el);&#125; A good practice, you causing reflow one time: 12345678910var fragment = document.createDocumentFragment(), list = ['foo', 'bar', 'baz', ...], el, text;for (var i = 0; i &lt; list.length; i++) &#123; el = document.createElement('li'); text = document.createTextNode(list[i]); el.appendChild(text); fragment.appendChild(el);&#125;document.body.appendChild(fragment); When would you use “document.write()” ? Answer: In terms of vendors supplying third parties or analytics code (like Google Analytics) it’s actually the easiest way for them to distribute such snippets. 12345&lt;script&gt; var url = 'http://ads.com/buyme?screen=' + screen.width + \"x\" + screen.height; document.write('&lt;script src=\"' + url + '\"&gt;&lt;/scr' + 'ipt&gt;');&lt;/script&gt; Explanation: It keeps the scripts small They don’t have to worry about overriding already established onload events or including the necessary abstraction to add onload events safely It’s extremely compatible document.write only works while the page is loading; If you call it after the page is done loading, it will overwrite the whole page. This effectively means you have to call it from an inline script block - And that will prevent the browser from processing parts of the page that follow. Scripts and Images will not be downloaded until the writing block is finished. What is reflow? What causes reflow? How could you reduce reflow? Answer: When you change size or position of an element in the page, all the elements after it has to change their position according to the changes you made. For example, if you change height on an element, all the elements under it has to move down in the page to accomodate a change in height. Hence, flow of the elements in the page is changed and this is called reflow. Re-flows could be very expensive and it might have a performance hit specially in the smaller devices like phone. As it might causes changes in the portion (or whole) layout of the page. The following cases causes reflow: change layout (geometry of the page) resize the window change height/width of any element changing font change font size move DOM element (animation) adding or removing stylesheet calculating offset height or offset width display: none; How to avoid: To avoid reflow, try to avoid doing things in the above list and some more in the below avoid setting multiple inline style apply animation to the elements that are positioned fixed or absolute avoid tables for layout More: reflow and repaint: css performance makes your JS slow What is repaint and when does this happen? Answer: repaint happens when you change the look of an element without changing the size and shape. This doesn’t cause reflow as geometry of the element didn’t changed. How it happens: change background color change text color visibility hidden What is defer and async attribute does in a script tag? Answer: HTML parser will ignore defer and async keyword for inline script (script that does not have a src attribute). with &lt;script async src=&quot;...&quot;&gt; browser downloads the file during HTML parsing and will pause the HTML parser to execute it when it has finished downloading with &lt;script defer src=&quot;...&quot;&gt; browser downloads the file during HTML parsing and will only execute it after the parser has completed. defer scripts are also guarenteed to execute in the order that they appear in the document. 12&lt;script src=\"1.js\" async&gt;&lt;/script&gt;&lt;script src=\"2.js\" async&gt;&lt;/script&gt; Examples: 1234567891011//1&lt;script src=\"big.js\"&gt;&lt;/script&gt;&lt;script src=\"small.js\"&gt;&lt;/script&gt;//2&lt;script async src=\"big.js\"&gt;&lt;/script&gt;&lt;script async src=\"small.js\"&gt;&lt;/script&gt;//3&lt;script defer src=\"big.js\"&gt;&lt;/script&gt;&lt;script defer src=\"small.js\"&gt;&lt;/script&gt; Events What is event bubble? How does event flows (event phases)? Answer: to understand event bubble, you have to understand what happen when you click on anything on a page. The event flow model specified by DOM Level 2 Events has three phases to it: Capture: When you clicked, browser knows a click event occurred. It starts from the window (lowest level/root of your website), then goes to document, then html root tag, then body, then table… its trying to reach the the as lowest level of element as possible. This is called capture phase (phase -1). Target: When browser reach the lowest level of element. In this case, you have clicked on a table cell (table data) hence target would be td tag. Then browser checks whether you have any click handler attached to this element. If there is any, browser executes that click hander. This is called target phase (phase -2).Bubbling: After firing click hander attached to td, browser walks toward root. One level upward and check whether there is any click handler attached with table row tr element. If there is any it will execute that. Then it goes to tbody, table, body, html, document, window. In this stage its moving upward and this is called event bubbling or bubbling phase (phase-3). Event handlers with on&lt;eventName&gt; doesn’t know anything about capture phase. To capture on capture phase need to addEventListener(&lt;eventName&gt;, &lt;cb&gt;, true), otherwise it will work by bubble phase. Explain event delegation Answer: Event delegation allows you to avoid adding event listeners to specific nodes, instead, the event listener is added to one parent. That event listener analyzes bubbled events to find a match on child elements. Explanation: Let’s say that we have a parent UL element with several child elements: 12345678&lt;ul id=\"parent-list\"&gt; &lt;li id=\"post-1\"&gt;Item 1&lt;/li&gt; &lt;li id=\"post-2\"&gt;Item 2&lt;/li&gt; &lt;li id=\"post-3\"&gt;Item 3&lt;/li&gt; &lt;li id=\"post-4\"&gt;Item 4&lt;/li&gt; &lt;li id=\"post-...\"&gt;...&lt;/li&gt; &lt;li id=\"post-1001\"&gt;Item 1001&lt;/li&gt;&lt;/ul&gt; Let’s also say that something needs to happen when each child element is clicked. You could add a separate event listener to each individual LI element, but what if LI elements are frequently added and removed from the list? Adding and removing event listeners would be a nightmare, especially if addition and removal code is in different places within your app. The better solution is to add an event listener to the parent UL element. When the event bubbles up to the UL element, you check the event object’s target property to gain a reference to the actual clicked node: 123456789// Get the element, add a click listener...document.getElementById(\"parent-list\").addEventListener(\"click\", function(e) &#123; // e.target is the clicked element! // If it was a list item if(e.target &amp;&amp; e.target.nodeName == \"LI\") &#123; // List item found! Output the ID! console.log(\"List item \", e.target.id.replace(\"post-\", \"\"), \" was clicked!\"); &#125;&#125;); Can you remove an event handler from an element? Answer: target.removeEventListener(&#39;click&#39;, &lt;handledName&gt;) How could you prevent a click on an anchor from going to the link? How could you stop further propagation of an event? Answer: preventDefault() inside event handler. However, this doesn’t stop further propagation. To stop it event.stopPropagation(); How to capture all click in a page? Answer: You can leverage event bubble to get all the clicks. As all the clicks will be bubbled up to the body. 12345678document.querySelector('body').addEventListener('click', function(e)&#123; console.log('body clicked', e.target);&#125;);//orwindow.onclick = function(e)&#123; console.log('someone clicked', e.target)&#125; AJAX Explain AJAX in as much detail as possible Answer: AJAX is a way to communicate to the server without reloading the page. Once we receive the data from the server, we can then manipulate those data and display unto certain parts of the page, this is why we don’t need to reload the page. Explanation: AJAX stands for Asynchronous JavaScript and XML. In a nutshell, it is the use of the XMLHttpRequest object to communicate with server-side scripts. It can send as well as receive information in a variety of formats, including JSON, XML, HTML, and even text files. AJAX’s most appealing characteristic, however, is its “asynchronous” nature, which means it can do all of this without having to refresh the page Typical example for GET request with XMLHttpRequest: What is COMET? How to achieve this technique? Answer: he AJAX - is a “request sent - get the result,” and the COMET - is “a continuous channel through which the data come.” Explanation: Comet is a Web application model that enables web servers to send data to the client without having to explicitly request it. Examples COMET-app: Chat - man sitting and watching what others write. At the same time new messages arrive “on their own”, he should not have to press a button to refresh the chat window. Auction - a person looks at the screen and sees renewed the current bid for the goods. Editing interface - when one editor is beginning to change the document, others see the information about it. Perhaps, and collaborative editing, editors when they see each other’s changes. COMET techniques overview: Polling: a simple method based on periodically polling the server. Long poll: A method by which a client opens a connection and doesn’t close it up until the event occurs. In the event occurs, the client receives a notification and then opens a connection again. “Infinite” iframe: The method is based on html document download features. It creates an invisible iframe, which reads “infinite” file. When an event occurs, a new row is added to the file. The string can be a javascript snippet. HTML5 WebSockets: specification defines an API establishing “socket” connections between a web browser and a server. In plain words: There is an persistent connection between the client and the server and both parties can start sending data at any time. How to work with HTTP headers in AJAX. Do we have a restriction? Answer: There are three methods setRequestHeader(name, value), getResponseHeader(name), getAllResponseHeaders() Send JSON Object with Ajax? Answer: Use xhr.setRequestHeader(&quot;Content-Type&quot;, &quot;application/x-www-form-urlencoded&quot;) and JSON.stringify(&lt;object&gt;); 123456var jsonRequest = \"json_name=\" + JSON.stringify(&#123;name:\"John\", time:\"2pm\"&#125;);var xhr = new XMLHttpRequest();xhr.open(\"POST\", \"/submit\");xhr.setRequestHeader(\"Content-Type\", \"application/x-www-form-urlencoded\");xhr.send(json_upload); Sending POST data using an XMLHttpRequest using different encoding patterns. Answer: With XMLHttpRequest we don’t need explicitly set header with Content-type. In spec are 3 types for submitting body entity: application/x-www-form-urlencoded multipart/form-data text-plain With application/x-www-form-urlencoded: 1234567891011var xhr = new XMLHttpRequest();var body = 'name=' + encodeURIComponent(name) + '&amp;surname=' + encodeURIComponent(surname);xhr.open(\"POST\", '/submit', true)xhr.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded')xhr.onreadystatechange = ...;xhr.send(body); With multipart/form-data: 123456789101112131415&lt;form name=\"person\"&gt; &lt;input name=\"name\" value=\"John\"&gt; &lt;input name=\"surname\" value=\"Doe\"&gt;&lt;/form&gt;&lt;script&gt; var formData = new FormData(document.forms.person); formData.append(\"patronym\", \"Робертович\"); var xhr = new XMLHttpRequest(); xhr.open(\"POST\", \"/url\"); xhr.setRequestHeader('Content-Type', 'multipart/form-data') xhr.send(formData);&lt;/script&gt; ES6 When standard was finalized? The ES6 specification was finalized in June 2015, (hence ES2015). Future versions of the specification will follow the ES[YYYY] pattern, e.g ES2016 for ES7. Tooling To get ES6 working today, you need a JavaScript-to-JavaScript transpiler: They allow you to compile code in the latest version into older versions of the language As browser support gets better, we’ll transpile ES2016 and ES2017 into ES6 and beyond We’ll need better source mapping functionality They’re the most reliable way to run ES6 source code in production today (although browsers get ES5) Use babel to transpile ES6 into ES5 for static build Use babelify to incorporate babel into your Gulp, Grunt, or npm run build process Use Node.js v4.x.x or greater as they have decent ES6 support baked in, thanks to v8 Use babel-node with any version of node, as it transpiles modules into ES5 Assignment Destructing, the Rapid Table Spread Operator and Rest Parameters Arrow Functions Template Literals Object Literals Classes Let and Const Symbols Iterators Generators Promises Maps / WeakMaps Sets / WeakSets Modules Proxy TODO with https://ponyfoo.com/articles/es6 JavaScript: advance What do you think of AMD vs CommonJS and ES6 modules? Answer: For many years JS had a single widely accepted module format, which is to say, there was none. Everything was a global variable petulantly hanging off the window object. Dark Ages. Long ago an adhoc group formed to solve the global conflict. The fruits of this vigilante justice are known today as CommonJS. Multiple competing formats were proposed and implemented in the wild by these dashing radicals and two bright lights emerged with significant adherents: AMD and CJS. Asynchronous Module Design (AMD) accounts for the async nature of JS but some felt the aesthetics were harder to read with a wrapper function. CommonJS (CJS) is synchronous, thus blocking, but generally understood to be an easier read. 1234567// this is an AMD moduledefine(function () &#123; return something&#125;)// and this is CommonJSmodule.exports = something JavaScript vendors and concerned citizens began formally standardizing modules into the language proper. After years of thrashing, a standard module format has finally emerged with ES6. What is asynchronous programming, and why is it important in JS? Non-blocking I/O in JS. Synchronous programming means that code is executed sequentially from top-to-bottom, blocking on long-running tasks such as network requests and disk I/O. Asynchronous programming means that the engine runs in an event loop. When a blocking operation is needed, the request is started, and the code keeps running without blocking for the result. When the response is ready, an interrupt is fired, which causes an event handler to be run, where the control flow continues. In this way, a single program thread can handle many concurrent operations. Node is asynchronous by default, meaning that the server works in much the same way, waiting in a loop for a network request, and accepting more incoming requests while the first one is being handled. In JavaScript, almost all I/O is non-blocking. This includes: Networking requests DB operations Disk reads and writes User interfaces are asynchronous by nature, and spend most of their time waiting for user input to interrupt the event loop and trigger event handlers The single thread of execution asks the runtime to perform an operation, providing a callback function and then moves on to do something else. When the operation has been completed, a message is enqueued along with the provided callback function. At some point in the future, the message is dequeued and the callback fired. Let’s compare two bits of code that make HTTP requests to www.google.com and output the response to console with Node.js and the Request: 12345request('http://www.google.com', function(error, response, body) &#123; console.log(body);&#125;);console.log('Done!'); The request function is executed, passing an anonymous function as a callback to execute when a response is available sometime in the future. “Done!” is immediately output to the console Sometime in the future, the response comes back and our callback is executed, outputting its body to the console The Event Loop The decoupling of the caller from the response allows for the JavaScript runtime to do other things while waiting for your asynchronous operation to complete and their callbacks to fire. But where in memory do these callbacks live – and in what order are they executed? What causes them to be called? JavaScript runtimes contain a message queue which stores a list of messages to be processed and their associated callback functions. These messages are queued in response to external events (such as a mouse being clicked or receiving the response to an HTTP request) given a callback function has been provided. If, for example a user were to click a button and no callback function was provided – no message would have been enqueued. In a loop, the queue is polled for the next message (each poll referred to as a “tick”) and when a message is encountered, the callback for that message is executed. Macrotasks and Microtasks Take this little bit of JavaScript: 1234567891011121314151617181920212223242526272829303132console.log('script start')const interval = setInterval(() =&gt; &#123; console.log('setInterval')&#125;, 0)setTimeout(() =&gt; &#123; console.log('setTimeout 1') Promise.resolve().then(() =&gt; &#123; console.log('promise 3') &#125;).then(() =&gt; &#123; console.log('promise 4') &#125;).then(() =&gt; &#123; setTimeout(() =&gt; &#123; console.log('setTimeout 2') Promise.resolve().then(() =&gt; &#123; console.log('promise 5') &#125;).then(() =&gt; &#123; console.log('promise 6') &#125;).then(() =&gt; &#123; clearInterval(interval) &#125;) &#125;, 0) &#125;)&#125;, 0)Promise.resolve().then(() =&gt; &#123; console.log('promise 1')&#125;).then(() =&gt; &#123; console.log('promise 2')&#125;)console.log('script end') Answer: 123456789101112script start promise 1 promise 2 setInterval setTimeout 1 promise 3 promise 4 setInterval setTimeout 2 setInterval promise 5 promise 6 To understand this you need to know how the event loop handles macrotasks and microtasks. macrotasks: setTimeout, setInterval, setImmediate, I/O, UI renderingmicrotasks: process.nextTick, Promises, Object.observe, MutationObserver A great post. What is the difference between “classical inheritance” and “prototypal inheritance”? Class Inheritance: instances inherit from classes (like a blueprint — a description of the class), and create sub-class relationships: hierarchical class taxonomies. Instances are typically instantiated via constructor functions with the new keyword. Class inheritance may or may not use the class keyword from ES6. Prototypal Inheritance: instances inherit directly from other objects. Instances are typically instantiated via factory functions or Object.create(). Instances may be composed from many different objects, allowing for easy selective inheritance. Good to hear: Classes: create tight coupling or hierarchies/taxonomies. Prototypes: mentions of concatenative inheritance, prototype delegation, functional inheritance, object composition. What are the pros and cons of functional programming vs object-oriented programming? OOP Pros: It’s easy to understand the basic concept of objects and easy to interpret the meaning of method calls. OOP tends to use an imperative style rather than a declarative style, which reads like a straight-forward set of instructions for the computer to follow. OOP Cons: OOP Typically depends on shared state. Objects and behaviors are typically tacked together on the same entity, which may be accessed at random by any number of functions with non-deterministic order, which may lead to undesirable behavior such as race conditions. FP Pros: Using the functional paradigm, programmers avoid any shared state or side-effects, which eliminates bugs caused by multiple functions competing for the same resources. With features such as the availability of point-free style (aka tacit programming), functions tend to be radically simplified and easily recomposed for more generally reusable code compared to OOP. FP Cons: Over exploitation of FP features such as point-free style and large compositions can potentially reduce readability because the resulting code is often more abstractly specified, more terse, and less concrete.More people are familiar with OO and imperative programming than functional programming, so even common idioms in functional programming can be confusing to new team members. What does “favor object composition over class inheritance” mean? This is a quote from “Design Patterns: Elements of Reusable Object-Oriented Software”. Object composition is a way to combine simple objects or data types into more complex ones. It means that code reuse should be achieved by assembling smaller units of functionality into new objects instead of inheriting from classes and creating object taxonomies. 12import &#123; a, b, c &#125; from 'components';composedObject = Object.assign(&#123;&#125;, a, b, c); Good to hear: Avoid class hierarchies. Avoid brittle base class problem. Avoid tight coupling. Avoid rigid taxonomy (forced is-a relationships that are eventually wrong for new use cases). Avoid the gorilla banana problem (“what you wanted was a banana, what you got was a gorilla holding the banana, and the entire jungle”). What are two-way data binding and one-way data flow, and how are they different? Two way data binding means that UI fields are bound to model data dynamically such that when a UI field changes, the model data changes with it and vice-versa. One way data flow means that the model is the single source of truth. Changes in the UI trigger messages that signal user intent to the model (or “store” in React). Only the model has the access to change the app’s state. The effect is that data always flows in a single direction, which makes it easier to understand. One way data flows are deterministic, whereas two-way binding can cause side-effects which are harder to follow and understand. Good to hear:React is the new canonical example of one-way data flow, so mentions of React are a good signal. Cycle.js is another popular implementation of uni-directional data flow.Angular is a popular framework which uses two-way binding. What are the pros and cons of monolithic vs microservice architectures? A monolithic architecture means that your app is written as one cohesive unit of code whose components are designed to work together, sharing the same memory space and resources. A microservice architecture means that your app is made up of lots of smaller, independent applications capable of running in their own memory space and scaling independently from each other across potentially many separate machines. Good to hear: Monolithic Pros: The major advantage of the monolithic architecture is that most apps typically have a large number of cross-cutting concerns, such as logging, rate limiting, and security features such audit trails and DOS protection. When everything is running through the same app, it’s easy to hook up components to those cross-cutting concerns. Monolithic cons: Monolithic app services tend to get tightly coupled and entangled as the application evolves, making it difficult to isolate services for purposes such as independent scaling or code maintainability. Monolithic architectures are also much harder to understand, because there may be dependencies, side-effects, and magic which are not obvious when you’re looking at a particular service or controller. Microservice pros: Microservice architectures are typically better organized, since each microservice has a very specific job, and is not concerned with the jobs of other components. Decoupled services are also easier to recompose and reconfigure to serve the purposes of different apps (for example, serving both the web clients and public API). They can also have performance advantages depending on how they’re organized because it’s possible to isolate hot services and scale them independent of the rest of the app. Microservice cons: As you’re building a new microservice architecture, you’re likely to discover lots of cross-cutting concerns that you did not anticipate at design time. A monolithic app could establish shared magic helpers or middleware to handle such cross-cutting concerns without much effort. MarkupHTML What is doctype? Why do u need it? Answer: doctype is an instruction to the browser to inform about the version of html document and how browser should render it. Explanation: It ensures how element should be displayed on the page by most of the browser. And it also makes browser’s life easier. otherwise, browser will guess and will go to quirks mode. Moreover, doctype is required to validate markup. 12&lt;!DOCTYPE html&gt;&lt;meta charset=\"UTF-8\"&gt; Difference between standard/strict mode and quirks mode? Answer: quirks mode in browser allows u to render page for as old browsers. This is for backward compatibility. What is the use of data- attribute? Answer: allow you to store extra information/data in the DOM and allows to write valid html with embedded private data. You can easily access data attribute by using JS. 1&lt;div id=\"myDiv\" data-user=\"jsDude\" data-list-size=\"5\" data-maxage=\"180\"&gt;&lt;/div&gt; What is the difference between span and div? Answer: div is a block element, span is inline. This means that to use them semantically, divs should be used to wrap sections of a document, while spans should be used to wrap small portions of text, images, etc. When should you use section, div or article? Answer: To decide which of these three elements is appropriate, choose the first suitable option: Would the enclosed content would make sense on it’s own in a feed reader? If so use &lt;article&gt; Is the enclosed content related? If so use &lt;section&gt; Finally if there’s no semantic relationship use &lt;div&gt; What is “Semantic HTML?” Answer: Semantic HTML is a coding style where the tags embody what the text is meant to convey. Explanation: In Semantic HTML, tags like &lt;b&gt;&lt;/b&gt; for bold, and &lt;i&gt;&lt;/i&gt; for italic should not be used, reason being they just represent formatting, and provide no indication of meaning or structure. The semantically correct thing to do is use &lt;strong&gt;&lt;/strong&gt; and &lt;em&gt;&lt;/em&gt;. These tags will have the same bold and italic effects, while demonstrating meaning and structure (emphasis in this case). What are some new HTML5 markup elements? Answer: There are several: , , , , , , , , , , , , , , , , , , , and . What are the new media-related elements in HTML5? Answer: HTML5 has strong support for media. There are now special &lt;audio&gt; and &lt;video&gt; tags. There are additional A/V support tags as well: &lt;embed&gt; is a container for 3rd party applications. What is the difference between SVG and Canvas? Answer: SVG is a document format for scalable vector graphics. Canvas is a javascript API for drawing vector graphics to a bitmap of a specific size. Explanation: SVG is XML based, which means that every element is available within the SVG DOM. You can attach JavaScript event handlers for an element. With SVG you can view, save and edit the file in many different tools. In SVG, each drawn shape is remembered as an object. If attributes of an SVG object are changed, the browser can automatically re-render the shape. Canvas is rendered pixel by pixel. In canvas, once the graphic is drawn, it is forgotten by the browser. If its position should be changed, the entire scene needs to be redrawn, including any objects that might have been covered by the graphic. Canvas: Pixel based Single HTML element.(Inspect element in Developer tool. You can see only canvas tag) Modified through script only Event model/user interaction is granular (x,y) Performance is better with smaller surface, a larger number of objects (&gt;10k), or both SVG: Shape based Multiple graphical elements, which become part of the SVG DOM Modified through script and CSS Event model/user interaction is abstracted (rect, path) Performance is better with smaller number of objects (&lt;10k), a larger surface, or both Describe the difference between cookies, sessionStorage, and localStorage Answer: localStorage, sessionStorage and cookies are all client storage solutions. Cookies are small text files that websites place in a browser for tracking or login purposes. Meanwhile, localStorage and sessionStorage are new objects, both of which are storage specifications but vary in scope and duration. Of the two, localStorage is permanent and website-specific whereas sessionStorage only lasts as long as the duration of the longest open tab. You can save to localStorage and sessionStorage only primitives, for object you need you use JSON.stringify1 CSSGeneral Website Optimization Questions How do you optimize a website’s assets? Answer: There are a number of answers to this question: File concatenation, file compression, CDN Hosting, offloading assets, re-organizing and refining code, etc. What are ways to reduce page load time? Answer: Again there are many answers here: Reduce image sizes, remove unnecessary widgets, HTTP compression, put CSS at the top and script references at the bottom or in external files, reduce lookups, minimize redirects, caching, etc. What kind of things must you be wary of when design or developing for multilingual sites? Answer: Another problem with many solutions: setting the default language, using Unicode encoding, using the lang attribute, being aware of standard font sizes and text direction, and language word length (may affect layout). TechnologiesJS FrameworkAngularJS List at least three ways to communicate between modules of your application using core AngularJS functionality. Answer: There are at least three idiomatic way to achieve this: Using services Using events Directly between controllers, using ControllerAs, or other forms of inheritance By assigning models on $rootScope Directly between controllers, using $parent, $$childHead, $$nextSibling, etc. Which means of communication between modules of your application are easily testable? Answer: The big deal is in DI patten. Using a service is definitely easy to test. Services are injected, and in a test either a real service can be used or it can be mocked. Events can be tested. In unit testing controllers, they usually are instantiated. For testing events on $rootScope, it must be injected into the test. For testing direct communication between controllers, the expected results should probably be mocked. Otherwise, controllers would need to be manually instantiated to have the right context. The most popular e2e testing tool for AngularJS is Protractor. Describe how e2e testing of AngularJS applications work? The e2e tests are executed against a running app, that is a fully initialized system. They most often spawn a browser instance and involve the actual input of commands through the user interface. The written code is evaluated by an automation program, such as a Selenium server (webdriver). That program sends commands to a browser instance, then evaluates the visible results and reports back to the user. The assertions are handled by another library, for Protractor (end-to-end) / Karma (unit tests) the default is Jasmine. What are the basic steps to unit test an AngularJS filter? Inject the module that contains the filter. Provide any mocks that the filter relies on. Get an instance of the filter using $filter(‘yourFilterName’). Assert your expectations. 123456789101112131415161718192021222324252627282930describe('Filter: myFltr', function () &#123; var myFltr; beforeEach(function () &#123; // Load the filters's module module('myApp'); // Provide any mocks needed module(function ($provide) &#123; //$provide.value('Name', new MockName()); &#125;); // Inject in angular constructs otherwise, // you would need to inject these into each test inject(function ($filter) &#123; myFltr = $filter('myFltr'); &#125;); &#125;); it('should exist', function () &#123; expect(!!myFltr).toBe(true); &#125;); describe('when evaluating an expression', function () &#123; it('should return the expected output', function () &#123; var text = 'AngularJS'; expect(myFltr(text)).toBe('my filter: ' + text); &#125;); &#125;);&#125;); When a scope is terminated, “destroy” events are fired. What are they used for, and why are there two? The first one is an AngularJS event, “$destroy” can be used by AngularJS scopes where they are accessible, such as in controllers or link functions. 123456scope.$on(‘$destroy’, function () &#123; // handle the destroy, i.e. clean up.&#125;);// in 1.5.x$onDestroy() &#123;...&#125; The jqLite / jQuery event is called whenever a node is removed, which may just happen without scope teardown: 1234element.on(‘$destroy’, function () &#123; // respectful jQuery plugins already have this handler. // angular.element(document.body).off(‘someCustomEvent’);&#125;); How do you reset a $timeout, and disable a $watch()? Answer: The key to both is assigning the result of the function to a variable. To cleanup the timeout, just .cancel() it: 12345var customTimeout = $timeout(function () &#123; // arbitrary code&#125;, 55);$timeout.cancel(customTimeout); The same applies to $interval(). To disable a watch, just call it: 1234567var deregisterWatchFn = $rootScope.$watch(‘someGloballyAvailableProperty’, function (newVal) &#123; if (newVal) &#123; // we invoke that deregistration function, to disable the watch deregisterWatchFn(); ... &#125;&#125;); Name and describe the phases of a directive definition function execution, or describe how directives are instantiated. Each directive undergoes something similar to a life cycle as AngularJS compiles and links the DOM. The directive lifecycle begins and ends within the AngularJS bootstrapping process, before the page is rendered. In a directive’s life cycle, there are four distinct functions that can execute if they are defined. Each enables the developer to control and customize the directive at different points of the life cycle. The compile function allows the directive to manipulate the DOM before it is compiled and linked thereby allowing it to add/remove/change directives, as well as, add/remove/change other DOM elements. The controller function facilitates directive communication. Sibling and child directives can request the controller of their siblings and parents to communicate information. The pre-link function allows for private $scope manipulation before the post-link process begins. The post-link method is the primary workhorse method of the directive. 123456789101112131415161718.directive(\"directiveName\",function () &#123; return &#123; controller: function() &#123; // controller code here... &#125;, compile: &#123; // compile code here... return &#123; pre: function() &#123; // pre-link code here... &#125;, post: function() &#123; // post-link code here... &#125; &#125;; &#125; &#125;&#125;) Commonly, not all of the functions are needed. In most circumstances, developers will simply create a controller and link (which refers to post-link) function following the pattern below. 1234567891011.directive(\"directiveName\",function () &#123; return &#123; controller: function() &#123; // controller code here... &#125;, link: function() &#123; // post-link code here... &#125; &#125;&#125;) More here. How does interpolation, e.g. {{ someModel }}, actually works? During the compilation process the compiler uses the $interpolate service to see if text nodes and element attributes contain interpolation markup with embedded expressions. If that is the case, the compiler adds watches on the computed interpolation function, which will update the corresponding text nodes or attribute values as part of the normal digest cycle. How does the digest phase work? In a nutshell, on every digest cycle all scope models are compared against their previous values. That is dirty checking. If change is detected, the watches set on that model are fired. Then another digest cycle executes, and so on until all models are stable. As long as core directives are used, we don’t need to worry, but when external code changes models the digest cycle needs to be called manually. Usually to do that, $apply(), $digest(), $timeout(), $evalAsync(). List a few ways to improve performance in an AngularJS app The first one can be enabled through the $compileProvider: 123.config(function ($compileProvider) &#123; $compileProvider.debugInfoEnabled(false);&#125;); Call this method to enable/disable various debug runtime information in the compiler such as adding binding information and a reference to the current scope on to DOM elements. If enabled, the compiler will add the following to DOM elements that have been bound to the scope ng-binding CSS class $binding data property containing an array of the binding expressions Using one-time binding where possible. Those bindings are set, e.g. in { { ::someModel } } interpolations by prefixing the model with two colons. In such a case, no watch is set and the model is ignored during digest. Making $httpProvider use applyAsync:123myApp.config(function ($httpProvider) &#123; $httpProvider.useApplyAsync(true);&#125;); That’s it! If the application now receives multiple $http responses at around the same time, this is what happens (a bit simplified though): The call’s promise is pushed into a queue An asynchronous $apply is scheduled in case there’s no one scheduled yet, by telling the browser to execute setTimeout() Once timed out, the queue is flushed and the actual$apply is triggered The setTimeout() is called with a 0 delay which causes an actual delay of around 10 milliseconds depending on the browser. That means, if our three asynchronous calls return at around the same time (somewhere inside that particular timeout delay), they get resolve with a single $digest cycle instead of three which speeds up our application. What is $rootScope and how does it relate to $scope? $rootScope is the parent object of all $scope Angular objects created in a web page. What is the difference between “ng-show”/“ng-hide” and “ng-if” directives? ng-show/ng-hide will always insert the DOM element, but will display/hide it based on the condition. ng-if will not insert the DOM element until the condition is not fulfilled. ng-if is better when we needed the DOM to be loaded conditionally, as it will help load page bit faster compared to ng-show/ng-hide Where should we implement the DOM manipulation in AngularJS? In the directives. DOM Manipulations should not exist in controllers, services or anywhere else but in directives. Otherwise it’s: It is not reusable It is not testable It include css hard coded selectors dependencies Is it a good or bad practice to use AngularJS together with jQuery? jQuery takes a traditional imperative approach to manipulating the DOM. In an imperative approach, it is up to the programmer to express the individual steps leading up to the desired outcome. What do I mean by this? So if we want an action to occur when a user types say 150 characters into an input, in jQuery we would say, “every time the user hits a key, check how many characters are in the input, if it exceeds 150 characters, do the action.” Every step is addressed along the way. AngularJS however takes a declarative approach to DOM manipulation. Here instead of worrying about all of the step by step details regarding how to do the desired outcome, AngularJS abstracts that and allows you to just say what you want done, in this case, “AngularJS, when the state of the input is at 150 characters, do this.” We are just declaring what we want and AngularJS worries about the rest, taking care of everything for us. It might seem like I’m just splitting hairs here, but it’s really an important distinction. AngularJS wants you basing your actions around the data models you create. It’s how the entire framework works and how your applications will be structured. To simply begin writing side scripts in jQuery where you are plucking out elements and setting up side event listeners just goes against the AngularJS approach in my opinion. If you were to migrate from Angular 1.4 to Angular 1.5, what is the main thing that would need refactoring? Changing .directive to .component to adapt to the new Angular 1.5 components. More about .component approach Lifecycle hooks in Angular 1.5 $onInit $postLink $onChanges $onDestroy More in awesome post. How would you specify that a scope variable should have one-time binding only? By using ::model.property in front of it. This allows the check if the candidate is aware of the available variable bindings in AngularJS. What is the difference between one-way binding and two-way binding? One way binding implies that the scope variable in the html will be set to the first value its model is bound to (i.e. assigned to). Two way binding implies that the scope variable will change it’s value everytime its model is assigned to a different value What is the role of services in AngularJS and name any services made available by default? Services are objects that provide separation of concerns to an AngularJS app. Services can be created using a factory method or a service method. Services are singleton components. All components of the application (into which the service is injected) will work with single instance of the service. Allows developing of business logic without depending on the View logic which will work with it. A typical service can be injected into another service or into an Controller. Few of the inbuilt services in AngularJS are:– the $http service: The $http service is a core Angular service that facilitates communication with the remote HTTP servers via the browser’s XMLHttpRequest object or via JSONP– the $log service: Simple service for logging. Default implementation safely writes the message into the browser’s console– the $anchorScroll: it scrolls to the element related to the specified hash or (if omitted) to the current value of $location.hash() What are Providers and when to use them? Each web application you build is composed of objects that collaborate to get stuff done. These objects need to be instantiated and wired together for the app to work. In Angular apps most of these objects are instantiated and wired together automatically by the $injector service. The $injector creates two types of objects, services and specialized objects. Services are objects whose API is defined by the developer writing the service. Specialized objects conform to a specific Angular framework API. These objects are one of controllers, directives, filters or animations. The injector needs to know how to create these objects. You tell it by registering a “recipe” for creating your object with the injector. There are five recipe types. The most verbose, but also the most comprehensive one is a Provider recipe. The remaining four recipe types — Value, Factory, Service and Constant — are just syntactic sugar on top of a provider recipe. The Provider recipe is the core recipe type and all the other recipe types are just syntactic sugar on top of it. It is the most verbose recipe with the most abilities, but for most services it’s overkill. When to use? You should use the Provider recipe only when you want to expose an API for application-wide configuration that must be made before the application starts. This is usually interesting only for reusable services whose behavior might need to vary slightly between applications. The Provider recipe is syntactically defined as a custom type that implements a $get method. This method is a factory function just like the one we use in the Factory recipe. In fact, if you define a Factory recipe, an empty Provider type with the $get method set to your factory function is automatically created under the hood. More in official docs. FundamentalsData Structure and algorithm Binary search A binary search tree is a great place to store data in an ordered way to allow for an easy search for specific information.It works by comparing the target value to the midpoint of the array; if they are not equal, the lower or upper half of the array is eliminated depending on the result and the search is repeated until the position of the target value is found. The basic algorithm, then, can be described as: If currentValue equals value, you’re done. If value is less than currentValue, go left. Go to step 1. If value is greater than currentValue, go right. Go to step 1. Binary search is intuitively recursive; however, it can be done iteratively by keeping track of the bounds of the search with two pointers. Binary search is efficient for sorted arrays that are stored contiguously (close together) in memory, making O(log n) comparisons, where n is the number of elements in the array. 12345678910111213141516171819202122function binarySearch(items, value)&#123; var startIndex = 0, stopIndex = items.length - 1, middle = Math.floor((stopIndex + startIndex)/2); while(items[middle] != value &amp;&amp; startIndex &lt; stopIndex)&#123; //adjust search area if (value &lt; items[middle])&#123; stopIndex = middle - 1; &#125; else if (value &gt; items[middle])&#123; startIndex = middle + 1; &#125; //recalculate middle middle = Math.floor((stopIndex + startIndex)/2); &#125; //make sure it's the right value return (items[middle] != value) ? -1 : middle;&#125; The fastest method to create unique items in array With primitive values: 1new Set([1, 2, 2, 1, 5]); // [1, 2, 5] With objects: 123456Array.prototype.unique = function() &#123; var o = &#123;&#125;, i, l = this.length, r = []; for(i=0; i&lt;l;i+=1) o[this[i]] = this[i]; for(i in o) r.push(o[i]); return r;&#125;; This is somewhat classified as “Hash Sorting Algorithm” where every item in the array is a hash value and a hash function inserts item into a bucket, replacing existing values in case of hash collision. As such, this can be applied to any programming language for faster sieving of very large arrays. This algorithm has a linear time complexity of O(2n) in worst case scenario. This is way better than what we will observe for the classic method as described below. The classic (worst and most popular) method of finding unique items in an array runs two loops in a nested order to compare each element with rest of the elements. Consequently, the time complexity of the classic method to find the unique items in an array is around quadratic O(n²). 1234567var a = [], l = this.length; for(var i=0; i&lt;l; i++) &#123; for(var j=i+1; j&lt;l; j++) if (this[i] === this[j]) j = ++i; a.push(this[i]); &#125; return a; The fastest method to find items in array Create a classical hash table with complexity of O(n): 1234var result = arr.reduce(function(map, obj) &#123; map[obj.id] = obj; return map;&#125;, &#123;&#125;); And search in the structure is O(1); Big-O Complexity Chart An awesome cheat sheet Save my day: 10 Interview Questions Every JavaScript Developer Should Know","categories":[],"tags":[]},{"title":"call & apply VS bind, the simplest explanation","slug":"call-apply-VS-bind-the-simplest-explanation","date":"2016-08-06T09:03:54.000Z","updated":"2016-09-18T09:55:18.102Z","comments":true,"path":"2016/08/06/call-apply-VS-bind-the-simplest-explanation/","link":"","permalink":"http://qetr1ck-op.github.io/2016/08/06/call-apply-VS-bind-the-simplest-explanation/","excerpt":"Every one know that apply() and call() are similar function, which set this (change context of function). But when should be used the bind() method?","text":"Every one know that apply() and call() are similar function, which set this (change context of function). But when should be used the bind() method? call and apply attach this into function/method and execute it immediately: 123456789const foo = &#123; name: 'Foo', hello(toWhom) &#123; return `Hello from $&#123;this.name&#125; to $&#123;toWhom&#125;`; &#125;&#125;foo.hello('bar'); // \"Hello from Foo to bar\"foo.hello.call(foo, 'world'); // \"Hello from Foo to world\" Function.prototype.bind(), on the other hand, creates a new function with a given this value, and returns that function without executing it. It needes to be invoked separately: 123456789const foo = &#123; name: 'Foo', hello(toWhom) &#123; return `Hello from $&#123;this.name&#125; to $&#123;toWhom&#125;`; &#125;&#125;const newHello = foo.hello.bind(foo);newHello('world'); //\"Hello from Foo to world\" It’s very useful with callbacks: 1234567const bar = &#123; message: 'Hello world' &#125;;function sayMsg() &#123; this.message;&#125;setTimeout(sayMsg.bind(bar)); // \"Hello world\"","categories":[{"name":"Javascript","slug":"Javascript","permalink":"http://qetr1ck-op.github.io/categories/Javascript/"}],"tags":[{"name":"OOP","slug":"OOP","permalink":"http://qetr1ck-op.github.io/tags/OOP/"}]},{"title":"Kangax ES2015 quiz, expained","slug":"Kangax-ES6-quiz-expained","date":"2016-07-26T20:01:02.000Z","updated":"2016-08-13T21:19:36.906Z","comments":true,"path":"2016/07/26/Kangax-ES6-quiz-expained/","link":"","permalink":"http://qetr1ck-op.github.io/2016/07/26/Kangax-ES6-quiz-expained/","excerpt":"@kangax‘ve created a quiz, it’s very interesting, the solution explains a tricky moment of spec.","text":"@kangax‘ve created a quiz, it’s very interesting, the solution explains a tricky moment of spec. Question 1123456(function(x, f = () =&gt; x) &#123; var x; var y = x; x = 2; return [x, y, f()];&#125;)(1); [2, 1, 1] [2, undefined, 1] [2, 1, 2] [2, undefined, 2] As we know, parameters create extra scope in case of using default values. Local variable x shadows the parameter with the same name, var x It’s hoisted and assigned to default value, to undefined? Usually yes, but not in this case. If there is a parameter with the same name, then the local binding is initialize not to undefined but with value of that parameter, that is 1 The variable y gets the the value 1 as well, because var y = x; x is assigned to 2, x = 2; Now it’s tricky f(). It is created in the scope of parameters, so x refers to the parameter x, which is 1. Final values are [2, 1, 1] Question 2123456(function() &#123; return [ ( () =&gt; this.x ).bind(&#123; x: 'inner' &#125;), ( () =&gt; this.x )() ];&#125;)().call(&#123; x: 'outer' &#125;); [‘inner’, ‘outer’] [‘outer’, ‘outer’] [undefined, undefined] Error Arrow function have lexical this value. This means that, it inherits this value from the context they are defined.And later it stays unchangeable, even if explicitly bound or called with different context. In this case both arrow function are created within the context of {x: &#39;outer&#39;}, and bind({x: &#39;inner&#39;}) applied on the first arrow function doesn’t make a difference. Question 31let x, &#123; x: y = 1&#125; = &#123; x &#125;; y; undefined 1 { x: 1} Error let x defines x with value undefined Destructive assignment { x: y = 1} = { x }, on the right side has a short notation for an object literal - { x } which is equalent to { x: x }, that is in our case an object { x: undefined } Once it destucted the pattern{ x: y = 1}, we extract variable y, which correspond to the propery x. Since propery x is undefined, the default value 1 is assigned to it. Question 41234567(function() &#123; let f = this ? class g &#123;&#125; : class h &#123;&#125;; return [ typeof f, typeof h ] &#125;)() [‘function’, undefined] [‘function’, ‘function’] [‘function’, ‘function’] [‘undefined’, ‘undefined’] Error The IIFE is executed with no explicit this value. In ES6 or with use strict directive it means it will be undefined; So variable f is a reference to class h {}. It’s type is a function because essentially classes in ES6 are syntactic sugar on top of contructor function. However, the class h {} is created in expression position, that means h isn’t added to to the environment, and return undefined. Question 51(typeof (new (class &#123; class () &#123;&#125; &#125;))) ‘function’ ‘object’ ‘undefined’ Error This is an obfuscated syntax playing, let’s try to figure it out! The ES6 allow concise method definition, that allows dropping the : function part. So class () {} is a method inside in https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/class#Examples. Now instead of assigning it to variable, we can instantiate it directly: new class { class() { } } The result of default class is always an object. So typeof should return object. Question 61typeof (new (class F extends (String, Array) &#123; &#125;)).substring ‘function’ ‘object’ ‘undefined’ Error Again an obfuscated syntax. The grouping operator always return the last argument, so the result of (String, Array) is actually just Array So we get class F extends Array {} We can image as it’s assigning operation let f = new F Obviously that typeof f.substring is undefined Question 71[...[...'...']].length 1 3 6 Error The spread operator allows to spread all the elements to the array. It works with any iterable object. String are iterable, meaning that we can iterate char by char. So inner [...&#39;...&#39;] results to an array [&#39;.&#39;, &#39;.&#39;, &#39;.&#39;] Array is iterable as well, so outer array spreads into new array. Result of [&#39;.&#39;, &#39;.&#39;, &#39;.&#39;].length is 3 Question 81typeof (function* f() &#123; yield f &#125;)().next().next() Generator object has next method, that returns the next value at the yield position. The returned value has signature: { value: &lt;returned value&gt;, done: boolean} First g.next() has result {value: function f, done: false} The returned value value itself doesn’t have next() method, so trying to chain methods is an error. Question 91typeof (new class f() &#123; [f]() &#123; &#125;, f: &#123; &#125; &#125;)[`$&#123;f&#125;`] ‘function’ ‘undefined’ ‘object’ Error Since the syntax of class isn’t correct class f(), the result is an error. Question 101typeof `$&#123;&#123;Object&#125;&#125;`.prototype “function” “undefined” “object” Error That one is very tricky! We have something that looks a bit strange: it isn’t ${Object} how it “should be”, but the $. It isn’t a special syntax it is still a value {Object} in template string ${}. What is ${Object}? ES6 has short notation for object literal, so in fact it’s just: {Object: Object}, a simple object with the property named &#39;Object&#39;, and the value Object (the built in constructor). So ${ {Object: Object} }, become &#39;[object Object]&#39;. Because the ${x} is roughly equivalent to the x + &#39;&#39; or x.toString() Now the &#39;[object Object]&#39;.prototype is undefined Save my day: DmitrySoshnikov","categories":[{"name":"Javascipt","slug":"Javascipt","permalink":"http://qetr1ck-op.github.io/categories/Javascipt/"},{"name":"ES2015","slug":"Javascipt/ES2015","permalink":"http://qetr1ck-op.github.io/categories/Javascipt/ES2015/"}],"tags":[{"name":"ES2015","slug":"ES2015","permalink":"http://qetr1ck-op.github.io/tags/ES2015/"}]},{"title":"Exploring AngularJS 1.5 .component() method","slug":"Exploring-AngularJS-1-5-component-method","date":"2016-07-22T19:20:03.000Z","updated":"2016-09-18T09:55:49.096Z","comments":true,"path":"2016/07/22/Exploring-AngularJS-1-5-component-method/","link":"","permalink":"http://qetr1ck-op.github.io/2016/07/22/Exploring-AngularJS-1-5-component-method/","excerpt":"AngularJS 1.5 introduce .component() helper method which is much simpler than the .directive() definitions and advocates best practices and common default behavior. Using .component() will allow to write in Angular 2 style as well, which will turn transition to Angular 2 much easier. Let’s compare the difference in syntax and the possibility of new abstraction.","text":"AngularJS 1.5 introduce .component() helper method which is much simpler than the .directive() definitions and advocates best practices and common default behavior. Using .component() will allow to write in Angular 2 style as well, which will turn transition to Angular 2 much easier. Let’s compare the difference in syntax and the possibility of new abstraction. “directrive()” to “component()”The syntax change is simple: 12345// beforemodule.directive(name, fn);// aftermodule.component(name, options); I’ve rebuild a simple counter directive which which we’ll refactor to component(): 123456789101112131415161718192021module .directive('counter', function counter() &#123; return &#123; scope: &#123;&#125;, bindToController: &#123; count: '=' &#125;, contorllerAs: '$ctlr', controller: function() &#123; this.increment = () =&gt; this.count++; this.decrement = () =&gt; this.count--; &#125;, template: ` &lt;div&gt; &lt;input type=\"number\" ng-model=\"$ctlr.count\"&gt; &lt;button ng-click=\"$ctrl.increment()\"&gt;+&lt;/button&gt; &lt;button ng-click=\"$ctrl.decrement()\"&gt;-&lt;/button&gt; &lt;/div&gt; ` &#125; &#125;) Function to ObjectLet’s start from the top and refactor the function argument to object: 12345678910111213// beforemodule .directive('counter', function counter() &#123; return &#123; &#125; &#125;)// aftermodule .component('counter', &#123; &#125;) Nice and simple. “scope” and “bindToController” become “bindings”In directive() the scope property allows us to define whether we want to isolate the $scope or inherit it. So repeating every time just create an extra boilerplate. With bindToController we can explicitly define binding directly to instance of controller via this. With bindings we can remove this boilerplate and simple define what we want to pass down to the component. And component() will always have an isolated scope. 123456789101112131415161718// beforemodule .directive('counter', function counter() &#123; return &#123; scope: &#123; count: '=' &#125;, bindToController: true &#125; &#125;)// aftermodule .component('counter', &#123; binding: &#123; count: '=' &#125; &#125;) Controller and “contorllerAs” changesNothing has changed in the way we declare controller, however it’s now smarter and has a default contorllerAs value of $ctrl. Under the hood it looks like: 12345678910111213// inside angular.jscontrollerAs: identifierForController(options.controller) || options.controllerAs || '$ctrl'//...var CNTRL_REG = /^(\\S+)(\\s+as\\s+(\\w+))?$/;function identifierForController(controller, ident) &#123; if (ident &amp;&amp; isString(ident)) return ident; if (isString(controller)) &#123; var match = CNTRL_REG.exec(controller); if (match) return match[3]; &#125;&#125; This allows us to do the following inside .component(): 1234&#123; ... controller: 'FooController as foo'&#125; Based on the information we refactor our Directive to Component by dropping controllerAs property: 12345678910111213141516171819202122232425// before.directive('counter', function counter() &#123; return &#123; scope: &#123; count: '=' &#125;, bindToController: true, controller: function () &#123; this.increment = () =&gt; this.count++; this.decrement = () =&gt; this.count--; &#125;, controllerAs: 'counter' &#125;;&#125;);// after.component('counter', &#123; bindings: &#123; count: '=' &#125;, controller: function () &#123; this.increment = () =&gt; this.count++; this.decrement = () =&gt; this.count--; &#125;&#125;); Things now are becoming much simpler and funny. TemplateThe template property can be defined as a function property with injected $elem and $attrs values: 1234567891011121314&#123; ... template: function ($element, $attrs) &#123; // access to $element and $attrs return ` &lt;div&gt; &lt;input type=\"text\" ng-model=\"$ctrl.count\"&gt; &lt;button type=\"button\" ng-click=\"$ctrl.decrement();\"&gt;-&lt;/button&gt; &lt;button type=\"button\" ng-click=\"$ctrl.increment();\"&gt;+&lt;/button&gt; &lt;/div&gt; ` &#125; ...&#125; A life demo with new “.component()”: Inheriting behavior with “require”Inherited Directive or Component methods will be bound to this.parent property in the Controller: 12345678910&#123; ... require: &#123; parent: '^^parentComponet' &#125;, controller: function() &#123; // use this object to access to required Object this.parent.foo(); &#125;&#125; One-way bindingA new syntax expression for isolate scope values: 12345678&#123; ... bindings: &#123; oneWay: '&lt;', twoWay: '=' &#125;, ...&#125; But still remember that object are passed by reference, and Angular doesn’t make a clone of the object when it passed via one-way binding, it actually sets the same value, which means that objects have still two-way binding somehow. Upgrading to Angular 2Writing in this style using .component() allows you easily transit to Angular 2, it’d look something like this: 12345678910111213141516171819202122import &#123; Component &#125; from '@angular/core'@Component(&#123; selector: 'counter', template: ` &lt;div&gt; &lt;input type=\"number\" [(ng-model)]=\"count\"&gt; &lt;button (click)=\"increment()\"&gt;+&lt;/button&gt; &lt;button (click)=\"decrement()\"&gt;-&lt;/button&gt; &lt;/div&gt; `,&#125;)export default class CounterComponent &#123; constructor() &#123;&#125; increment() &#123; this.count++; &#125; decrement() &#123; this.count++; &#125;&#125; Save my day: toddmotto","categories":[{"name":"Javascript","slug":"Javascript","permalink":"http://qetr1ck-op.github.io/categories/Javascript/"},{"name":"AngularJS","slug":"Javascript/AngularJS","permalink":"http://qetr1ck-op.github.io/categories/Javascript/AngularJS/"}],"tags":[{"name":"AngularJS","slug":"AngularJS","permalink":"http://qetr1ck-op.github.io/tags/AngularJS/"}]},{"title":"5 principles that will make a more SOLID Javascript Engineer","slug":"5-principles-that-will-make-a-more-SOLID-Javascript-Engineer","date":"2016-07-11T20:13:43.000Z","updated":"2016-09-18T09:59:20.098Z","comments":true,"path":"2016/07/11/5-principles-that-will-make-a-more-SOLID-Javascript-Engineer/","link":"","permalink":"http://qetr1ck-op.github.io/2016/07/11/5-principles-that-will-make-a-more-SOLID-Javascript-Engineer/","excerpt":"Being a SOLID developer in JS isn’t so as straight forward as in other languages. Some developers consider functional approach. Others chose OOP style. Some stand in both line. And other think that having class is wrong and redundant and prefer factories. But still, SOLID principles are the basic pillars of object oriented programming. But what are they?","text":"Being a SOLID developer in JS isn’t so as straight forward as in other languages. Some developers consider functional approach. Others chose OOP style. Some stand in both line. And other think that having class is wrong and redundant and prefer factories. But still, SOLID principles are the basic pillars of object oriented programming. But what are they? The SOLID principles are: S - Single responsibility principle O - Open-Close principle L - Liskov Substitution principle I - Interface segregation principle D - Dependency Inversion principle Single responsibility principleVery similar to Unix slogan: “Do one thing and do it well” This one is easy to comprehend but harder to implement. Every function should do exactly one thing. It should haveone clearly defined goal. So were should we draw a line to decouple on big peace of code. I have 2 basic strategies for dealing with complexity: If you find yourself writing/calling function loginUserAndSaveToken() you’re probably breaking the SRP. Breakthis function into two separate ones. For every function imagine if there are possibility to extract reusable part to not repeat your self. But there is a tricky moment. Using this logic, runFacebook() is indeed a single responsible function. But this only applies as long as the bodyof function runFacebook() is implemented correctly in small divided functions. Open-Close principleIt means that our module should be open to extension, but closed to modification. Meaning is simple, if someone wants to extend your module behavior, they won’t need to modify existing code if theydon’t want to. There is a easy rule to follow here: If you have to open a JS file and need to make a modification there, in order to extend it - you’ve failedOCP 1234567891011121314class IceCreamMachine &#123; constructor() &#123; this.flavors = ['chocolate', 'vanilla']; &#125; create() &#123; if (this.flavors.includes(flavor)) &#123; // warning, ES7 Array.prototype.includes console.log('Great success. You now can eat your ice cream'); &#125; else &#123; console.log('A bad choice, not ice cream today'); &#125; &#125;&#125;export default IceCreamMachine As far as you can see there’s no way to add new ice cream flavor without literally open the module and editIceCreamMachine.flavors array. To follow OCP we can easily change that: 123456789101112131415class IceCreamMachine &#123; constructor() &#123; this.flavors = ['chocolate', 'vanilla']; &#125; create() &#123; if (this.flavors.includes(flavor)) &#123; // warning, ES7 Array.prototype.includes console.log('Great success. You now can eat your ice cream'); &#125; else &#123; console.log('A bad choice, not ice cream today'); &#125; &#125; flavorAdd(flavor) &#123; this.flavors = [...this.flavors, flavor]; &#125;&#125; Liskov Substitution PrincipleThis is one of the most obscure name I’ve ever seen in programming world. And even more the classical description is: Child classes should never break the parent class type definition. What a tough explanation. I’ll make it more simple: It means that we must make sure that new derived classes are extending the base class without changing their behavior. To illustrate we will go with classical example with: 1234567891011121314class Rectangle &#123; constructor() &#123; // init procedure &#125; setWidth(width) &#123; this.width = width; &#125; setHeigth(height) &#123; this.height = height; &#125; getArea() &#123; return this.width * this.height; &#125;&#125; We start with basic geometry abstraction Rectangle. Imagine that is a working and already is deployed to several clients. Now we need a new feature. A possibility to manipulate Square‘s. In real life, in geometry, a square is a form of rectangle. So we could try to implement Square class that extends Rectangle. But is a Square really a Rectangle in programming?.. 1234567891011121314class Square extends Rectangle &#123; constructor() &#123; super(); // init procedure &#125; setWidth(width) &#123; this.width = width; this.height = width; &#125; setHeigth(height) &#123; this.height = height; this.width = height; &#125;&#125; A square is a rectangle with equal width and height, and we do a strange implementation like in example above.We overwrite both setters. So, our Square class isn’t a Rectangle after all. It breaks the law of geometry. It fails the LSP principle. Interface Segregation principleThe SRP is about actors and high lever architecture.The OCP is about design and feature extension.The LSP is about sub-typing and inheritance.And the ISP is about business logic to client communication. Interface Segregation actually means you shouldn’t create bloated interfaces Since JS doesn’t have an interfaces, I’m going to use more abstractive description. So how should we define our interfaces? We could thing about our model and expose all functionality we want it to offer: Let’s say your friend created a brand new HTML5 route library. He convinced you to implement it in your project. You start to play around and register the first route via registerRouter(routeName). And you thing all are set up. But your friend lied. He forgot to mention that you also need to implement onErrorHandler() and handleIE8() for every your registered route. The lesson is whenever you expose a module, make sure only essential are required, everything else is optional. Otherwise your friends will hate you. Dependency Inversion PrincipleYou’ve might heard about dependency inversion as a standalone term. Dependency Injection and Inversion of Control also mean the same. A. High-level modules shouldn’t depend on low-level modules. Both should depend on abstraction.B. Abstraction shouldn’t depend upon details. Details should depend on details. DI is all about handling over control from the function itself to the caller function. In our case it means defining who controls the type of parameters the function receives. Let’s use an example. We’ve started to use an event emitter implementation. Your old functionality looks like this: 123456789function awesomeFoo(dispatcher) &#123; dispatcher.trigger('awesome/foo');&#125;function awesomeFooListener(dispatcher) &#123; dispatcher.on('awesome/foo', event =&gt; &#123; console.log(event) &#125;; &#125; There is one problem. New dispatcher methods are called with emit() and listen(). You could refactor your code. But what if implementation isn’t all that great. You’d like to be able easily switch between implementations You realize that you don’t need the whole dispatcher object in every function. You change your code to receive only the relevant methods for every function: 123456789function awesomeFoo(dispatcher) &#123; dispatch('awesome/foo');&#125;function awesomeFooListener(dispatcher) &#123; listen('awesome/foo', event =&gt; &#123; console.log(event) &#125;; &#125; Your code now doesn’t depend on any concrete implementation of event emitter object. It does depend on abstraction. You can now freely switch between new/old implementation or even use a mock implementation for testing. Save my day: The Full Stack Aspiring Craftsman code.tutsplus","categories":[{"name":"Javascript","slug":"Javascript","permalink":"http://qetr1ck-op.github.io/categories/Javascript/"},{"name":"OOP","slug":"Javascript/OOP","permalink":"http://qetr1ck-op.github.io/categories/Javascript/OOP/"}],"tags":[]},{"title":"How to copy object in Javascript","slug":"How-to-copy-object-in-Javascript","date":"2016-07-08T18:55:05.000Z","updated":"2016-09-18T09:59:46.011Z","comments":true,"path":"2016/07/08/How-to-copy-object-in-Javascript/","link":"","permalink":"http://qetr1ck-op.github.io/2016/07/08/How-to-copy-object-in-Javascript/","excerpt":"There are many ways to copy object in Javascript but most of the time such operation doesn’t do what we expected. Are all properties copied by reference? Are sub-properties merged or replaced? Are accessor, like getter and setters, preserved? And what about Sumbols and other non-enumerable properties?","text":"There are many ways to copy object in Javascript but most of the time such operation doesn’t do what we expected. Are all properties copied by reference? Are sub-properties merged or replaced? Are accessor, like getter and setters, preserved? And what about Sumbols and other non-enumerable properties? Shallow VS Deep copyWhen we copied reference nor a value, we are doing shallow copy. Whenever we do an operation like a.prop = b.prop we are performing a shallow copy, meaning that modifying the object property a.prop it will reflect changes in b.prop too. 1234567891011121314const a = &#123; obj: &#123; test: 'Foo' &#125;&#125;;const b = &#123;&#125;;b.obj = a.obj;//if we modify itb.obj.test = 'Bar';//it will be reflected in a a.obj.test; In order to perform deep copy of a.prop: 123456789101112const a = &#123; obj: &#123; test: 'Foo' &#125;&#125;;const b = &#123;&#125;;b.obj = &#123;&#125;;//not reflected in ab.obj.test = 'Bar';a.obj.test; Object.assign(target, [, sourceN])Object.assign performs a shallow copy it merges enumerable properties with priority right to left: 1234567891011121314151617181920212223242526const a = &#123; obj: &#123; foo: true &#125;, bar: 2&#125;;const b = &#123; obj: &#123; foz: true &#125;, baz: 3&#125;;//shallow mergeconst c = Object.assign(&#123;&#125;, a, b);//which 'obj' property was copied?//the priority is right to leftc.obj === b.obj; //truec.obj === a.obj; //falsec.bar; // 2c.baz; // 3//change will reflect by referencec.obj.foz = false;b.obj.foz; // false Object.assign side effectsThere are at least two main subtle problems most developers are not aware of: all accessors, those properties with getter or setter, will be copied as a simple data, invoking the getterduring the copy all Symbol keys will be copied too, making Symbol less private or protected than we thing 1234567891011121314151617const uid = Symbol('uid');const special = &#123; get next() &#123; return ++this.counter; &#125;, counter: 0&#125;;special[uid] = Math.random;//what could be possible wrong here?!const notSpecial = Object.assign(&#123;&#125;, special);// if 'next' is declared (and copied) before 'counter'notSpecial.counter; // 1notSpecial.next; // 1 in any casenotSpecial[uid] === special[uid]; // same as special[uid] If you want a advice - use Object.assign for simple shallow copy or merge with data that you are suredoesn’t contain accessors. Use one of the simple npm package or lodash/underscore/rambdaclone is one a popular package for deep copying: 12345678const clone = require('clone'); let a, b; a = &#123; foo: &#123; bar: 'baz' &#125; &#125;; // initial value of a b = clone(a); // clone a -&gt; b a.foo.bar = 'foo'; // changes not modify 'b' Achieve the same result with _.deepCopy: 12345const objects = [&#123; 'a': 1 &#125;, &#123; 'b': 2 &#125;];const deep = _.cloneDeep(objects);console.log(deep[0] === objects[0]);// → false JSON.parse(JSON.stringify(object))If you don’t have function within your object, a very simple: 1const cloneOfA = JSON.parse(JSON.stringify(a)); This works with for all kinds of objects contain: object, array, string, boolean, numbers; Save my day: www.webreflection.co.uk stackoverflow.com","categories":[{"name":"Javascript","slug":"Javascript","permalink":"http://qetr1ck-op.github.io/categories/Javascript/"}],"tags":[]},{"title":"Development with Webpack and React part 5","slug":"Development-with-Webpack-and-React-part-5","date":"2016-02-21T10:02:24.000Z","updated":"2016-09-18T10:00:13.690Z","comments":true,"path":"2016/02/21/Development-with-Webpack-and-React-part-5/","link":"","permalink":"http://qetr1ck-op.github.io/2016/02/21/Development-with-Webpack-and-React-part-5/","excerpt":"We still have work to do to turn this into a real Kanban as pictured above. Most importantly our system is missing the concept of Lane.","text":"We still have work to do to turn this into a real Kanban as pictured above. Most importantly our system is missing the concept of Lane. A Lane is something that should be able to contain many Notes within itself and track their order. Extracting LanesThere will be a component for the higher level (i.e., Lanes) and for the lower level (i.e., Lane). The higher level component will deal with lane ordering. A Lane will render itself (i.e., name and Notes) and have basic manipulation operations. Just as with Notes, we are going to need a set of actions: app/actions/LaneActions.js123import alt from '../libs/alt';export default alt.generateActions('create'); In addition, we are going to need a LaneStore and a method matching to create: app/stores/LaneStore.js1234567891011121314151617181920212223import uuid from 'node-uuid';import alt from '../libs/alt';import LaneActions from '../actions/LaneActions';class LaneStore &#123; constructor() &#123; this.bindActions(LaneActions); this.lanes = []; &#125; create(lane) &#123; const lanes = this.lanes; lane.id = uuid.v4(); lane.notes = lane.notes || []; this.setState(&#123; lanes: lanes.concat(lane) &#125;); &#125;&#125;export default alt.createStore(LaneStore, 'LaneStore'); We are also going to need a stub for Lanes: 12345678910111213//app/components/Lanes.jsximport React from 'react';export default class Lanes extends React.Component &#123; render() &#123; return ( &lt;div className=\"lanes\"&gt; lanes should go here &lt;/div&gt; ); &#125;&#125; Next, we need to make room for Lanes at App. We will simply replace Notes references with Lanes, set up actions, and store as needed: 123456789101112131415161718192021222324252627282930313233//app/components/App.jsximport AltContainer from 'alt-container';import React from 'react';import Lanes from './Lanes.jsx';import LaneActions from '../actions/LaneActions';import LaneStore from '../stores/LaneStore';export default class App extends React.Component &#123; render() &#123; return ( &lt;div&gt; &lt;AltContainer stores=&#123;[LaneStore]&#125; inject=&#123;&#123; lanes: () =&gt; LaneStore.getState().lanes || [] &#125;&#125; &gt; &lt;Lanes /&gt; &lt;/AltContainer&gt; &lt;/div&gt; ); &#125; addLane() &#123; LaneActions.create(&#123;name: 'New lane'&#125;); &#125;&#125; It just shows a plus button and lanes should go here text. Even the add button doesn’t work yet. We still need to model Lane and attach Notes to that to make this all work. Modeling LaneThe Lanes container will render each Lane separately. Each Lane in turn will then render associated Notes, just like our App did earlier. 123456789101112//app/components/Lanes.jsximport React from 'react';import Lane from './Lane.jsx';export default class (&#123;lanes&#125;) =&gt; &#123; return ( &lt;div className=\"lanes\"&gt;&#123;lanes.map(lane =&gt; &lt;Lane className=\"lane\" key=&#123;lane.id&#125; lane=&#123;lane&#125; /&gt; )&#125;&lt;/div&gt; );&#125; We are also going to need a Lane component to make this work. It will render the Lane name and associated Notes: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546//app/components/Lane.jsximport AltContainer from 'alt-container';import React from 'react';import Notes from './Notes.jsx';import NoteActions from '../actions/NoteActions';import NoteStore from '../stores/NoteStore';export default class Lane extends React.Component &#123; render() &#123; const &#123;lane, ...props&#125; = this.props; return ( &lt;div &#123;...props&#125;&gt; &lt;div className=\"lane-header\"&gt; &lt;div className=\"lane-add-note\"&gt; &lt;button onClick=&#123;this.addNote&#125;&gt;+&lt;/button&gt; &lt;/div&gt; &lt;div className=\"lane-name\"&gt;&#123;lane.name&#125;&lt;/div&gt; &lt;/div&gt; &lt;AltContainer stores=&#123;[NoteStore]&#125; inject=&#123;&#123; notes: () =&gt; NoteStore.getState().notes || [] &#125;&#125; &gt; &lt;Notes onEdit=&#123;this.editNote&#125; onDelete=&#123;this.deleteNote&#125; /&gt; &lt;/AltContainer&gt; &lt;/div&gt; ); &#125; editNote(id, task) &#123; // Don't modify if trying set an empty value if(!task.trim()) &#123; return; &#125; NoteActions.update(&#123;id, task&#125;); &#125; addNote() &#123; NoteActions.create(&#123;task: 'New task'&#125;); &#125; deleteNote(id) &#123; NoteActions.delete(id); &#125;&#125; const {a, b, ...props} = this.props in the example. This allows us to attach a className to Lane and we avoid polluting it with HTML attributes we don’t need. The syntax expands Object key value pairs as props so we don’t have to write each prop we want separately. If you run the application and try adding new notes, you can see there’s something wrong. Every note you add is shared by all lanes. If a note is modified, other lanes update too. The reason why this happens is simple. Our NoteStore is a singleton. This means every component that is listening to NoteStore will receive the same data. We will need to resolve this problem somehow. Making Lanes Responsible of NotesCurrently, our Lane contains just an array of objects. Each of the objects knows its id and name. We’ll need something more. In order to make this work, each Lane needs to know which Notes belong to it. If a Lane contained an array of Note ids, it could then filter and display the Notes belonging to it. We’ll implement a scheme to achieve this next. Setting Up attachToLaneWhen we add a new Note to the system using addNote, we need to make sure it’s associated to some Lane. This association can be modeled using a method, such as LaneActions.attachToLane({laneId: &lt;id&gt;, noteId: &lt;id&gt;}). Before calling this method we should create a note and gets its id. To get started we should add attachToLane to actions as before: 12345//app/actions/LaneActions.jsimport alt from '../libs/alt';export default alt.generateActions('create', 'attachToLane'); In order to implement attachToLane, we need to find a lane matching to the given lane id and then attach note id to it: 1234567891011121314151617181920212223242526272829//app/stores/LaneStore.jsimport uuid from 'node-uuid';import alt from '../libs/alt';import LaneActions from '../actions/LaneActions';class LaneStore &#123; ... attachToLane(&#123;laneId, noteId&#125;) &#123; const lanes = this.lanes.map(lane =&gt; &#123; if(lane.id === laneId) &#123; if(lane.notes.includes(noteId)) &#123; console.warn('Already attached note to lane', lanes); &#125; else &#123; lane.notes.push(noteId); &#125; &#125; return lane; &#125;); this.setState(&#123;lanes&#125;); &#125;&#125;export default alt.createStore(LaneStore, 'LaneStore'); We also need to make sure NoteActions.create returns a note so the setup works just like in the code example above. The note is needed for creating an association between a lane and a note: 123456789101112131415161718192021222324//app/stores/NoteStore.js...class NoteStore &#123; constructor() &#123; this.bindActions(NoteActions); this.notes = []; &#125; create(note) &#123; const notes = this.notes; note.id = uuid.v4(); this.setState(&#123; notes: notes.concat(note) &#125;); return note; &#125; ...&#125;... Setting Up detachFromLanedeleteNote is the opposite operation of addNote. Again, we should set up an action: 12345//app/actions/LaneActions.jsimport alt from './libs/alt';export default alt.generateActions('create', 'attachToLane', 'detachFromLane'); The implementation will resemble attachToLane. In this case, we’ll remove the possibly found Note instead: 1234567891011121314151617181920212223242526//app/stores/LaneStore.jsimport uuid from 'node-uuid';import alt from '../libs/alt';import LaneAction from '../libs/action/LaneActions';class LaneStore &#123; ... attachToLane(&#123;laneId, noteId&#125;) &#123; ... &#125; detachFromLane(&#123;laneId, noteId&#125;) &#123; const lanes = this.lanes.map( lane =&gt; &#123; if (lane.id === laneId) &#123; lane.notes = lane.notes.filter( note =&gt; note.id !=== noteId ); &#125; return lanes; &#125;); this.setState(&#123;lanes&#125;); &#125;&#125;export default alt.createStore(LaneStore, 'LaneStore'); Just building an association between a lane and a note isn’t enough. We are going to need some way to resolve the note references to data we can display through the user interface. For this purpose, we need to implement a special getter so we get just the data we want per each lane. Implementing a Getter for NoteStoreOne neat way to resolve lane notes to actual data is to implement a public method NoteStore.getNotesByIds(notes). It accepts an array of Note ids, and returns the corresponding objects. Just implementing the method isn’t enough. We also need to make it public. In Alt, this can be achieved using this.exportPublicMethods: 12345678910111213141516171819202122232425262728293031323334//app/sotes/NoteStore.jsximport uuid from 'node-uuid';import alt from '../libs/alt';import NoteActions from '../actions/NoteActions';class NoteStore &#123; constructor() &#123; this.bindActions(NoteActions); this.notes = []; this.exportPublicMethods(&#123; getNotesById: this.getNotesById.bind(this) &#125;) &#125; ... getNoteByIds(ids) &#123; // 1. Make sure we are operating on an array and // map over the ids // [id, id, id, ...] -&gt; [[Note], [], [Note], ...] return (ids || []).map( // 2. Extract matching notes // [Note, Note, Note] -&gt; [Note, ...] (match) or [] (no match) id =&gt; this.notes.filter( note.id === id ) ) // 3. Filter out possible empty arrays and get notes // [[Note], [], [Note]] -&gt; [[Note], [Note]] -&gt; [Note, Note] .filter( ary =&gt; ary.length ) .map( ary =&gt; ary[0] ); &#125;&#125;export defalt alt.createStore(NoteStore, 'NoteStore'); Note that the implementation filters possible non-matching ids from the result. Connecting Lane with the LogicNow that we have the logical bits together, we can integrate it with Lane. We’ll need to take the newly added props (id, notes) into account, and glue this all together: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950//app/components/Lane.jsx...import LaneActions from './app/actions/LaneActions';export default class Lane extends React.Component &#123; render() &#123; const &#123;lane, ...props&#125; = this.props; return ( &lt;div &#123;...props&#125;&gt; &lt;div className=\"lane-header\"&gt; &lt;div className=\"lane-add-note\"&gt; &lt;button onClick=&#123;this.addNote&#125;&gt;+&lt;/button&gt; &lt;/div&gt; &lt;div className=\"lane-name\"&gt;&#123;lane.name&#125;&lt;/div&gt; &lt;/div&gt; &lt;AltContainer stores=&#123;[NoteStore]&#125; inject=&#123;&#123; notes: () =&gt; NoteStore.getNotesById(lane.notes) &#125;&#125; &gt; &lt;Notes onEdit=&#123;this.onEdit&#125; onDelete=&#123;this.onDelete&#125; /&gt; &lt;/AltContainer&gt; &lt;/div&gt; ); &#125; editNote(id, task) &#123; // Don't modify if trying set an empty value if(!task.trim()) &#123; return; &#125; NoteActions.update(&#123;id, task&#125;); &#125; addNote = (e) =&gt; &#123; const laneId = this.props.lane.id; const noteId = NoteAction.create( &#123;task: 'New Task'&#125; ).id; LaneAction.attachToLane(&#123; noteId, laneId &#125;); &#125; addNote = (noteId, e) =&gt; &#123; const laneId = this.props.lane.id; NoteAction.delete(noteId); LaneAction.detachFronLane(&#123; noteId, laneId &#125;); e.stopPropagation(); &#125;&#125; There are three important changes: Methods where we need to refer to this have been bound using a property initializer. An alternative way to achieve this would have been to bind at render or at constructor. notes: () =&gt; NoteStore.getNotesByIds(notes) - Our new getter is used to filter notes. addNote, deleteNote - These operate now based on the new logic we specified. Note that we trigger detachFromLane before delete at deleteNote. Otherwise we may try to render non-existent notes. You can try swapping the order to see warnings. The current structure allows us to keep singleton stores and a flat data structure. Dealing with references is a little awkward, but that’s consistent with the Flux architecture. If you try to add notes to a specific lane, they shouldn’t be duplicated anymore. Also editing a note should behave as you might expect: On Data Dependencies and waitForThe current setup works because our actions are synchronous. It would become more problematic if we dealt with a back-end. In that case, we would have to set up waitFor based code. waitFor allows us to deal with data dependencies. It tells the dispatcher that it should wait before going on: 1234567891011121314//app/stores/LaneStore.jsclass LaneStore &#123; ... attachToLane( &#123;laneId, noteId&#125; ) &#123; if(!noteId) &#123; this.waitFor(NoteStore); // last note -&gt; id noteId = NoteStore.getState().notes.slice(-1)[0].id; &#125; ... &#125;&#125; It becomes necessary when you need to deal with asynchronously fetched data that depends on each other, however. Implementing Edit/Remove for LaneWe are still missing some basic functionality, such as editing and removing lanes. For now, we just want to get Editable into a good condition: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960//app/component/Editable.jsximport React from 'react';export default class Editable extends React.Component&#123; render() &#123; const &#123; value, onEdit, onDelete, onValueClick, editing, ...props &#125; = this.props; return ( &lt;div ...props&gt; &#123;editing ? this.renderEdit() : this.renderValue()&#125; &lt;/div&gt; ) &#125; renderEdit = () =&gt; &#123; return ( &lt;input type=\"text\" ref=&#123; (e) =&gt; e ? e.selectionStart = this.props.value.length : null &#125; autoFocus=&#123;true&#125; defaultValue=&#123;this.props.value&#125; onBlur=&#123;this.finishEdit&#125; onKeyPress=&#123;this.checkEnter&#125; /&gt; ) &#125;; renderValue = () =&gt; &#123; const onDelete = this.props.onDelete; return ( &lt;div onClick=&#123;this.props.onValueClick&#125;&gt; &lt;span className=\"value\"&gt;&#123;this.props.value&#125;&lt;/span&gt; &#123;onDelete ? this.renderDelete() : null &#125; &lt;/div&gt; ) &#125;; renderDelete = () =&gt; &#123; return ( &lt;button className=\"onDelete\" onClick=&#123;this.props.onDelete&#125; &gt;x &lt;/button&gt; ) &#125;; checkEnter = (e) =&gt; &#123; if(e.key === 'Enter') &#123; this.finishEdit() &#125; &#125;; finishEdit = (e) =&gt; &#123; this.props.onClick(e.target.value); &#125;;&#125; Editable uses uncontrolled design with its input. This means we pass the control over its state to DOM and capture it through event handlers. If you wanted to validate the input when the user is typing, it would be useful to convert it into a controlled design. In this case you would define a onChange handler and a value prop. It’s more work, but also provides more control. React documentation discusses controlled components in greater detail. Pointing Notes to EditableNext, we need to make Notes.jsx point at the new component. We’ll need to alter the import and the component name at render(): 12345678910111213141516171819//app/components/Notes.jsximport React from 'react';import Editable from './Editable.jsx';export default (&#123;notes, onValueClick, onEdit, onDelete&#125;) =&gt; &#123; return ( &lt;ul className=\"notes\"&gt;&#123;notes.map(note =&gt; &lt;li className=\"note\" key=&#123;note.id&#125;&gt; &lt;Editable editing=&#123;note.editing&#125; value=&#123;note.task&#125; onValueClick=&#123;onValueClick.bind(null, note.id)&#125; onEdit=&#123;onEdit.bind(null, note.id)&#125; onDelete=&#123;onDelete.bind(null, note.id)&#125; /&gt; &lt;/li&gt; )&#125;&lt;/ul&gt; );&#125; Connecting Lane with EditableNext, we can use this generic component to allow a Lane’s name to be modified: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778//app/components/Lane.jsximport Editable from './Editable.jsx';export default class Lane extends React.Component &#123; render() &#123; const &#123;lane, ...props&#125; = this.props; return ( &lt;div &#123;...props&#125;&gt; &lt;div className=\"lane-header\" onClick=&#123;this.activateLaneEdit&#125;&gt; &lt;div className=\"lane-add-note\"&gt; &lt;button onClick=&#123;this.addNote&#125;&gt;+&lt;/button&gt; &lt;/div&gt; &lt;Editable className=\"lane-name\" editing=&#123;lane.editing&#125; value=&#123;lane.name&#125; onEdit=&#123;this.editName&#125; /&gt; &lt;div className=\"lane-delete\"&gt; &lt;button onClick=&#123;this.deleteLane&#125;&gt;x&lt;/button&gt; &lt;/div&gt; &lt;/div&gt; &lt;AltContainer stores=&#123;[NoteStore]&#125; inject=&#123;&#123; notes: () =&gt; NoteStore.getNotesByIds(lane.notes) &#125;&#125; &gt; &lt;Notes onValueClick=&#123;this.activateNoteEdit&#125; onEdit=&#123;this.editNote&#125; onDelete=&#123;this.deleteNote&#125; /&gt; &lt;/AltContainer&gt; &lt;/div&gt; ) &#125; editNote(id, task) &#123; // Don't modify if trying set an empty value if(!task.trim()) &#123; return; &#125; NoteActions.update(&#123;id, task&#125;); &#125; addNote = (e) =&gt; &#123; // If note is added, avoid opening lane name edit by stopping // event bubbling in this case. e.stopPropagation(); const laneId = this.props.lane.id; const note = NoteActions.create(&#123;task: 'New task'&#125;); LaneActions.attachToLane(&#123; noteId: note.id, laneId &#125;); &#125;; ... editName = (name) =&gt; &#123; const laneId = this.props.lane.id; console.log(`edit lane $&#123;laneId&#125; name using $&#123;name&#125;`); &#125;; deleteLane = () =&gt; &#123; const laneId = this.props.lane.id; console.log(`delete lane $&#123;laneId&#125;`); &#125;; activateLaneEdit = () =&gt; &#123; const laneId = this.props.lane.id; console.log(`activate lane $&#123;laneId&#125; edit`); &#125;; activateNoteEdit(id) &#123; console.log(`activate note $&#123;id&#125; edit`); &#125;&#125; Defining Editable LogicWe will need to define some logic to make this work. To follow the same idea as with Note, we can model the remaining CRUD actions here. We’ll need to set up update and delete actions in particular. 12345678// app/actions/LaneActions.jsimport alt from '../libs/alt';export default alt.generateActions( 'create', 'update', 'delete', 'attachToLane', 'detachFromLane'); We are also going to need LaneStore level implementations for these. They can be modeled based on what we have seen in NoteStore earlier: 12345678910111213141516171819202122232425262728293031323334// app/stores/LaneStore.js...class LaneStore &#123; ... create(lane) &#123; ... &#125; update(updatedLane) &#123; const lanes = this.lanes.map(lane =&gt; &#123; if(lane.id === updatedLane.id) &#123; return Object.assign(&#123;&#125;, lane, updatedLane); &#125; return lane; &#125;); this.setState(&#123;lanes&#125;); &#125; delete(id) &#123; this.setState(&#123; lanes: this.lanes.filter(lane =&gt; lane.id !== id) &#125;); &#125; attachToLane(&#123;laneId, noteId&#125;) &#123; ... &#125; ...&#125;export default alt.createStore(LaneStore, 'LaneStore'); Now that we have resolved actions and store, we need to adjust our component to take these changes into account: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546// app/component/Lane.jsx...export default class Lane extends React.Component &#123; ... editNote(id, task) &#123; // Don't modify if trying set an empty value if(!task.trim()) &#123; NoteActions.update(&#123;id, editing: false&#125;); return; &#125; NoteActions.update(&#123;id, task, editing: false&#125;); &#125; ... editName = (name) =&gt; &#123; const laneId = this.props.lane.id; // Don't modify if trying set an empty value if(!name.trim()) &#123; LaneActions.update(&#123;id: laneId, editing: false&#125;); return; &#125; LaneActions.update(&#123;id: laneId, name, editing: false&#125;); &#125;; deleteLane = () =&gt; &#123; const laneId = this.props.lane.id; LaneActions.delete(laneId); &#125;; activateLaneEdit = () =&gt; &#123; const laneId = this.props.lane.id; LaneActions.update(&#123;id: laneId, editing: true&#125;); &#125;; activateNoteEdit(id) &#123; NoteActions.update(&#123;id, editing: true&#125;); &#125;&#125; If you want that lanes and notes are editable after they are created, set lane.editing = true; or note.editing = true; when creating them. Styling Kanban BoardAs we added Lanes to the application, the styling went a bit off. Add the following styling to make it a little nicer: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273//app/main.cssbody &#123; background: cornsilk; font-family: sans-serif;&#125;.lane &#123; display: inline-block; margin: 1em; background-color: #efefef; border: 1px solid #ccc; border-radius: 0.5em; min-width: 10em; vertical-align: top;&#125;.lane-header &#123; overflow: auto; padding: 1em; color: #efefef; background-color: #333; border-top-left-radius: 0.5em; border-top-right-radius: 0.5em;&#125;.lane-name &#123; float: left;&#125;.lane-add-note &#123; float: left; margin-right: 0.5em;&#125;.lane-delete &#123; float: right; margin-left: 0.5em; visibility: hidden;&#125;.lane-header:hover .lane-delete &#123; visibility: visible;&#125;.add-lane, .lane-add-note button &#123; cursor: pointer; background-color: #fdfdfd; border: 1px solid #ccc;&#125;.lane-delete button &#123; padding: 0; cursor: pointer; color: white; background-color: rgba(0, 0, 0, 0); border: 0;&#125;... As this is a small project, we can leave the CSS in a single file like this. In case it starts growing, consider separating it to multiple files. One way to do this is to extract CSS per component and then refer to it there (e.g., require(&#39;./lane.css&#39;) at Lane.jsx). Besides keeping things nice and tidy, Webpack’s lazy loading machinery can pick this up. As a result, the initial CSS your user has to load will be smaller. On Namespacing ComponentsTODO","categories":[{"name":"Javascript","slug":"Javascript","permalink":"http://qetr1ck-op.github.io/categories/Javascript/"}],"tags":[{"name":"Webpack","slug":"Webpack","permalink":"http://qetr1ck-op.github.io/tags/Webpack/"},{"name":"Babel","slug":"Babel","permalink":"http://qetr1ck-op.github.io/tags/Babel/"},{"name":"ES6","slug":"ES6","permalink":"http://qetr1ck-op.github.io/tags/ES6/"},{"name":"React","slug":"React","permalink":"http://qetr1ck-op.github.io/tags/React/"},{"name":"Alt","slug":"Alt","permalink":"http://qetr1ck-op.github.io/tags/Alt/"}]},{"title":"Kata: Format a string of names like 'Bart, Lisa & Maggie'","slug":"Kata-String-Format-a-string-of-names-like-Bart-Lisa-Maggie","date":"2016-02-18T22:05:14.000Z","updated":"2016-07-08T18:16:00.988Z","comments":true,"path":"2016/02/19/Kata-String-Format-a-string-of-names-like-Bart-Lisa-Maggie/","link":"","permalink":"http://qetr1ck-op.github.io/2016/02/19/Kata-String-Format-a-string-of-names-like-Bart-Lisa-Maggie/","excerpt":"Given: an array containing hashes of names Return: a string formatted as a list of names separated by commas except for the last two names, which should be separated by an ampersand.","text":"Given: an array containing hashes of names Return: a string formatted as a list of names separated by commas except for the last two names, which should be separated by an ampersand. exapmle.js1234567891011list([ &#123;name: 'Bart'&#125;, &#123;name: 'Lisa'&#125;, &#123;name: 'Maggie'&#125; ])// returns 'Bart, Lisa &amp; Maggie'list([ &#123;name: 'Bart'&#125;, &#123;name: 'Lisa'&#125; ])// returns 'Bart &amp; Lisa'list([ &#123;name: 'Bart'&#125; ])// returns 'Bart'list([])// returns '' Tests: list.spec.js12345678Test.assertEquals(list([&#123;name: 'Bart'&#125;,&#123;name: 'Lisa'&#125;,&#123;name: 'Maggie'&#125;,&#123;name: 'Homer'&#125;,&#123;name: 'Marge'&#125;]), 'Bart, Lisa, Maggie, Homer &amp; Marge',\"Must work with many names\")Test.assertEquals(list([&#123;name: 'Bart'&#125;,&#123;name: 'Lisa'&#125;,&#123;name: 'Maggie'&#125;]), 'Bart, Lisa &amp; Maggie',\"Must work with many names\")Test.assertEquals(list([&#123;name: 'Bart'&#125;,&#123;name: 'Lisa'&#125;]), 'Bart &amp; Lisa', \"Must work with two names\")Test.assertEquals(list([&#123;name: 'Bart'&#125;]), 'Bart', \"Wrong output for a single name\")Test.assertEquals(list([]), '', \"Must work with no names\") Result: list.js12345678910111213const list = names =&gt; &#123; return names.reduce( (prev, current, index, array) =&gt; &#123; if (index === 0)&#123; return current.name; &#125; else if (index === array.length - 1)&#123; return `$&#123;prev&#125; &amp; $&#123;current.name&#125;`; &#125; else &#123; return `$&#123;prev&#125;, $&#123;current.name&#125;`; &#125; &#125;, ''); &#125;","categories":[{"name":"Javascript","slug":"Javascript","permalink":"http://qetr1ck-op.github.io/categories/Javascript/"},{"name":"Kata","slug":"Javascript/Kata","permalink":"http://qetr1ck-op.github.io/categories/Javascript/Kata/"}],"tags":[{"name":"Kata","slug":"Kata","permalink":"http://qetr1ck-op.github.io/tags/Kata/"}]},{"title":"Kata: Filter through name/email","slug":"Kata-Array-RegExp-Filter-through-name-email","date":"2016-02-15T20:34:45.000Z","updated":"2016-07-08T18:16:37.774Z","comments":true,"path":"2016/02/15/Kata-Array-RegExp-Filter-through-name-email/","link":"","permalink":"http://qetr1ck-op.github.io/2016/02/15/Kata-Array-RegExp-Filter-through-name-email/","excerpt":"He has troubles with users ending or starting in a ., and his user-array is a flat array of user-email-pairs, like so:","text":"He has troubles with users ending or starting in a ., and his user-array is a flat array of user-email-pairs, like so: 1[ \"foo\", \"foo@bar.com\", \"bar\", \"bar@foo.com\", \".foo\", \"food@bar.com\" ] He is only interested in e-mailing the users and ask them to sign up again, so no need to keep the user-name, only e-mail addresses for the user-names that start or end with a . should be returned. For the above array, the correct return-array would be 1[ \"food@bar.com\" ] Test:12345678describe( \"Testing a list\", function()&#123; it( \"Basic list\", function()&#123; var a = [ \"foo\", \"foo@foo.com\", \"bar.\", \"bar@bar.com\" ], b = [ \"bar@bar.com\" ]; Test.assertSimilar( searchNames( a ), b, \"not correct \" + Test.inspect(a) + \" given\" ); &#125; );&#125; ); Result:12345const searchNames = logins =&gt; &#123; return logins.filter( ( login, i, ary) =&gt; i % 2 === 1 &amp;&amp; ary[i - 1].match(/^\\.|\\.$/); )&#125;;","categories":[{"name":"Javascript","slug":"Javascript","permalink":"http://qetr1ck-op.github.io/categories/Javascript/"},{"name":"Kata","slug":"Javascript/Kata","permalink":"http://qetr1ck-op.github.io/categories/Javascript/Kata/"}],"tags":[{"name":"Kata","slug":"Kata","permalink":"http://qetr1ck-op.github.io/tags/Kata/"},{"name":"Arrays","slug":"Arrays","permalink":"http://qetr1ck-op.github.io/tags/Arrays/"},{"name":"RegExp","slug":"RegExp","permalink":"http://qetr1ck-op.github.io/tags/RegExp/"}]},{"title":"Misconceptions About Inheritance in JavaScript","slug":"Misconceptions-About-Inheritance-in-JavaScript","date":"2016-02-14T20:54:55.000Z","updated":"2016-06-28T07:50:41.752Z","comments":true,"path":"2016/02/14/Misconceptions-About-Inheritance-in-JavaScript/","link":"","permalink":"http://qetr1ck-op.github.io/2016/02/14/Misconceptions-About-Inheritance-in-JavaScript/","excerpt":"What’s the Difference Between Class &amp; Prototypal Inheritance? This can be a tricky question, and you’ll probably need to defend your answer with follow-up Q&amp;A, so pay special attention to learning the differences, and how to apply the knowledge to write better code.","text":"What’s the Difference Between Class &amp; Prototypal Inheritance? This can be a tricky question, and you’ll probably need to defend your answer with follow-up Q&amp;A, so pay special attention to learning the differences, and how to apply the knowledge to write better code. Aren’t classical and prototypal inheritance really the same thing, just a stylistic preference?No. Classical and prototypal inheritance are fundamentally and semantically distinct. In class inheritance, instances inherit from a blueprint (the class), and create sub-class relationships. In other words, you can’t use the class like you would use an instance. You can’t invoke instance methods on a class definition itself. You must first create an instance and then invoke methods on that instance. In prototypal inheritance, instances inherit from other instances. Using delegate prototypes (setting the prototype of one instance to refer to an examplar object), it’s literally Objects Linking to Other Objects, or OLOO. Using concatenative inheritance, you just copy properties from an exemplar object to a new instance. Aren’t classes the right way to create objects in JavaScript?No. There are several right ways to create objects in JavaScript. The first and most common is an object literal: 123456789let mouse = &#123; furColor: 'brown', legs: 4, tail: 'long, skinny', describe () &#123; return `A mouse with $&#123;this.furColor&#125; fur, $&#123;this.legs&#125; legs, and a $&#123;this.tail&#125; tail.`; &#125;&#125;; You can attach delegate prototypes with Object.create(): 12345678910111213141516let animal = &#123; animalType: 'animal', describe () &#123; return `An $&#123;this.animalType&#125;, with $&#123;this.furColor&#125; fur, $&#123;this.legs&#125; legs, and a $&#123;this.tail&#125; tail.`; &#125;&#125;;let mouse = Object.assign(Object.create(animal), &#123; animalType: 'mouse', furColor: 'brown', legs: 4, tail: 'long, skinny'&#125;); Let’s break this one down a little: animal is a delegate prototype. mouse is an instance. When you try to access a property on mouse that isn’t there, the JavaScript runtime will look for the property on animal (the delegate). I’m skipping the constructor function example because I can’t recommend them. Don’t you need a constructor function to specify object instantiation behavior and handle object initialization?No. Any function can create and return objects. When it’s not a constructor function, it’s called a factory function. Factory function: 12345678910111213141516171819let animal = &#123; animalType: 'animal', describe () &#123; return `An $&#123;this.animalType&#125; with $&#123;this.furColor&#125; fur, $&#123;this.legs&#125; legs, and a $&#123;this.tail&#125; tail.`; &#125;&#125;; let mouseFactory = function mouseFactory () &#123; return Object.assign(Object.create(animal), &#123; animalType: 'mouse', furColor: 'brown', legs: 4, tail: 'long, skinny' &#125;);&#125;;let mickey = mouseFactory(); Don’t you need constructor functions for privacy in JavaScript?No. In JavaScript, any time you export a function, that function has access to the outer function’s variables. When you use them, the JS engine creates a closure. Closures are not unique to constructor functions. Any function can create a closure for data privacy: 123456789101112131415161718192021222324let animal = &#123; animalType: 'animal', describe () &#123; return `An $&#123;this.animalType&#125; with $&#123;this.furColor&#125; fur, $&#123;this.legs&#125; legs, and a $&#123;this.tail&#125; tail.`; &#125;&#125;; let mouseFactory = function mouseFactory () &#123; let secret = 'secret agent'; return Object.assign(Object.create(animal), &#123; animalType: 'mouse', furColor: 'brown', legs: 4, tail: 'long, skinny', profession () &#123; return secret; &#125; &#125;);&#125;; let james = mouseFactory(); Does new mean that code is using classical inheritance?No. The new keyword is used to invoke a constructor. What it actually does is: Create a new instance Bind this to the new instance Reference the new object’s delegate [[Prototype]] to the object referenced by the constructor function’s prototype property. Names the object type after the constructor, which you’ll notice mostly in the debugging console. You’ll see [Object Foo], for example, instead of [Object object]. Allows instanceof to check whether or not an object’s prototype reference is the same object referenced by the .prototype property of the constructor. Is There a Big Performance Difference Between Classical and Prototypal Inheritance?No. Can you tell the difference between .0000000001 seconds and .000000001 seconds? Neither can I, but I sure can tell the difference between loading 10 small icons or loading one web font, instead! The Native APIs use Constructors. Aren’t they More Idiomatic than Factories?Factories are extremely common in JavaScript. For instance, the most popular JavaScript library of all time, jQuery exposes a factory to users. What else exposes factories? React React.createClass() is a factory. Angular uses classes &amp; factories, but wraps them all with a factory in the Dependency Injection container. All providers are sugar that use the .provider() factory. There’s even a .factory() provider, and even the .service() provider wraps normal constructors and exposes … you guessed it: A factory for DI consumers. Ember Ember.Application.create(); is a factory that produces the app. Rather than creating constructors to call with new, the .extend() methods augment the app. Node core services like http.createServer() and net.createServer() are factory functions. Express is a factory that creates an express app. The only object instantiation pattern more common than factories in JS is the object literal. JavaScript built-ins started out using constructors because Brendan Eich was told to make it look like Java. JavaScript continues to use constructors for self-consistency. It would be awkward to try to change everything to factories and deprecate constructors now. Doesn’t the Choice Between Classical and Prototypal Inheritance Depend on the Use Case?No. I recommend that you follow the Gang of Four’s advice on this point: “Favor object composition over class inheritance.” In Java, that was harder than class inheritance because you actually had to use classes to achieve it. In JavaScript, we don’t have that excuse. It’s actually much easier in JavaScript to simply create the object that you need by assembling various prototypes together than it is to manage object hierarchies. You don’t have to extend a class. JavaScript has dynamic object extension, and jQuery exposes its own prototype so you can just extend that: 12345678910/*How to extend the jQuery prototype:So difficult.Brain hurts.ouch.*/jQuery.fn.megaCalendarWidget = megaCalendarWidget;// omg I'm so glad that's over. The next time you call the jQuery factory, you’ll get an instance that can make your date inputs mega awesome. Similarly, you can use Object.assign() to compose any number of objects together with last-in priority: 1234import ninja from 'ninja';import mouse from 'mouse';let ninjamouse = Object.assign(&#123;&#125;, mouse, ninja); No, really — any number of objects: 12345678910111213// I'm not sure Object.assign() is available (ES6)// so this time I'll use Lodash.var assign = require('lodash/object/assign');var skydiving = require('skydiving');var ninja = require('ninja');var mouse = require('mouse');var wingsuit = require('wingsuit');// The amount of awesome in this next bit might be too much// for seniors with heart conditions or young children.var skydivingNinjaMouseWithWingsuit = assign(&#123;&#125;, // create a new object skydiving, ninja, mouse, wingsuit); // copy all the awesome to it. This technique is called concatenative inheritance, and the prototypes you inherit from are sometimes referred to as exemplar prototypes, which differ from delegate prototypes in that you copy from them, rather than delegate to them. Why Does this Matter?Inheritance is fundamentally a code reuse mechanism: A way for different kinds of objects to share code. The way that you share code matters because if you get it wrong, it can create a lot of problems. In fact, class inheritance causes many well known problems in OO design: Class inheritance creates parent/child object taxonomies as a side-effect. The tight coupling problem (class inheritance is the tightest coupling available in oo design), which leads to the next one… The fragile base class problemInflexible hierarchy problem (eventually, all evolving hierarchies are wrong for new uses) The duplication by necessity problem (due to inflexible hierarchies, new use cases are often shoe-horned in by duplicating, rather than adapting existing code) The Gorilla/banana problem (What you wanted was a banana, but what you got was a gorilla holding the banana, and the entire jungle) The solution to all of these problems is to favor object composition over class inheritance. Save my day - Eric Elliott on Medium","categories":[{"name":"Javascript","slug":"Javascript","permalink":"http://qetr1ck-op.github.io/categories/Javascript/"}],"tags":[{"name":"OOP","slug":"OOP","permalink":"http://qetr1ck-op.github.io/tags/OOP/"}]},{"title":"Kata: Function cache","slug":"Kata-Functions-Function-cache","date":"2016-02-14T19:17:45.000Z","updated":"2016-07-08T18:17:26.657Z","comments":true,"path":"2016/02/14/Kata-Functions-Function-cache/","link":"","permalink":"http://qetr1ck-op.github.io/2016/02/14/Kata-Functions-Function-cache/","excerpt":"If you are calculating complex things or execute time-consuming API calls, you sometimes want to cache the results. In this case we want you to create a function wrapper, which takes a function and caches its results depending on the arguments, that were applied to the function.","text":"If you are calculating complex things or execute time-consuming API calls, you sometimes want to cache the results. In this case we want you to create a function wrapper, which takes a function and caches its results depending on the arguments, that were applied to the function. Usage example: 123456const complexFunction = (arg1, arg2) =&gt; &#123; /* complex calculation in here */ &#125;;const cachedFunction = cache(complexFunction);cachedFunction('foo', 'bar'); // complex function should be executedcachedFunction('foo', 'bar'); // complex function should not be invoked again, instead the cached result should be returnedcachedFunction('foo', 'baz'); // should be executed, because the method wasn't invoked before with these arguments Result: 12345678910const cache = fn =&gt; &#123; const calls = &#123;&#125;; return function(...args) &#123; if (!calls[args]) &#123; calls[args] = fn(...args); &#125; return calls[args]; &#125;&#125;","categories":[{"name":"Javascript","slug":"Javascript","permalink":"http://qetr1ck-op.github.io/categories/Javascript/"},{"name":"Kata","slug":"Javascript/Kata","permalink":"http://qetr1ck-op.github.io/categories/Javascript/Kata/"}],"tags":[{"name":"Kata","slug":"Kata","permalink":"http://qetr1ck-op.github.io/tags/Kata/"},{"name":"Functions","slug":"Functions","permalink":"http://qetr1ck-op.github.io/tags/Functions/"}]},{"title":"Kata: Reverse words","slug":"Kata-String-Reverse-words","date":"2016-02-13T09:50:12.000Z","updated":"2016-07-08T18:18:13.517Z","comments":true,"path":"2016/02/13/Kata-String-Reverse-words/","link":"","permalink":"http://qetr1ck-op.github.io/2016/02/13/Kata-String-Reverse-words/","excerpt":"Write a reverseWords function that accepts a string a parameter, and reverses each word in the string. Every space should stay, so you cannot use words from Prelude.","text":"Write a reverseWords function that accepts a string a parameter, and reverses each word in the string. Every space should stay, so you cannot use words from Prelude. Example: 1reverseWords(\"This is an example!\"); // returns \"sihT si na !elpmaxe\" Test: 1Test.assertEquals(reverseWords(\"This is an example!\"), \"sihT si na !elpmaxe\") Result: 123456const reverseWords = str =&gt; &#123; return str .split(' ') .map( word =&gt; word.split('').reverse().join('') ) .join(' ');&#125;","categories":[],"tags":[]},{"title":"Kata: A chain adding function","slug":"Kata-Curring-A-chain-adding-function","date":"2016-02-11T21:15:33.000Z","updated":"2016-07-08T18:19:33.278Z","comments":true,"path":"2016/02/11/Kata-Curring-A-chain-adding-function/","link":"","permalink":"http://qetr1ck-op.github.io/2016/02/11/Kata-Curring-A-chain-adding-function/","excerpt":"Write a reverseWords function that accepts a string a parameter, and reverses each word in the string:","text":"Write a reverseWords function that accepts a string a parameter, and reverses each word in the string: 1reverseWords(\"This is an example!\"); // returns \"sihT si na !elpmaxe\" 1Test.assertEquals(reverseWords(\"This is an example!\"), \"sihT si na !elpmaxe\") 1234567'use strict';var reverseWords = str =&gt; &#123; return str.split(' ') .map( word =&gt; word.split('').reverse().join('') ) .join(' ')&#125;","categories":[{"name":"Javascript","slug":"Javascript","permalink":"http://qetr1ck-op.github.io/categories/Javascript/"}],"tags":[{"name":"Kata","slug":"Kata","permalink":"http://qetr1ck-op.github.io/tags/Kata/"},{"name":"Strings","slug":"Strings","permalink":"http://qetr1ck-op.github.io/tags/Strings/"}]},{"title":"Development with Webpack and React part 4","slug":"Development-with-Webpack-and-React-part-4","date":"2016-02-10T19:39:47.000Z","updated":"2016-02-20T20:48:40.568Z","comments":true,"path":"2016/02/10/Development-with-Webpack-and-React-part-4/","link":"","permalink":"http://qetr1ck-op.github.io/2016/02/10/Development-with-Webpack-and-React-part-4/","excerpt":"React and Flux architecture with Alt","text":"React and Flux architecture with Alt You can get pretty far by keeping everything in components. Eventually, that will become painful. Introduction to FluxSo far, we’ve been dealing only with views. Flux architecture introduces a couple of new concepts to the mix. These are actions, dispatcher, and stores. Flux implements unidirectional flow in contrast to popular frameworks, such as Angular or Ember. Actions and StoresIn our case, we will model NoteActions and NoteStore. NoteActions provide concrete operations we can perform over our data. For instance, we can have NoteActions.create({task: &#39;Learn React&#39;}). DispatcherWhen we trigger the action, the dispatcher will get notified. The dispatcher will be able to deal with possible dependencies between stores. It is possible that a certain action needs to happen before another. The dispatcher allows us to achieve this. At the simplest level, actions can just pass the message to the dispatcher as is. Once the dispatcher has dealt with the action, stores that are listening to it get triggered. In our case, NoteStore gets notified. As a result, it will be able to update its internal state. After doing this it will notify possible listeners of the new state. Flux DataflowUsually, though, the unidirectional process has a cyclical flow and it doesn’t necessarily end. Eventually, the components depending on our store data become refreshed through this looping process. Advantages of FluxEven though this sounds a little complicated, the arrangement gives our application flexibility. We can, for instance, implement API communication, caching, and i18n outside of our views. This way they stay clean of logic while keeping the application easier to understand. Implementing Flux architecture in your application will actually increase the amount of code. It has been designed to allow productivity across larger teams. You could say, “explicit is better than implicit”. Which Flux Implementation to Use?There is no single right way to interpret the architecture. You will find implementations that fit different tastes. voronianski/flux-comparison provides a nice comparison between some of the more popular ones. Porting to AltIt is a flexible, full-featured implementation that has been designed with universal (isomorphic) rendering in mind. In Alt, you’ll deal with actions and stores. The dispatcher is hidden, but you will still have access to it if needed. Compared to other implementations Alt hides a lot of boilerplate. There are special features to allow you to save and restore the application state. This is handy for implementing persistency and universal rendering. Setting Up an Alt InstanceEverything in Alt begins from an Alt instance. It keeps track of actions and stores and keeps communication going on. Set it up as follows: 123456789//app/libs/alt.jsimport Alt from 'alt';//import chromeDebug from 'alt-utils/lib/chromeDebug';const alt = new Alt();//chromeDebug(alt);export default alt; Webpack caches the modules so the next time you import Alt, it will return the same instance again. There is a Chrome plugin known as alt-devtool Defining CRUD API for NotesNext, we’ll need to define a basic API for operating over the Note data. Alt provides a shorthand known as generateActions. We can use it like this: 12345//app/actions/NoteActions.jsimport alt from '../libs/alt';export default alt.generateActions('create', 'update', 'delete'); Defining a Store for NotesA store is a single source of truth for a part of your application state. In this case, we need one to maintain the state of the notes. We will connect all the actions we defined above using the bindActions function. We have the logic we need for our store already at App. We will move that logic to NoteStore. As a first step, we can set up a skeleton for our store. We can fill in the methods we need after that. Here’s a starting point: 123456789101112131415161718192021222324//app/stores/NoteStore.jsimport uuid from 'node-uuid';import alt from '../libs/alt';import NoteActions from '../actions/NoteActions';class NoteStore &#123; constructor() &#123; this.bindActions(NoteActions); this.notes = []; &#125; create(note) &#123; &#125; update(updatedNote) &#123; &#125; delete(id) &#123; &#125;&#125;export default alt.createStore(NoteStore, 'NoteStore'); We call bindActions to map each action to a method by name. We trigger the appropriate logic at each method based on that. Finally, we connect the store with Alt using alt.createStore. Note that assigning a label to a store (NoteStore in this case) isn’t required. It is a good practice as it protects the code against minification and possible collisions. These labels become important when we persist the data. Implementing create12345678910111213141516171819202122232425//app/stores/NoteStore.jsimport uuid from 'node-uuid';import alt from '../libs/alt';import NoteActions from '../actions/NoteActions';class NoteStore &#123; constructor() &#123; ... &#125; create(note) &#123; const notes = this.notes; note.id = uuid.v4(); this.setState(&#123; notes: notes.concat(note) &#125;); &#125; ...&#125;export default alt.createStore(NoteStore, 'NoteStore'); To keep the implementation clean, we are using this.setState. It is a feature of Alt that allows us to signify that we are going to alter the store state. Alt will signal the change to possible listeners. Implementing update1234567891011121314151617181920212223242526272829303132app/stores/NoteStore.js...class NoteStore &#123; ... update(updatedNote) &#123; const notes = this.notes.map(note =&gt; &#123; if(note.id === updatedNote.id) &#123; // Object.assign is used to patch the note data here. It // mutates target (first parameter). In order to avoid that, // I use &#123;&#125; as its target and apply data on it. // // Example: &#123;&#125;, &#123;a: 5, b: 3&#125;, &#123;a: 17&#125; -&gt; &#123;a: 17, b: 3&#125; // return Object.assign(&#123;&#125;, note, updatedNote); &#125; return note; &#125;); // This is same as `this.setState(&#123;notes: notes&#125;)` this.setState(&#123;notes&#125;); &#125; delete(id) &#123; &#125;&#125;export default alt.createStore(NoteStore, 'NoteStore'); Implementing delete12345678910111213141516app/stores/NoteStore.js...class NoteStore &#123; ... delete(id) &#123; this.setState(&#123; notes: this.notes.filter(note =&gt; note.id !== id) &#125;); &#125;&#125;export default alt.createStore(NoteStore, 'NoteStore'); Instead of slicing and concatenating data, it would be possible to operate directly on it. For example a mutable variant, such as this.notes.splice(targetId, 1) would work. We could also use a shorthand, such as [...notes.slice(0, noteIndex), ...notes.slice(noteIndex + 1)]. The exact solution depends on your preferences. I prefer to avoid mutable solutions (i.e., splice) myself. Gluing It All TogetherOur NoteStore provides two methods in particular that are going to be useful. These are NoteStore.listen and NoteStore.unlisten. They will allow views to subscribe to the state changes. As you might remember from the earlier chapters, React provides a set of lifecycle hooks. We can subscribe to NoteStore within our view at componentDidMount and componentWillUnmount. By unsubscribing, we avoid possible memory leaks. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859//app/components/App.jsximport React from 'react';import Notes from './Notes.jsx';//------------------------------------------------import NoteActions from '../actions/NoteActions';import NoteStore from '../stores/NoteStore';//------------------------------------------------export default class App extends React.Component &#123; constructor(props) &#123; super(props); this.state = NoteStore.getState(); &#125; componentDidMount() &#123; NoteStore.listen(this.storeChanged); &#125; componentWillUnmount() &#123; NoteStore.unlisten(this.storeChanged); &#125; storeChanged = (state) =&gt; &#123; // Without a property initializer `this` wouldn't // point at the right context because it defaults to // `undefined` in strict mode. this.setState(state); &#125;; render() &#123; const notes = this.state.notes; return ( &lt;div&gt; &lt;button className=\"add-note\" onClick=&#123;this.addNote&#125;&gt;+&lt;/button&gt; &lt;Notes notes=&#123;notes&#125; onEdit=&#123;this.editNote&#125; onDelete=&#123;this.deleteNote&#125; /&gt; &lt;/div&gt; ); &#125; deleteNote(id) &#123; NoteActions.delete(id); &#125; addNote() &#123; NoteActions.create(&#123;task: 'New task'&#125;); &#125; editNote(id, task) &#123; // Don't modify if trying set an empty value if(!task.trim()) &#123; return; &#125; NoteActions.update(&#123;id, task&#125;); &#125; The application should work just like before now. As we alter ‘NoteStore’ through actions, this leads to a cascade that causes our ‘App’ state to update through ‘setState’. This in turn will cause the component to ‘render’. That’s Flux’s unidirectional flow in practice. We actually have more code now than before, but that’s okay. ‘App’ is a little neater and it’s going to be easier to develop as we’ll soon see. Implementing Persistency over localStoragelocalStorage has a sibling known as sessionStorage. Whereas sessionStorage loses its data when the browser is closed, localStorage retains its data. They both share the same API as discussed below: storage.getItem(k) - Returns the stored string value for the given key. storage.removeItem(k) - Removes the data matching the key. storage.setItem(k, v) - Stores the given value using the given key. storage.clear() - Empties the storage contents. Implementing a Wrapper for localStorageAs objects are convenient, we’ll use JSON.parse and JSON.stringify for serialization. We need just storage.get(k) and storage.set(k, v) as seen in the implementation below: 123456789101112131415//app/libs/storage.jsexport default &#123; get(k) &#123; try &#123; return JSON.parse(localStorage.getItem(k)); &#125; catch(e) &#123; return null; &#125; &#125;, set(k, v) &#123; localStorage.setItem(k, JSON.stringify(v)); &#125;&#125;; The implementation could be generalized further. You could convert it into a factory storage =&gt; {...} and make it possible to swap the storage. Now we are stuck with localStorage unless we change the code. An alternative would be to use localForage to hide all the complexity. Persisting Application Using FinalStoreBesides this little utility, we’ll need to adapt our application to use it. Alt provides a built-in store called FinalStore which is perfect for this purpose. We can persist the entire state of our application using FinalStore, bootstrapping, and snapshotting. FinalStore is a store that listens to all existing stores. Every time some store changes, FinalStore will know about it. This makes it ideal for persistency. We can take a snapshot of the entire app state and push it to localStorage every time FinalStore changes. That solves one part of the problem. Bootstrapping solves the remaining part as alt.bootstrap allows us to set state of the all stores. The method doesn’t emit events. To make our stores populate with the right state, we will need to call it before the components are rendered. In our case, we’ll fetch the data from localStorage and invoke it to populate our stores. An alternative way would be to take a snapshot only when the window gets closed. There’s a Window level beforeunload hook that could be used. The problem with this approach is that it is brittle. What if something unexpected happens and the hook doesn’t get triggered for some reason? You’ll lose data. app/libs/persist.js does the hard part. It will set up a FinalStore, deal with bootstrapping (restore data) and snapshotting (save data). I have included an escape hatch in the form of the debug flag. If it is set, the data won’t get saved to localStorage. The reasoning is that by doing this, you can set the flag (localStorage.setItem(&#39;debug&#39;, &#39;true&#39;)), hit localStorage.clear() and refresh the browser to get a clean slate. The implementation below illustrates these ideas: 1234567891011121314151617181920//app/libs/persist.jsimport makeFinalStore from 'alt-utils/lib/makeFinalStore';export default function(alt, storage, storeName) &#123; const finalStore = makeFinalStore(alt); try &#123; alt.bootstrap(storage.get(storeName)); &#125; catch(e) &#123; console.error('Failed to bootstrap data', e); &#125; finalStore.listen(() =&gt; &#123; if(!storage.get('debug')) &#123; storage.set(storeName, alt.takeSnapshot()); //(1) &#125; &#125;);&#125; We will need to pass the relevant data to it (Alt instance, storage, storage name) and off we go: 123456789101112//app/index.jsx...import alt from './libs/alt';import storage from './libs/storage';import persist from './libs/persist';persist(alt, storage, 'app');ReactDOM.render(&lt;App /&gt;, document.getElementById('app')); Using the AltContainerThe AltContainer wrapper allows us to simplify connection logic greatly and cut down the amount of logic needed. The implementation below illustrates how to bind it all together. Note how much code we can remove! 12345678910111213141516171819202122232425262728//app/components/App.jsximport AltContainer from 'alt-container';import React from 'react';import Notes from './Notes.jsx';import NoteActions from '../actions/NoteActions';import NoteStore from '../stores/NoteStore';export default class App extends React.Component &#123; render() &#123; return ( &lt;div&gt; &lt;button className=\"add-note\" onClick=&#123;this.addNote&#125;&gt;+&lt;/button&gt; &lt;AltContainer stores=&#123;[NoteStore]&#125; inject=&#123;&#123; notes: () =&gt; NoteStore.getState().notes &#125;&#125; &gt; &lt;Notes onEdit=&#123;this.editNote&#125; onDelete=&#123;this.deleteNote&#125; /&gt; &lt;/AltContainer&gt; &lt;/div&gt; ); &#125; ...&#125; The AltContainer allows us to bind data to its immediate children. In this case, it injects the notes property in to Notes. The pattern allows us to set up arbitrary connections to multiple stores and manage them. Alternative Implementations Redux is a Flux inspired architecture that was designed with hot loading as its primary constraint. Redux operates based on a single state tree. The state of the tree is manipulated using pure functions known as reducers. Even though there’s some boilerplate code, Redux forces you to dig into functional programming. The implementation is quite close to the Alt based one. - Redux demo Compared to Redux, Cerebral had a different starting point. It was developed to provide insight on how the application changes its state. Cerebral provides more opinionated way to develop, and as a result, comes with more batteries included. - Cerebral demo Mobservable allows you to make your data structures observable. The structures can then be connected with React components so that whenever the structures update, so do the React components. Given real references between structures can be used, the Kanban implementation is surprisingly simple. - Mobservable demo Final app sourcesThe final app of the article here Save my day: (http://survivejs.com/)[http://survivejs.com/webpack_react/react_and_flux/]","categories":[{"name":"Javascript","slug":"Javascript","permalink":"http://qetr1ck-op.github.io/categories/Javascript/"}],"tags":[{"name":"Webpack","slug":"Webpack","permalink":"http://qetr1ck-op.github.io/tags/Webpack/"},{"name":"Babel","slug":"Babel","permalink":"http://qetr1ck-op.github.io/tags/Babel/"},{"name":"ES6","slug":"ES6","permalink":"http://qetr1ck-op.github.io/tags/ES6/"},{"name":"React","slug":"React","permalink":"http://qetr1ck-op.github.io/tags/React/"},{"name":"Alt","slug":"Alt","permalink":"http://qetr1ck-op.github.io/tags/Alt/"}]},{"title":"Kata: All, None & Any","slug":"Kata-Fundamentals-Arrays-All-None-Any","date":"2016-02-10T18:58:59.000Z","updated":"2016-07-08T18:21:19.726Z","comments":true,"path":"2016/02/10/Kata-Fundamentals-Arrays-All-None-Any/","link":"","permalink":"http://qetr1ck-op.github.io/2016/02/10/Kata-Fundamentals-Arrays-All-None-Any/","excerpt":"As a part of this Kata, you need to create three functions that one needs to be able to call upon an array:","text":"As a part of this Kata, you need to create three functions that one needs to be able to call upon an array: all This function returns true only if the predicate supplied returns true for all the items in the array 12[1, 2, 3].all(isGreaterThanZero) =&gt; true[-1, 0, 2].all(isGreaterThanZero) =&gt; false none This function returns true only if the predicate supplied returns false for all the items in the array 12[-1, 2, 3].none(isLessThanZero) =&gt; false[-1, -2, -3].none(isGreaterThanZero) =&gt; true any This function returns true if at least one of the items in the array returns true for the predicate supplied 12[-1, 2, 3].any(isGreaterThanZero) =&gt; true[-1, -2, -3].any(isGreaterThanZero) =&gt; false You do not need to worry about the data supplied, it will be an array at all times. 12345678910111213141516function isGreaterThanZero (num) &#123; return num &gt; 0;&#125;function isLessThanZero (num) &#123; return num &lt; 0;&#125;Test.expect([1, 2, 3].all(isGreaterThanZero), 'All are greater than zero');Test.expect(![-1, 0, 2].all(isLessThanZero), 'All is less than zero');Test.expect(![1, 2, 3].none(isGreaterThanZero), 'None is greater than zero');Test.expect([3, 0, 2].none(isLessThanZero), 'None is less than zero');Test.expect([1, 2, 3].any(isGreaterThanZero), 'None is greater than zero');Test.expect([-1, 0, 2].any(isLessThanZero), 'None is less than zero'); 1234567891011Array.prototype.all = function (p) &#123; return this.filter(p).length === this.length;&#125;;Array.prototype.none = function (p) &#123; return this.filter(p).length === 0;&#125;;Array.prototype.any = function (p) &#123; return this.filter(p).length &gt; 0;&#125;;","categories":[{"name":"Javascript","slug":"Javascript","permalink":"http://qetr1ck-op.github.io/categories/Javascript/"},{"name":"Kata","slug":"Javascript/Kata","permalink":"http://qetr1ck-op.github.io/categories/Javascript/Kata/"}],"tags":[{"name":"Kata","slug":"Kata","permalink":"http://qetr1ck-op.github.io/tags/Kata/"},{"name":"Array","slug":"Array","permalink":"http://qetr1ck-op.github.io/tags/Array/"}]},{"title":"Kata: Are they square?","slug":"Kata-Arrays-Are-they-square","date":"2016-02-09T21:54:01.000Z","updated":"2016-07-08T18:20:25.762Z","comments":true,"path":"2016/02/09/Kata-Arrays-Are-they-square/","link":"","permalink":"http://qetr1ck-op.github.io/2016/02/09/Kata-Arrays-Are-they-square/","excerpt":"Write a function that checks whether all elements in an array are square numbers. The function should be able to take any number of array elements.","text":"Write a function that checks whether all elements in an array are square numbers. The function should be able to take any number of array elements. Your function should return true if all elements in the array are square numbers and false if not. An empty array should return undefined. You can assume that all array elements will be positive integers. 12345678Test.describe(\"isSquare\",function() &#123; Test.it(\"Basic tests\",function() &#123; Test.assertEquals(isSquare([1, 4, 9, 16, 25, 36]), true); Test.assertEquals(isSquare([1, 2, 3, 4, 5, 6]), false); Test.assertEquals(isSquare([]), undefined); Test.assertEquals(isSquare([1, 2, 4, 15]), false); &#125;)&#125;); 123var isSquare = function(arr)&#123; return (arr.length) ? arr.every(x =&gt; Math.sqrt(x) % 1 === 0) : undefined;&#125;","categories":[{"name":"Javascript","slug":"Javascript","permalink":"http://qetr1ck-op.github.io/categories/Javascript/"}],"tags":[{"name":"Kata","slug":"Kata","permalink":"http://qetr1ck-op.github.io/tags/Kata/"},{"name":"Arrays","slug":"Arrays","permalink":"http://qetr1ck-op.github.io/tags/Arrays/"}]},{"title":"Development with Webpack and React part 3","slug":"Development-with-Webpack-and-React-part-3","date":"2016-02-07T18:33:51.000Z","updated":"2016-10-05T20:34:46.336Z","comments":true,"path":"2016/02/07/Development-with-Webpack-and-React-part-3/","link":"","permalink":"http://qetr1ck-op.github.io/2016/02/07/Development-with-Webpack-and-React-part-3/","excerpt":"Implement a basic note application.","text":"Implement a basic note application. Initial data model and setting up AppWe’ll be using a Node.js implementation known as node-uuid and its uuid.v4 variant. It will give us ids, such as 1c8e7a12-0b4c-4f23-938c-00d7161f94fc and they are guaranteed to be unique with a very high probability. The simplest way to achieve that is to push the data directly to render() for now: 12345678910111213141516171819202122232425262728293031323334//app/components/App.jsximport uuid from 'node-uuid';import React from 'react';export default class App extends React.Component &#123; render() &#123; const notes = [ &#123; id: uuid.v4(), task: 'Learn Webpack' &#125;, &#123; id: uuid.v4(), task: 'Learn React' &#125;, &#123; id: uuid.v4(), task: 'Do laundry' &#125; ]; return ( &lt;div&gt; &lt;ul&gt;&#123;notes.map(note =&gt; &lt;li key=&#123;note.id&#125;&gt;&#123;note.task&#125;&lt;/li&gt; )&#125;&lt;/ul&gt; &lt;/div&gt; ); &#125;&#125; In order to tell React in which order to render the elements, we use the key property. It is important that this is unique or else React won’t be able to figure out the correct order in which to render. If not set, React will give a warning: 1&lt;li key=&#123;note.id&#125;&gt;&#123;note.task&#125;&lt;/li&gt; If you want to attach comments to your JSX, just use {/* no comments */} Adding New Items to the ListCurrently the state of our application is tied to render(). In order to make it possible to modify it, we’ll need to convert it into component state: 123456789101112131415161718192021222324252627282930313233//app/components/App.jsx...export default class App extends React.Component &#123; constructor(props) &#123; // ------------------------ super(props); this.state = &#123; notes: [ &#123; id: uuid.v4(), task: 'Learn Webpack' &#125;, &#123; id: uuid.v4(), task: 'Learn React' &#125;, &#123; id: uuid.v4(), task: 'Do laundry' &#125; ] &#125;; // ------------------------ &#125; render() &#123; // ----------------------------- const notes = this.state.notes; // ----------------------------- ... &#125;&#125; In the earlier versions of React, you achieved the same result with getInitialState. We’re passing props to super by convention. If you don’t pass it, this.props won’t get set! Calling super invokes the same method of the parent class and you see this kind of usage in object oriented programming often. Defining addNote HandlerNow that we have state, we can begin to modify it. A good way to achieve this is to add a simple button to App and then trigger this.setState to force React to alter the state and trigger render(): 1234567891011121314151617181920212223242526272829303132333435...export default class App extends React.Component &#123; constructor(props) &#123; ... &#125; render() &#123; const notes = this.state.notes; return ( &lt;div&gt; &lt;button onClick=&#123;this.addNote&#125;&gt;+&lt;/button&gt; &lt;ul&gt;&#123;notes.map(note =&gt; &lt;li key=&#123;note.id&#125;&gt;&#123;note.task&#125;&lt;/li&gt; )&#125;&lt;/ul&gt; &lt;/div&gt; ); &#125; // We are using an experimental feature known as property // initializer here. It allows us to bind the method `this` // to point at our *App* instance. // // Alternatively we could `bind` at `constructor` using // a line, such as this.addNote = this.addNote.bind(this); addNote = () =&gt; &#123; this.setState(&#123; notes: this.state.notes.concat([&#123; id: uuid.v4(), task: 'New task' &#125;]) &#125;); &#125;;&#125; this.setState accepts a second parameter like this: this.setState({...}, () =&gt; console.log(&#39;set state!&#39;)). This is handy to know if you want to trigger some behavior right after setState has completed. You could use [...this.state.notes, {id: uuid.v4(), task: &#39;New task&#39;}] to achieve the same result. Improving Component HierarchyBy looking at our application, we can see there’s a component hierarchy like this: App - App retains application state and deals with the high level logic.Notes - Notes acts as an intermediate in between and renders individual Note components.Note - Note is the workhorse of our application. Editing and deletion will be triggered here. That logic will cascade to App through wiring. Extracting NoteNote is a component which will need to receive task as a prop and render it as below: 12345//app/components/Note.jsximport React from 'react';export default (&#123;task&#125;) =&gt; &lt;div&gt;&#123;task&#125;&lt;/div&gt;; Extracting Notes is a similar operation: 12345678910111213141516//app/components/Notes.jsximport React from 'react';import Note from './Note.jsx';export default (&#123;notes&#125;) =&gt; &#123; return ( &lt;ul&gt;&#123;notes.map(note =&gt; &lt;li key=&#123;note.id&#125;&gt; //------------------------ &lt;Note task=&#123;note.task&#125; /&gt; //------------------------ &lt;/li&gt; )&#125;&lt;/ul&gt; );&#125; We should tweak App to connect the component with it: 12345678910111213141516171819202122232425262728293031323334//app/components/App.jsximport uuid from 'node-uuid';import React from 'react';import Note from './Note.jsx';import Notes from './Notes.jsx';export default class App extends React.Component &#123; constructor(props) &#123; ... &#125; render() &#123; const notes = this.state.notes; return ( &lt;div&gt; &lt;button onClick=&#123;this.addNote&#125;&gt;+&lt;/button&gt; //--------------------------------------- &lt;Notes notes=&#123;notes&#125; /&gt; //--------------------------------------- &lt;/div&gt; ); &#125; addNote = () =&gt; &#123; this.setState(&#123; notes: this.state.notes.concat([&#123; id: uuid.v4(), task: 'New task' &#125;]) &#125;); &#125;;&#125; Editing NotesThis means Note will need to track its editing state somehow. In addition, we need to communicate that the value (task) has changed so that App knows to update its state. Tracking Note editing State1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677//app/components/Note.jsximport React from 'react';export default class Note extends React.Component &#123; constructor(props) &#123; super(props); // Track `editing` state. this.state = &#123; editing: false &#125;; &#125; render() &#123; // Render the component differently based on state. if(this.state.editing) &#123; return this.renderEdit(); &#125; return this.renderNote(); &#125; renderEdit = () =&gt; &#123; // We deal with blur and input handlers here. These map to DOM events. // We also set selection to input end using a callback at a ref. // It gets triggered after the component is mounted. // // We could also use a string reference (i.e., `ref=\"input\") and // then refer to the element in question later in the code. This // would allow us to use the underlying DOM API through // this.refs.input. This can be useful when combined with // React lifecycle methods. return &lt;input type=\"text\" ref=&#123; (e) =&gt; e ? e.selectionStart = this.props.task.length : null &#125; autoFocus=&#123;true&#125; defaultValue=&#123;this.props.task&#125; onBlur=&#123;this.finishEdit&#125; onKeyPress=&#123;this.checkEnter&#125; /&gt;; &#125;; renderNote = () =&gt; &#123; // If the user clicks a normal note, trigger editing logic. return &lt;div onClick=&#123;this.edit&#125;&gt;&#123;this.props.task&#125;&lt;/div&gt;; &#125;; edit = () =&gt; &#123; // Enter edit mode. this.setState(&#123; editing: true &#125;); &#125;; checkEnter = (e) =&gt; &#123; // The user hit *enter*, let's finish up. if(e.key === 'Enter') &#123; this.finishEdit(e); &#125; &#125;; finishEdit = (e) =&gt; &#123; // `Note` will trigger an optional `onEdit` callback once it // has a new value. We will use this to communicate the change to // `App`. // // A smarter way to deal with the default value would be to set // it through `defaultProps`. // // See *Typing with React* chapter for more information. const value = e.target.value; if(this.props.onEdit &amp;&amp; value.trim()) &#123; this.props.onEdit(value); // Exit edit mode. this.setState(&#123; editing: false &#125;); &#125; &#125;;&#125; If you try to edit a Note now, you should see an input and be able to edit the data. Given we haven’t set up onEdit handler, it doesn’t do anything useful yet, though. We’ll need to capture the edited data next and update App state so that the code works. It is a good idea to name your callbacks using on prefix. This will allow you to distinguish them from other props and keep your code a little tidier. Communicating Note State ChangesThis can be achieved through data binding as illustrated by the diagram below: As onEdit is defined on App level, we’ll need to pass onEdit handler through Notes. So for the stub to work, changes in two files are needed. Here’s what it should look like for App: 123456789101112131415161718192021222324252627282930313233343536373839//app/components/App.jsximport uuid from 'node-uuid';import React from 'react';import Notes from './Notes.jsx';export default class App extends React.Component &#123; constructor(props) &#123; ... &#125; render() &#123; const notes = this.state.notes; return ( &lt;div&gt; &lt;button onClick=&#123;this.addNote&#125;&gt;+&lt;/button&gt; //--------------------------------------------- &lt;Notes notes=&#123;notes&#125; onEdit=&#123;this.editNote&#125; /&gt; //--------------------------------------------- &lt;/div&gt; ); &#125; addNote = () =&gt; &#123; ... &#125;; editNote = (id, task) =&gt; &#123; const notes = this.state.notes.map(note =&gt; &#123; if(note.id === id &amp;&amp; task) &#123; note.task = task; &#125; return note; &#125;); this.setState(&#123;notes&#125;); &#125;;&#125; To make the scheme work as designed, we need to modify Notes to work according to the idea: 123456789101112131415161718192021//app/components/Notes.jsximport React from 'react';import Note from './Note.jsx';export default (&#123;notes, onEdit&#125;) =&gt; &#123; return ( &lt;ul&gt;&#123;notes.map(note =&gt; &lt;li key=&#123;note.id&#125;&gt; &lt;Note task=&#123;note.task&#125; //--------------------------------------------- onEdit=&#123;onEdit.bind(null, note.id)&#125; /&gt; //--------------------------------------------- &lt;/li&gt; )&#125;&lt;/ul&gt; );&#125; Removing NotesJust like earlier, it will take three changes. We need to define logic at App level, bind the id at Notes, and then finally trigger the logic at Note through its user interface. To get started, App logic can be defined in terms of filter: 12345678910111213141516171819202122232425262728//app/components/App.jsxexport default class App extends React.Component &#123; ... render() &#123; const notes = this.state.notes; return ( &lt;div&gt; &lt;button onClick=&#123;this.addNote&#125;&gt;+&lt;/button&gt; &lt;Notes notes=&#123;notes&#125; onEdit=&#123;this.editNote&#125; //--------------------------------------------- onDelete=&#123;this.deleteNote&#125; /&gt; //--------------------------------------------- &lt;/div&gt; ); &#125; deleteNote = (id) =&gt; &#123; this.setState(&#123; notes: this.state.notes.filter(note =&gt; note.id !== id) &#125;); &#125;; ...&#125; Notes will work similarly as earlier: 1234567891011121314151617181920212223//app/components/Notes.jsximport React from 'react';import Note from './Note.jsx';export default (&#123;notes, onEdit&#125;) =&gt; &#123;export default (&#123;notes, onEdit, onDelete&#125;) =&gt; &#123; return ( &lt;ul&gt;&#123;notes.map(note =&gt; &lt;li key=&#123;note.id&#125;&gt; &lt;Note task=&#123;note.task&#125; onEdit=&#123;onEdit.bind(null, note.id)&#125; //--------------------------------------------- onDelete=&#123;onDelete.bind(null, note.id)&#125; /&gt; //--------------------------------------------- &lt;/li&gt; )&#125;&lt;/ul&gt; );&#125; Finally, we need to attach a delete button to each Note and then trigger onDelete when those are clicked: 12345678910111213141516171819202122232425//app/components/Note.jsx...export default class Note extends React.Component &#123; ... renderNote = () =&gt; &#123; // If the user clicks a normal note, trigger editing logic. const onDelete = this.props.onDelete; return ( //----------------------------------------- &lt;div onClick=&#123;this.edit&#125;&gt; &lt;span&gt;&#123;this.props.task&#125;&lt;/span&gt; &#123;onDelete ? this.renderDelete() : null &#125; &lt;/div&gt; //----------------------------------------- ); &#125;; //--------------------------------------------------------- renderDelete = () =&gt; &#123; return &lt;button onClick=&#123;this.props.onDelete&#125;&gt;x&lt;/button&gt;; &#125;; //--------------------------------------------------------- ... Understanding React ComponentsUnderstanding how props and state work is important. Component lifecycle is another key concept. React provides the following lifecycle hooks: Process of initial render: Lifecycle for state change: More in off docs. Final app sourcesThe final source of the article here Save my day: (http://survivejs.com/)[http://survivejs.com/webpack_react/implementing_notes/]","categories":[{"name":"Javascript","slug":"Javascript","permalink":"http://qetr1ck-op.github.io/categories/Javascript/"}],"tags":[{"name":"Webpack","slug":"Webpack","permalink":"http://qetr1ck-op.github.io/tags/Webpack/"},{"name":"Babel","slug":"Babel","permalink":"http://qetr1ck-op.github.io/tags/Babel/"},{"name":"ES6","slug":"ES6","permalink":"http://qetr1ck-op.github.io/tags/ES6/"},{"name":"React","slug":"React","permalink":"http://qetr1ck-op.github.io/tags/React/"},{"name":"Alt","slug":"Alt","permalink":"http://qetr1ck-op.github.io/tags/Alt/"}]},{"title":"Development with Webpack and React part 2","slug":"Development-with-Webpack-and-React-p-2","date":"2016-02-07T14:13:20.000Z","updated":"2016-10-05T20:36:30.279Z","comments":true,"path":"2016/02/07/Development-with-Webpack-and-React-p-2/","link":"","permalink":"http://qetr1ck-op.github.io/2016/02/07/Development-with-Webpack-and-React-p-2/","excerpt":"Configuring webpack babel-loader with .babelrc. Set up hot loading and create first React view.","text":"Configuring webpack babel-loader with .babelrc. Set up hot loading and create first React view. Configuring babel-loaderYou can use Babel with Webpack easily through babel-loader. It takes our ES6 module definition based code and turn it into ES5 bundles: 1npm i babel-loader babel-core --save-dev To make this work, we need to add a loader declaration for babel-loader to the loaders section of the configuration. It matches against both .js and .jsx using a regular expression /\\.jsx?$/. To keep everything performant we should restrict the loader to operate within ./app directory. This way it won’t traverse node_modules: 1234567891011121314151617181920212223242526272829303132333435363738...// webpack.config.jsconst common = &#123; entry: PATHS.app, // Add resolve.extensions. // '' is needed to allow imports without an extension. // Note the .'s before extensions as it will fail to match without!!! resolve: &#123; extensions: ['', '.js', '.jsx'] &#125;, output: &#123; path: PATHS.build, filename: 'bundle.js' &#125;, module: &#123; loaders: [ &#123; test: /\\.css$/, loaders: ['style', 'css'], include: PATHS.app &#125;, // Set up jsx. This accepts js too thanks to RegExp &#123; test: /\\.jsx?$/, // Enable caching for improved performance during development // It uses default OS directory by default. If you need something // more custom, pass a path to it. I.e., babel?cacheDirectory=&lt;path&gt; loaders: ['babel?cacheDirectory'], include: PATHS.app &#125; ] &#125;&#125;;... Note that resolve.extensions setting will allow you to refer to JSX files without an extension now. Setting up .babelrcAlso, we are going to need a .babelrc. You could pass Babel settings through Webpack (i.e., babel?presets[]=react,presets[]=es2015), but then it would be just for Webpack only. That’s why we are going to push our Babel settings to this specific dotfile. The same idea applies for other tools, such as ESLint. Babel 6 relies on plugins. To make it easier to consume plugins, Babel supports the concept of presets. Each preset comes with a set of plugins so you don’t have to wire them up separately. In this case we’ll be relying on ES2015 and JSX presets: 1npm i -D babel-preset-es2015 babel-preset-react In addition, we’ll be enabling a couple of custom features to make the project more convenient to develop: Property initializers - Example: renderNote = (note) =&gt; {. This binds the renderNote method to instances automatically. The feature makes more sense as we get to use it. Decorators - Example: @DragDropContext(HTML5Backend). These annotations allow us to attach functionality to classes and their methods. Object rest/spread - Example: const {a, b, ...props} = this.props. This syntax allows us to easily extract specific properties from an object. In order to make it easier to set up the features we will use: 1npm i -D babel-preset-survivejs-kanban Next we need to set up a .babelrc file to make this all work: 12345678// .babelrc&#123; \"presets\": [ \"es2015\", \"react\", \"survivejs-kanban\" ]&#125; Using Babel for Webpack ConfigurationSimply rename webpack.config.js towebpack.config.babel.js and Webpack will pick it up provided Babel has been set up in your project. For this to work, you will need to have babel-register installed to your project. Alternative Loader DeclarationsThe first one shows how to pass parameters to a loader through a query string: 1234567&#123; test: /\\.jsx?$/, loaders: [ 'babel?cacheDirectory,presets[]=react,presets[]=es2015,presets[]=survivejs-kanban' ], include: PATHS.app&#125; Another way is to use the combination of loader and query fields: 123456789&#123; test: /\\.jsx?$/, loader: 'babel', query: &#123; cacheDirectory: true, presets: ['react', 'es2015', 'survivejs-kanban'] &#125;, include: PATHS.app&#125; It’s a good idea to keep in mind that Webpack loaders are always evaluated from right to left and from bottom to top. Developing the First React View1npm i react react-dom -S First, we should define the App. This will be the core of our application: 123456789//app/components/App.jsximport React from 'react';import Note from './Note.jsx';export default class App extends React.Component &#123; render() &#123; return &lt;Note /&gt;; &#125;&#125; You can import portions from react using the syntax import React, {Component} from &#39;react&#39;;. Then you can do class App extends Component. It is important that you import React as well because that JSX will get converted to React.createElement calls. Setting up Note12345//app/components/Note.jsximport React from 'react';export default () =&gt; &lt;div&gt;Learn Webpack&lt;/div&gt;; Note that we’re using the jsx extension here. It is not absolutely necessary, but it is a good convention to have. Rendering index.jsx 123456789//app/index.jsximport './main.css';import React from 'react';import ReactDOM from 'react-dom';import App from './components/App.jsx';ReactDOM.render(&lt;App /&gt;, document.getElementById('app')); Activating Hot Loading for DevelopmentNote that every time you perform a modification, the browser updates with a flash. That’s unfortunate because this means our application loses state. It is annoying to manipulate the user interface back to the state in which it was to test something. We can work around this problem using hot loading. babel-plugin-react-transform allow us to instrument React components in various ways. Hot loading is one of these. It is enabled through react-transform-hmr. A Babel preset known as babel-preset-react-hmre will keep our setup simple: 1npm i babel-preset-react-hmre --save-dev An easy way to control .babelrc is to set BABEL_ENV environment variable as npm lifecycle event. This gives us a predictable mapping between package.json and .babelrc: 12//webpack.config.jsprocess.env.BABEL_ENV = TARGET; In addition we need to expand our Babel configuration: 12345678910//.babelrc...\"env\": &#123; \"start\": &#123; \"presets\": [ \"react-hmre\" ] &#125; &#125; Final app sourcesThe final source of the article here Save my day: http://survivejs.com/","categories":[{"name":"Javascript","slug":"Javascript","permalink":"http://qetr1ck-op.github.io/categories/Javascript/"}],"tags":[{"name":"Webpack","slug":"Webpack","permalink":"http://qetr1ck-op.github.io/tags/Webpack/"},{"name":"Babel","slug":"Babel","permalink":"http://qetr1ck-op.github.io/tags/Babel/"},{"name":"ES6","slug":"ES6","permalink":"http://qetr1ck-op.github.io/tags/ES6/"},{"name":"React","slug":"React","permalink":"http://qetr1ck-op.github.io/tags/React/"},{"name":"Alt","slug":"Alt","permalink":"http://qetr1ck-op.github.io/tags/Alt/"}]},{"title":"Development with Webpack and React part 1","slug":"Development-with-Webpack","date":"2016-02-07T10:11:41.000Z","updated":"2016-10-05T20:35:31.907Z","comments":true,"path":"2016/02/07/Development-with-Webpack/","link":"","permalink":"http://qetr1ck-op.github.io/2016/02/07/Development-with-Webpack/","excerpt":"Begin with compression of build tools. Conception of bundlers. How to install and base configuration.","text":"Begin with compression of build tools. Conception of bundlers. How to install and base configuration. Task Runners and BundlersWebpack is a powerful module bundler. It hides a lot of power behind configuration. Once you understand its fundamentals, it becomes much easier to use this power. Historically speaking, there have been many build systems. Make is perhaps the best known, and is still a viable option. To make things easier, specialized task runners, such as Grunt and Gulp appeared. Plugins available through npm, made both task runners powerful. Task runners are great tools on a high level. They allow you to perform operations in a cross-platform manner. The problems begin when you need to splice various assets together and produce bundles. This is the reason we have bundlers, such as Browserify or Webpack. Continuing further on this path, JSPM pushes package management directly to the browser. It relies on System.js, a dynamic module loader. Unlike Browserify and Webpack, it skips the bundling step altogether during development. You can generate a production bundle using it, however. BrowserifyBrowserify is one solution to the module problem. It provides a way to bundle CommonJS modules together. You can hook it up with Gulp. There are smaller transformation tools that allow you to move beyond the basic usage. For example, watchify provides a file watcher that creates bundles for you during development. This will save some effort and no doubt is a good solution up to a point. WebpackIn its simplicity, it is a module bundler. It takes a bunch of assets in and outputs assets you can give to your client. Webpack takes a more monolithic approach than Browserify. Whereas Browserify consists of multiple small tools, Webpack comes with a core that provides a lot of functionality out of the box. The core can be extended using specific loaders and plugins. Why use webpack? Hot Module Replacement Dynamic bundle loading Loaders and Plugins Asset Hashing commonJS, AMD, ES6 Live reload Development with webpackObviously for development you already should have node.js, better via nvm, npm, git, .gitignore Install1npm i webpack -D npm maintains a directory where it installs possible executables of packages. You can display the exact path using 1npm bin -&gt; .../node_modules/.bin Directory StructureSet up a structure like this: 1234567/app index.js component.js/build index.htmlpackage.jsonwebpack.config.js Setting Up Webpack ConfigurationFor this purpose we’ll build webpack.config.js. To map our application to build/bundle.js we need configuration like this: 1234567891011121314151617//webpack.config.jsconst path = require('path');const PATHS = &#123; app: path.join(__dirname, 'app'), build: path.join(__dirname, 'build')&#125;;module.exports = &#123; // Entry accepts a path or an object of entries. // The build chapter contains an example of the latter. entry: PATHS.app, output: &#123; path: PATHS.build, filename: 'bundle.js' &#125;&#125;; Difference path.resolve vs path.join Adding a Build ShortcutGiven executing node_modules/.bin/webpack is a little verbose, we should do something about it: 123456//package.json...\"scripts\": &#123; \"build\": \"webpack\"&#125;,... This works because npm adds node_modules/.bin temporarily to the path. As a result, rather than having to write &quot;build&quot;: &quot;node_modules/.bin/webpack&quot;, we can do just &quot;build&quot;: &quot;webpack&quot;. Setting Up webpack-dev-serverwebpack-dev-server is a development server running in-memory. It refreshes content automatically in the browser while you develop your application. This makes it roughly equivalent to tools, such as LiveReload or Browsersync. The greatest advantage Webpack has over these tools is Hot Module Replacement (HMR). In short, it provides a way to patch the browser state without a full refresh. 1npm i webpack-dev-server -D Given our index.html is below ./build, we should letwebpack-dev-server to serve the content from there: 12345678...\"scripts\": &#123; \"build\": \"webpack\", \"start\": \"webpack-dev-server --content-base build\" // --port 3000&#125;,... Splitting Up ConfigurationAs the development setup has certain requirements of its own, we’ll need to split our Webpack configuration. Given Webpack configuration is just JavaScript, there are many ways to achieve this. At least the following ways are feasible: Share configuration through module imports. You can see this approach in action at webpack/react-starter Push configuration to a library which you then consume. Example: HenrikJoreteg/hjs-webpack. Maintain configuration within a single file and branch there. If we trigger a script through npm (i.e., npm run test), npm sets this information in an environment variable. We can match against it and return the configuration we want. To keep things simple and help with the approach, I’ve defined a custom merge function that concatenates arrays and merges objects. This is convenient with Webpack as we’ll soon see: 1npm i webpack-merge --save-dev Next, we need to define some split points to our configuration so we can customize it per npm script: 123456789101112131415161718192021222324252627282930313233//webpack.config.js...const merge = require('webpack-merge');const TARGET = process.env.npm_lifecycle_event;const PATHS = &#123; app: path.join(__dirname, 'app'), build: path.join(__dirname, 'build')&#125;;module.exports = &#123; const common = &#123; // Entry accepts a path or an object of entries. // The build chapter contains an example of the latter. entry: PATHS.app, output: &#123; path: PATHS.build, filename: 'bundle.js' &#125; &#125;; // Default configuration if(TARGET === 'start' || !TARGET) &#123; module.exports = merge(common, &#123;&#125;); &#125; if(TARGET === 'build') &#123; module.exports = merge(common, &#123;&#125;); &#125; Configuring Hot Module Replacement (HMR)Hot Module Replacement gives us simple means to refresh the browser automatically as we make changes. In order to make this work, we’ll need to connect the generated bundle running in-memory to the development server. Webpack uses WebSocket based communication to achieve this. Beyond this we’ll need to enable HotModuleReplacementPlugin to make the setup work: 123456789101112131415161718192021222324252627282930313233343536//webpack.config.js...const webpack = require('webpack');...if(TARGET === 'start' || !TARGET) &#123; module.exports = merge(common, &#123; devServer: &#123; contentBase: PATHS.build, // Enable history API fallback so HTML5 History API based // routing works. This is a good default that will come // in handy in more complicated setups. historyApiFallback: true, hot: true, inline: true, progress: true, // Display only errors to reduce the amount of output. stats: 'errors-only', // Parse host and port from env so this is easy to customize. host: process.env.HOST, port: process.env.PORT &#125;, plugins: [ new webpack.HotModuleReplacementPlugin() // (!) ] &#125;);&#125;... Given we pushed contentBase configuration to JavaScript, we can remove it from package.json: 123456789//package.json...\"scripts\": &#123; \"build\": \"webpack\" \"start\": \"webpack-dev-server\" //--watch-poll --inline --hot&#125;,... Refreshing CSSWhat are loaders Loaders are transformations that are applied on a resource file of your app. They are functions (running in node.js) that take the source of a resource file as the parameter and return the new source. For example, you can use loaders to tell webpack to load CoffeeScript or JSX To load CSS into a project, we’ll need to use a couple of loaders: 1npm i css-loader style-loader --save-dev Now that we have the loaders we need, we’ll need to make sure Webpack is aware of them: 1234567891011121314151617181920//webpack.config.js...const common = &#123; ... &#125;, module: &#123; loaders: [ &#123; // Test expects a RegExp! Note the slashes! test: /\\.css$/, loaders: ['style', 'css'], // Include accepts either a path or an array of paths. include: PATHS.app // It is a good idea to set up include always &#125; ] &#125;&#125;... The loaders are evaluated from right to left. In this case, css-loader gets evaluated first, then style-loader. css-loader will resolve @import and url statements in our CSS files. style-loader deals with require statements in our JavaScript. A similar approach works with CSS preprocessors, like Sass and Less, and their loaders. Enabling SourcemapsIn Webpack this is controlled through the devtool setting: 123456789101112//webpack.config.js...if(TARGET === 'start' || !TARGET) &#123; module.exports = merge(common, &#123; devtool: 'eval-source-map', ... &#125;);&#125;... In this case, we’re using eval-source-map. It builds slowly initially, but it provides fast rebuild speed and yields real files. Faster development specific options, such as cheap-module-eval-source-map and eval, produce lower quality sourcemaps. Especially eval is fast and is the most suitable for large projects. Library and externalsRecommended configuration (only relevant stuff): 1234567891011121314//webpack.config.js&#123; output: &#123; // export itself to a global var libraryTarget: \"var\", // name of the global var: \"Foo\" library: \"Foo\" &#125;, externals: &#123; // require(\"jquery\") is external and available // on the global var jQuery \"jquery\": \"jQuery\" &#125;&#125; NODE_ENV and pluginsWe will use standard for node.js developers variable NODE_ENV and plugin DefinePlugin 12345678910//webpack.config.js...const NODE_ENV = process.env.NODE_ENV || 'development';const webpack = require(webpack);...plugins: [ new webpack.DefinePlugin(&#123; NODE_ENV: JSON.stringify(NODE_ENV) &#125;);] Final app sourcesThe final source of the article here Save my day: http://survivejs.com/","categories":[{"name":"Javascript","slug":"Javascript","permalink":"http://qetr1ck-op.github.io/categories/Javascript/"}],"tags":[{"name":"Webpack","slug":"Webpack","permalink":"http://qetr1ck-op.github.io/tags/Webpack/"},{"name":"Babel","slug":"Babel","permalink":"http://qetr1ck-op.github.io/tags/Babel/"},{"name":"ES6","slug":"ES6","permalink":"http://qetr1ck-op.github.io/tags/ES6/"},{"name":"React","slug":"React","permalink":"http://qetr1ck-op.github.io/tags/React/"},{"name":"Alt","slug":"Alt","permalink":"http://qetr1ck-op.github.io/tags/Alt/"}]},{"title":"Understanding Components approach and Thinking in React","slug":"Understanding-Components-approach-and-Thinking-in-React","date":"2016-02-05T10:34:35.000Z","updated":"2016-10-05T20:37:05.338Z","comments":true,"path":"2016/02/05/Understanding-Components-approach-and-Thinking-in-React/","link":"","permalink":"http://qetr1ck-op.github.io/2016/02/05/Understanding-Components-approach-and-Thinking-in-React/","excerpt":"The parts of a web user interface form the building blocks for both simple websites and modern front-end applications.","text":"The parts of a web user interface form the building blocks for both simple websites and modern front-end applications. Understanding ComponentsThese parts are commonly referred to as UI components or UI widgets. The browser offers many native components and, when these are not enough, custom components like Kendo UI, (Bottsrap)[http://getbootstrap.com/] Semantic UI, UI Kit can be used. UI component is a region in a web page that contains an isolated UI feature that is distinct from everything around it. For example, an HTML &lt;select&gt;element is considered a native HTML UI component. An HTML element can be placed into a web page and a developer gets: An isolated, reusable, and decoupled instance of a &lt;select&gt; with no side effects; A default styled UI element that a user can interact with; Configuration that affects the state via properties that are passed declaratively to the component by way of HTML attributes, text, and child components (i.e. &lt;option&gt;) that can contain attributes and text as well; An API to imperatively program the component, affecting state, via the DOM and JavaScript (i.e. DOM events and methods). The main primitive (speaking about React, Angular &amp; Ember) is this idea of a component. I think everyone has some notion of what a component is. The idea is that it should be an atomic UI piece that is composable and reusable, and should work with other pieces. We’re not designing pages, we’re designing systems of components. Thinking in ReactOne of the many great parts of React is how it makes you think about apps as you build them. I’ll walk through the process of building a searchable product data table using React. Start with a mockImagine that we already have a JSON API which returns some data that looks like this: 12345678[ &#123;category: \"Sporting Goods\", price: \"$49.99\", stocked: true, name: \"Football\"&#125;, &#123;category: \"Sporting Goods\", price: \"$9.99\", stocked: true, name: \"Baseball\"&#125;, &#123;category: \"Sporting Goods\", price: \"$29.99\", stocked: false, name: \"Basketball\"&#125;, &#123;category: \"Electronics\", price: \"$99.99\", stocked: true, name: \"iPod Touch\"&#125;, &#123;category: \"Electronics\", price: \"$399.99\", stocked: false, name: \"iPhone 5\"&#125;, &#123;category: \"Electronics\", price: \"$199.99\", stocked: true, name: \"Nexus 7\"&#125;]; And the mock v.0.0.1 should looks like this: Step 1: break the UI into a component hierarchyThe first thing you’ll want to do is to draw boxes around every component (and subcomponent) in the mock and give them all names. But how do you know what should be its own component? Just use the same techniques for deciding if you should create a new function or object. One such technique is the single responsibility principle, that is, a component should ideally only do one thing. If it ends up growing, it should be decomposed into smaller subcomponents. Components that appear within another component in the mock should appear as a child in the hierarchy: 12345- FilterableProductTable - SearchBar - ProductTable - ProductCategoryRow - ProductRow Step 2: Build a static version in React To build a static version of your app that renders your data model, you’ll want to build components that reuse other components and pass data using props. props are a way of passing data from parent to child. If you’re familiar with the concept of state, don’t use state at all to build this static version. State is reserved only for interactivity, that is, data that changes over time. Since this is a static version of the app, you don’t need it. Step 3: Identify the minimal representation of UI stateTo make your UI interactive, you need to be able to trigger changes to your underlying data model. React makes this easy with state. Think of all of the pieces of data in our example application. We have: The original list of products The search text the user has entered The value of the checkbox The filtered list of products Let’s go through each one and figure out which one is state. Simply ask three questions about each piece of data: Is it passed in from a parent via props? If so, it probably isn’t state. Does it change over time? If not, it probably isn’t state. Can you compute it based on any other state or props in your component? If so, it’s not state. So finally, our state is: The search text the user has entered The value of the checkbox Step 4: Identify where your state should liveThis is often the most challenging part for newcomers to understand, so follow these steps to figure it out: For each piece of state in your application: Identify every component that renders something based on that state. Find a common owner component (a single component above all the components that need the state in the hierarchy). If you can’t find a component where it makes sense to own the state, create a new component simply for holding the state Let’s run through this strategy for our application: ProductTable needs to filter the product list based on state and SearchBar needs to display the search text and checked state. The common owner component is FilterableProductTable. It conceptually makes sense for the filter text and checked value to live in FilterableProductTable We’ve decided that our state lives in FilterableProductTable. First, add a getInitialState() method to FilterableProductTable that returns {filterText: &#39;&#39;, inStockOnly: false} to reflect the initial state of your application. Then, pass filterText and inStockOnly to ProductTable and SearchBar as a prop. Finally, use these props to filter the rows in ProductTable and set the values of the form fields in SearchBar. Step 5: Add inverse data flowNow it’s time to support data flowing the other way: the form components deep in the hierarchy need to update the state in FilterableProductTable. If you try to type or check the box in the previous version of the example, you’ll see that React ignores your input. This is intentional, as we’ve set the value prop of the input to always be equal to the state passed in from FilterableProductTable. Since components should only update their own state, FilterableProductTable will pass a callback to SearchBar that will fire whenever the state should be updated. We can use the onChange event on the inputs to be notified of it. And the callback passed by FilterableProductTable will call setState(), and the app will be updated.","categories":[{"name":"Javascript","slug":"Javascript","permalink":"http://qetr1ck-op.github.io/categories/Javascript/"},{"name":"React","slug":"Javascript/React","permalink":"http://qetr1ck-op.github.io/categories/Javascript/React/"}],"tags":[]},{"title":"First reaction about React.js","slug":"First-look-at-React-js","date":"2016-02-04T15:20:14.000Z","updated":"2016-06-28T07:54:32.314Z","comments":true,"path":"2016/02/04/First-look-at-React-js/","link":"","permalink":"http://qetr1ck-op.github.io/2016/02/04/First-look-at-React-js/","excerpt":"Building a dead simple application with following component structure: 1234- CommentBox - CommentList - Comment - CommentForm","text":"Building a dead simple application with following component structure: 1234- CommentBox - CommentList - Comment - CommentForm Getting startedOpen up public/index.html in your favorite editor. It should look something like this: 123456789101112131415161718192021&lt;!-- index.html --&gt;&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=\"utf-8\" /&gt; &lt;title&gt;React Tutorial&lt;/title&gt; &lt;script src=\"https://cdnjs.cloudflare.com/ajax/libs/react/0.14.7/react.js\"&gt;&lt;/script&gt; &lt;script src=\"https://cdnjs.cloudflare.com/ajax/libs/react/0.14.7/react-dom.js\"&gt;&lt;/script&gt; &lt;script src=\"https://cdnjs.cloudflare.com/ajax/libs/babel-core/5.8.23/browser.min.js\"&gt;&lt;/script&gt; &lt;script src=\"https://cdnjs.cloudflare.com/ajax/libs/jquery/2.1.1/jquery.min.js\"&gt;&lt;/script&gt; &lt;script src=\"https://cdnjs.cloudflare.com/ajax/libs/marked/0.3.2/marked.min.js\"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=\"content\"&gt;&lt;/div&gt; &lt;script type=\"text/babel\" src=\"scripts/example.js\"&gt;&lt;/script&gt; &lt;script type=\"text/babel\"&gt; // To get started with this tutorial running your own code, simply remove // the script tag loading scripts/example.js and start writing code here. &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; We included jQuery here because we want to simplify the code of our future ajax calls, but it’s NOT mandatory for React to work. Your first componentReact is all about modular, composable components. For our comment box example, we’ll have the following component structure: 1234- CommentBox - CommentList - Comment - CommentForm Let’s build the CommentBox component, which is just a simple &lt;div&gt;: 12345678910111213141516171819// tutorial1.jsvar CommentBox = React.createClass(&#123; render: function() &#123; return ( &lt;div className=\"commentBox\"&gt; Hello, world! I am a CommentBox. &lt;/div&gt; /* Imperative way React.createElement('div', &#123;className: \"commentBox\"&#125;, \"Hello, world! I am a CommentBox.\" ) */ ); &#125;&#125;);ReactDOM.render( &lt;CommentBox /&gt;, document.getElementById('content')); React.createClass() to create a new React component. The most important of these methods is called render which returns a tree of React components that will eventually render to HTML. The &lt;div&gt; tags are not actual DOM nodes; they are instantiations of React div components. Composing componentsLet’s build skeletons for CommentList and CommentForm which will, again, be simple &lt;div&gt;s. Add these two components to your file, keeping the existing CommentBox declaration and ReactDOM.render call: 12345678910111213141516171819var CommentList = React.createClass(&#123; render: function() &#123; return ( &lt;div className=\"commentList\"&gt; Hello, world! I am a CommentList. &lt;/div&gt; ); &#125;&#125;);var CommentForm = React.createClass(&#123; render: function() &#123; return ( &lt;div className=\"commentForm\"&gt; Hello, world! I am a CommentForm. &lt;/div&gt; ); &#125;&#125;); Next, update the CommentBox component to use these new components:1234567891011var CommentBox = React.createClass(&#123; render: function() &#123; return ( &lt;div className=\"commentBox\"&gt; &lt;h1&gt;Comments&lt;/h1&gt; &lt;CommentList /&gt; &lt;CommentForm /&gt; &lt;/div&gt; ); &#125;&#125;); Notice how we’re mixing HTML tags and components we’ve built. HTML components are regular React components, just like the ones you define, with one difference. The JSX compiler will automatically rewrite HTML tags to React.createElement(tagName) expressions and leave everything else alone. Using propsLet’s create the Comment component, which will depend on data passed in from its parent. Data passed in from a parent component is available as a property on the child component. These properties are accessed through this.props: 123456789101112var Comment = React.createClass(&#123; render: function() &#123; return ( &lt;div className=\"comment\"&gt; &lt;h2 className=\"commentAuthor\"&gt; &#123;this.props.author&#125; &lt;/h2&gt; &#123;this.props.children&#125; &lt;/div&gt; ); &#125;&#125;); We access named attributes passed to the component as keys on this.props and any nested elements as this.props.children. Component PropertiesNow let’s add some comments within our CommentList: 12345678910var CommentList = React.createClass(&#123; render: function() &#123; return ( &lt;div className=\"commentList\"&gt; &lt;Comment author=\"Pete Hunt\"&gt;This is one comment&lt;/Comment&gt; &lt;Comment author=\"Jordan Walke\"&gt;This is *another* comment&lt;/Comment&gt; &lt;/div&gt; ); &#125;&#125;); For example, we passed Pete Hunt (via an attribute) and This is one comment (via an XML-like child node) to the first Comment. As noted above, the Comment component will access these properties through this.props.author, and this.props.children. Adding MarkdownIn this tutorial we use a third-party library marked which takes Markdown text and converts it to raw HTML: 123456789101112var Comment = React.createClass(&#123; render: function() &#123; return ( &lt;div className=\"comment\"&gt; &lt;h2 className=\"commentAuthor\"&gt; &#123;this.props.author&#125; &lt;/h2&gt; &#123;marked(this.props.children.toString())&#125; // .toString() from React's wrapped text to a raw string &lt;/div&gt; ); &#125;&#125;); But there’s a problem! Our rendered comments look like this in the browser: &lt;p&gt;This is &lt;em&gt;another&lt;/em&gt; comment&lt;/p&gt;. We want those tags to actually render as HTML. That’s React protecting you from an XSS attack. There’s a way to get around it but the framework warns you not to use it: 1234567891011121314151617var Comment = React.createClass(&#123; rawMarkup: function() &#123; var rawMarkup = marked(this.props.children.toString(), &#123;sanitize: true&#125;); return &#123; __html: rawMarkup &#125;; &#125;, render: function() &#123; return ( &lt;div className=\"comment\"&gt; &lt;h2 className=\"commentAuthor\"&gt; &#123;this.props.author&#125; &lt;/h2&gt; &lt;span dangerouslySetInnerHTML=&#123;this.rawMarkup()&#125; /&gt; &lt;/div&gt; ); &#125;&#125;); Mock up the data modelSo far we’ve been inserting the comments directly in the source code. Instead, let’s render a blob of JSON data into the comment list. Eventually this will come from the server, but for now, write it in your source: 1234var data = [ &#123;id: 1, author: \"Pete Hunt\", text: \"This is one comment\"&#125;, &#123;id: 2, author: \"Jordan Walke\", text: \"This is *another* comment\"&#125;]; We need to get this data into CommentList in a modular way. Modify CommentBox and the ReactDOM.render() call to pass this data into the CommentList via props: 12345678910111213141516var CommentBox = React.createClass(&#123; render: function() &#123; return ( &lt;div className=\"commentBox\"&gt; &lt;h1&gt;Comments&lt;/h1&gt; &lt;CommentList data=&#123;this.props.data&#125; /&gt; &lt;CommentForm /&gt; &lt;/div&gt; ); &#125;&#125;);ReactDOM.render( &lt;CommentBox data=&#123;data&#125; /&gt;, document.getElementById('content')); Now that the data is available in the CommentList, let’s render the comments dynamically: 12345678910111213141516var CommentList = React.createClass(&#123; render: function() &#123; var commentNodes = this.props.data.map(function(comment) &#123; return ( &lt;Comment author=&#123;comment.author&#125; key=&#123;comment.id&#125;&gt; &#123;comment.text&#125; &lt;/Comment&gt; ); &#125;); return ( &lt;div className=\"commentList\"&gt; &#123;commentNodes&#125; &lt;/div&gt; ); &#125;&#125;); Fetching from the server.We will remove the data prop and replace it with a URL to fetch: 123ReactDOM.render( &lt;CommentBox url=\"/api/comments\" /&gt;, document.getElementById('content')); This component is different from the prior components because it will have to re-render itself. Reactive stateSo far, based on its props, each component has rendered itself once. props are immutable: they are passed from the parent and are owned by the parent. To implement interactions, we introduce mutable state to the component. this.state is private to the component and can be changed by calling this.setState(). When the state updates, the component re-renders itself. When the server fetches data, we will be changing the comment data we have. Let’s add an array of comment data to the CommentBox component as its state: 1234567891011121314var CommentBox = React.createClass(&#123; getInitialState: function() &#123; return &#123;data: []&#125;; &#125;, render: function() &#123; return ( &lt;div className=\"commentBox\"&gt; &lt;h1&gt;Comments&lt;/h1&gt; &lt;CommentList data=&#123;this.state.data&#125; /&gt; &lt;CommentForm /&gt; &lt;/div&gt; ); &#125;&#125;); getInitialState() executes exactly once during the lifecycle of the component and sets up the initial state of the component. Updating stateWhen the component is first created, we want to GET some JSON from the server and update the state to reflect the latest data, so once it’s fetched, this.state.data will look something like this: 1234[ &#123;\"author\": \"Pete Hunt\", \"text\": \"This is one comment\"&#125;, &#123;\"author\": \"Jordan Walke\", \"text\": \"This is *another* comment\"&#125;] 123456789101112131415161718192021222324252627var CommentBox = React.createClass(&#123; getInitialState: function() &#123; return &#123;data: []&#125;; &#125;, componentDidMount: function() &#123; $.ajax(&#123; url: this.props.url, dataType: 'json', cache: false, success: function(data) &#123; this.setState(&#123;data: data&#125;); &#125;.bind(this), error: function(xhr, status, err) &#123; console.error(this.props.url, status, err.toString()); &#125;.bind(this) &#125;); &#125;, render: function() &#123; return ( &lt;div className=\"commentBox\"&gt; &lt;h1&gt;Comments&lt;/h1&gt; &lt;CommentList data=&#123;this.state.data&#125; /&gt; &lt;CommentForm /&gt; &lt;/div&gt; ); &#125;&#125;); Here, componentDidMount is a method called automatically by React after a component is rendered for the first time. The key to dynamic updates is the call to this.setState(). We replace the old array of comments with the new one from the server and the UI automatically updates itself. Because of this reactivity, it is only a minor change to add live updates. We will use simple polling here but you could easily use WebSockets or other technologies. After refactoring: 12345678910111213141516171819202122232425262728293031323334353637// tutorial14.jsvar CommentBox = React.createClass(&#123; loadCommentsFromServer: function() &#123; $.ajax(&#123; url: this.props.url, dataType: 'json', cache: false, success: function(data) &#123; this.setState(&#123;data: data&#125;); &#125;.bind(this), error: function(xhr, status, err) &#123; console.error(this.props.url, status, err.toString()); &#125;.bind(this) &#125;); &#125;, getInitialState: function() &#123; return &#123;data: []&#125;; &#125;, componentDidMount: function() &#123; this.loadCommentsFromServer(); setInterval(this.loadCommentsFromServer, this.props.pollInterval); &#125;, render: function() &#123; return ( &lt;div className=\"commentBox\"&gt; &lt;h1&gt;Comments&lt;/h1&gt; &lt;CommentList data=&#123;this.state.data&#125; /&gt; &lt;CommentForm /&gt; &lt;/div&gt; ); &#125;&#125;);ReactDOM.render( &lt;CommentBox url=\"/api/comments\" pollInterval=&#123;2000&#125; /&gt;, document.getElementById('content')); Adding new commentsOur CommentForm component should ask the user for their name and comment text and send a request to the server to save the comment: 1234567891011var CommentForm = React.createClass(&#123; render: function() &#123; return ( &lt;form className=\"commentForm\"&gt; &lt;input type=\"text\" placeholder=\"Your name\" /&gt; &lt;input type=\"text\" placeholder=\"Say something...\" /&gt; &lt;input type=\"submit\" value=\"Post\" /&gt; &lt;/form&gt; ); &#125;&#125;); We will be using this.state to save the user’s input as it is entered. We define an initial state with two properties author and text and set them to be empty strings. In our &lt;input&gt; elements, we set the value prop to reflect the state of the component and attach onChange handlers to them. These &lt;input&gt; elements with a value set are called controlled components: 123456789101112131415161718192021222324252627282930var CommentForm = React.createClass(&#123; getInitialState: function() &#123; return &#123;author: '', text: ''&#125;; &#125;, handleAuthorChange: function(e) &#123; this.setState(&#123;author: e.target.value&#125;); &#125;, handleTextChange: function(e) &#123; this.setState(&#123;text: e.target.value&#125;); &#125;, render: function() &#123; return ( &lt;form className=\"commentForm\"&gt; &lt;input type=\"text\" placeholder=\"Your name\" value=&#123;this.state.author&#125; onChange=&#123;this.handleAuthorChange&#125; /&gt; &lt;input type=\"text\" placeholder=\"Say something...\" value=&#123;this.state.text&#125; onChange=&#123;this.handleTextChange&#125; /&gt; &lt;input type=\"submit\" value=\"Post\" /&gt; &lt;/form&gt; ); &#125;&#125;); Events, submitting the formReact attaches event handlers to components using a camelCase naming convention. We attach onChange handlers to the two &lt;input&gt; elements. Let’s make the form interactive. When the user submits the form, we should clear it, submit a request to the server, and refresh the list of comments: 12345678910111213141516171819202122232425262728293031323334353637383940var CommentForm = React.createClass(&#123; getInitialState: function() &#123; return &#123;author: '', text: ''&#125;; &#125;, handleAuthorChange: function(e) &#123; this.setState(&#123;author: e.target.value&#125;); &#125;, handleTextChange: function(e) &#123; this.setState(&#123;text: e.target.value&#125;); &#125;, handleSubmit: function(e) &#123; e.preventDefault(); var author = this.state.author.trim(); var text = this.state.text.trim(); if (!text || !author) &#123; return; &#125; // TODO: send request to the server this.setState(&#123;author: '', text: ''&#125;); &#125;, render: function() &#123; return ( &lt;form className=\"commentForm\" onSubmit=&#123;this.handleSubmit&#125;&gt; &lt;input type=\"text\" placeholder=\"Your name\" value=&#123;this.state.author&#125; onChange=&#123;this.handleAuthorChange&#125; /&gt; &lt;input type=\"text\" placeholder=\"Say something...\" value=&#123;this.state.text&#125; onChange=&#123;this.handleTextChange&#125; /&gt; &lt;input type=\"submit\" value=\"Post\" /&gt; &lt;/form&gt; ); &#125;&#125;); Callbacks as props, pass data from the child component back up to its parentWhen a user submits a comment, we will need to refresh the list of comments to include the new one. It makes sense to do all of this logic in CommentBox since CommentBox owns the state that represents the list of comments. We need to pass data from the child component back up to its parent. We do this in our parent’s render method by passing a new callback handleCommentSubmit into the child, binding it to the child’s onCommentSubmit event. Whenever the event is triggered, the callback will be invoked: 1234567891011121314151617181920212223242526272829303132333435363738var CommentBox = React.createClass(&#123; loadCommentsFromServer: function() &#123; $.ajax(&#123; url: this.props.url, dataType: 'json', cache: false, success: function(data) &#123; this.setState(&#123;data: data&#125;); &#125;.bind(this), error: function(xhr, status, err) &#123; console.error(this.props.url, status, err.toString()); &#125;.bind(this) &#125;); &#125;, //-------------------------------------------------- handleCommentSubmit: function(comment) &#123; // TODO: submit to the server and refresh the list &#125;, //-------------------------------------------------- getInitialState: function() &#123; return &#123;data: []&#125;; &#125;, componentDidMount: function() &#123; this.loadCommentsFromServer(); setInterval(this.loadCommentsFromServer, this.props.pollInterval); &#125;, render: function() &#123; return ( &lt;div className=\"commentBox\"&gt; &lt;h1&gt;Comments&lt;/h1&gt; &lt;CommentList data=&#123;this.state.data&#125; /&gt; //-------------------------------------------------------- &lt;CommentForm onCommentSubmit=&#123;this.handleCommentSubmit&#125; /&gt; //-------------------------------------------------------- &lt;/div&gt; ); &#125;&#125;); Call the callback from the CommentForm when the user submits the form: 123456789101112131415161718192021222324252627282930313233343536373839404142var CommentForm = React.createClass(&#123; getInitialState: function() &#123; return &#123;author: '', text: ''&#125;; &#125;, handleAuthorChange: function(e) &#123; this.setState(&#123;author: e.target.value&#125;); &#125;, handleTextChange: function(e) &#123; this.setState(&#123;text: e.target.value&#125;); &#125;, handleSubmit: function(e) &#123; e.preventDefault(); var author = this.state.author.trim(); var text = this.state.text.trim(); if (!text || !author) &#123; return; &#125; //-------------------------------------------------------- this.props.onCommentSubmit(&#123;author: author, text: text&#125;); //-------------------------------------------------------- this.setState(&#123;author: '', text: ''&#125;); &#125;, render: function() &#123; return ( &lt;form className=\"commentForm\" onSubmit=&#123;this.handleSubmit&#125;&gt; &lt;input type=\"text\" placeholder=\"Your name\" value=&#123;this.state.author&#125; onChange=&#123;this.handleAuthorChange&#125; /&gt; &lt;input type=\"text\" placeholder=\"Say something...\" value=&#123;this.state.text&#125; onChange=&#123;this.handleTextChange&#125; /&gt; &lt;input type=\"submit\" value=\"Post\" /&gt; &lt;/form&gt; ); &#125;&#125;); Now that the callbacks are in place, all we have to do is submit to the server and refresh the list: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647var CommentBox = React.createClass(&#123; loadCommentsFromServer: function() &#123; $.ajax(&#123; url: this.props.url, dataType: 'json', cache: false, success: function(data) &#123; this.setState(&#123;data: data&#125;); &#125;.bind(this), error: function(xhr, status, err) &#123; console.error(this.props.url, status, err.toString()); &#125;.bind(this) &#125;); &#125;, //----------------------------------------------------------- handleCommentSubmit: function(comment) &#123; $.ajax(&#123; url: this.props.url, dataType: 'json', type: 'POST', data: comment, success: function(data) &#123; this.setState(&#123;data: data&#125;); &#125;.bind(this), error: function(xhr, status, err) &#123; console.error(this.props.url, status, err.toString()); &#125;.bind(this) &#125;); &#125;, //----------------------------------------------------------- getInitialState: function() &#123; return &#123;data: []&#125;; &#125;, componentDidMount: function() &#123; this.loadCommentsFromServer(); setInterval(this.loadCommentsFromServer, this.props.pollInterval); &#125;, render: function() &#123; return ( &lt;div className=\"commentBox\"&gt; &lt;h1&gt;Comments&lt;/h1&gt; &lt;CommentList data=&#123;this.state.data&#125; /&gt; &lt;CommentForm onCommentSubmit=&#123;this.handleCommentSubmit&#125; /&gt; &lt;/div&gt; ); &#125;&#125;); Optimization: optimistic updatesIt feels slow to have to wait for the request to complete before your comment appears in the list. We can optimistically add this comment to the list to make the app feel faster: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657var CommentBox = React.createClass(&#123; loadCommentsFromServer: function() &#123; $.ajax(&#123; url: this.props.url, dataType: 'json', cache: false, success: function(data) &#123; this.setState(&#123;data: data&#125;); &#125;.bind(this), error: function(xhr, status, err) &#123; console.error(this.props.url, status, err.toString()); &#125;.bind(this) &#125;); &#125;, handleCommentSubmit: function(comment) &#123; //------------------------------------------------------------------------- var comments = this.state.data; // Optimistically set an id on the new comment. It will be replaced by an // id generated by the server. In a production application you would likely // not use Date.now() for this and would have a more robust system in place. comment.id = Date.now(); var newComments = comments.concat([comment]); this.setState(&#123;data: newComments&#125;); //------------------------------------------------------------------------- $.ajax(&#123; url: this.props.url, dataType: 'json', type: 'POST', data: comment, success: function(data) &#123; this.setState(&#123;data: data&#125;); &#125;.bind(this), error: function(xhr, status, err) &#123; //--------------------------------------------------------------------- this.setState(&#123;data: comments&#125;); //--------------------------------------------------------------------- console.error(this.props.url, status, err.toString()); &#125;.bind(this) &#125;); &#125;, getInitialState: function() &#123; return &#123;data: []&#125;; &#125;, componentDidMount: function() &#123; this.loadCommentsFromServer(); setInterval(this.loadCommentsFromServer, this.props.pollInterval); &#125;, render: function() &#123; return ( &lt;div className=\"commentBox\"&gt; &lt;h1&gt;Comments&lt;/h1&gt; &lt;CommentList data=&#123;this.state.data&#125; /&gt; &lt;CommentForm onCommentSubmit=&#123;this.handleCommentSubmit&#125; /&gt; &lt;/div&gt; ); &#125;&#125;); Demo appThe total result as a demo you can find here. Save my day: Off site","categories":[{"name":"Javascript","slug":"Javascript","permalink":"http://qetr1ck-op.github.io/categories/Javascript/"},{"name":"React","slug":"Javascript/React","permalink":"http://qetr1ck-op.github.io/categories/Javascript/React/"}],"tags":[{"name":"First look","slug":"First-look","permalink":"http://qetr1ck-op.github.io/tags/First-look/"}]},{"title":"Practical design patterns in JavaScript","slug":"Practical-design-patterns-in-JavaScript","date":"2016-02-03T10:43:26.000Z","updated":"2016-10-05T20:40:33.580Z","comments":true,"path":"2016/02/03/Practical-design-patterns-in-JavaScript/","link":"","permalink":"http://qetr1ck-op.github.io/2016/02/03/Practical-design-patterns-in-JavaScript/","excerpt":"One of the most important aspects of writing maintainable code is being able to notice the repeating themes in that code and optimize them. This is an area where knowledge of design patterns can prove invaluable. I take a look at a number of popular JavaScript design patterns and explore why certain patterns may be suitable for your projects.","text":"One of the most important aspects of writing maintainable code is being able to notice the repeating themes in that code and optimize them. This is an area where knowledge of design patterns can prove invaluable. I take a look at a number of popular JavaScript design patterns and explore why certain patterns may be suitable for your projects. Why is it important to understand patterns and be familiar with them?So, why is it important to understand patterns and be familiar with them? Design patterns have three main benefits: Patterns are proven solutions: They provide solid approaches to solving issues in software development using proven techniques that reflect the experience and insights the developers that helped define them bring to the pattern. Patterns can be easily reused: A pattern usually reflects an out of the box solution that can be adapted to suit our own needs. Patterns can be expressive: When we look at a pattern there’s generally a set structure and vocabulary to the solution presented that can help express rather large solutions quite elegantly. Categories Of Design PatternDesign patterns can be broken down into a number of different categories. In this section we’ll review three of these categories: Creation Design PatternsThe basic approach to object creation might otherwise lead to added complexity in a project whilst these patterns aim to solve this problem by controlling the creation process. Some of the patterns that fall under this category are: Constructor, Factory, Prototype, Singleton. Structural Design PatternsTypically identify simple ways to realize relationships between different objects. They help ensure that when one part of a system changes, the entire structure of the system doesn’t need to do the same. Patterns that fall under this category include: Decorator, Facade, Flyweight. Behavioral Design PatternsBehavioral patterns focus on improving the communication between disparate objects in a system. Some behavioral patterns include: Mediator, Observer. Table of 23 Design Patterns mentioned by the GoFI personally found the following table a very useful reminder of what a number of patterns has to offer - it covers the 23 Design Patterns mentioned by the GoF: Creation Design Patterns in depthDevelopers commonly wonder whether there is an ideal pattern or set of patterns they should be using in their workflow. There isn’t a true single answer to this question; each script and web application we work on is likely to have its own individual needs and we need to think about where we feel a pattern can offer real value to an implementation. The Constructor PatternIn classical object-oriented programming languages, a constructor is a special method used to initialize a newly created object once memory has been allocated for it. In JavaScript, as almost everything is an object, we’re most often interested in object constructors. Object Creation12345678// Each of the following options will create a new empty object:var newObject = &#123;&#125;; // orvar newObject = Object.create( Object.prototype ); // orvar newObject = new Object(); Where the Object constructor in the final example creates an object wrapper for a specific value, or where no value is passed, it will create an empty object and return it. Basic ConstructorsBy simply prefixing a call to a constructor function with the keyword new, we can tell JavaScript we would like the function to behave like a constructor and instantiate a new object with the members defined by that function. Inside a constructor, the keyword this references the new object that’s being created: 1234567891011121314151617181920function Car( model, year, miles ) &#123; this.model = model; this.year = year; this.miles = miles; this.toString = function () &#123; return this.model + \" has done \" + this.miles + \" miles\"; &#125;;&#125; // Usage:var civic = new Car( \"Honda Civic\", 2009, 20000 );var mondeo = new Car( \"Ford Mondeo\", 2010, 5000 ); // and then open our browser console to view the// output of the toString() method being called on// these objectsconsole.log( civic.toString() );console.log( mondeo.toString() ); Constructors With PrototypesFunctions, like almost all objects in JavaScript, contain a prototype object. When we call a JavaScript constructor to create an object, all the properties of the constructor’s prototype are then made available to the new object: 1234567891011121314151617181920function Car( model, year, miles ) &#123; this.model = model; this.year = year; this.miles = miles; &#125; // Note here that we are using Object.prototype.newMethod rather than// Object.prototype so as to avoid redefining the prototype objectCar.prototype.toString = function () &#123; return this.model + \" has done \" + this.miles + \" miles\";&#125;; // Usage:var civic = new Car( \"Honda Civic\", 2009, 20000 );var mondeo = new Car( \"Ford Mondeo\", 2010, 5000 ); console.log( civic.toString() );console.log( mondeo.toString() ); Constructors with ES6 class1234567891011121314151617const Car = class &#123; constructor(args) &#123; Object.assign(this, args); &#125; toString() &#123; return `$&#123;this.model&#125; has done $&#123;this.miles&#125; miles`; &#125;&#125;// Usage: var civic = new Car( &#123;model: \"Honda Civic\", year: 2009, miles: 20000&#125; );var mondeo = new Car( &#123;model: \"Honda Civic\", year: 2009, miles: 20000&#125; ); console.log( civic.toString() );console.log( mondeo.toString() ); Constructors with ES6 class for Node.js12// in the end/or better on the beginning share you constructormodule.exports = Car; Constructors in Angular1.x123456789101112131415161718192021222324//Task.factory.js&#123; const app = angular.module('taskManager'); app.factory('Task', () =&gt; &#123; const Task = class &#123; constructor(name) &#123; this.name = name; this.completed = false; &#125; complete() &#123; this.name = true; console.log(`compete task: $&#123;this.name&#125;`); &#125; save() &#123; console.log(`save task: $&#123;this.name&#125;`); &#125; &#125; return Task &#125;)&#125; 12345678910111213141516//Task.controller.js&#123; const app = angular.module('taskManager'); app.controller('taskController'); function taskController(Task) &#123; const ctrl = this; ctrl.tasks = [ new Taks(&#123;name: 'task1'&#125;), new Taks(&#123;name: 'task2', completed: true&#125;) ] &#125; taskController.$inject = ['Task']&#125; The Module PatternModules are an integral piece of any robust application’s architecture and typically help in keeping the units of code for a project both cleanly separated and organized. In JavaScript, there are several options for implementing modules. These include: The Module pattern Object literal notation AMD modules CommonJS modules ES6 modules The Revealing Module PatternWe would simply define all of our functions and variables in the private scope and return an anonymous object with pointers to the private functionality we wished to reveal as public: 123456789101112131415161718192021222324252627282930var myRevealingModule = (function () &#123; var privateVar = \"Ben Cherry\", publicVar = \"Hey there!\"; function privateFunction() &#123; console.log( \"Name:\" + privateVar ); &#125; function publicSetName( strName ) &#123; privateVar = strName; &#125; function publicGetName() &#123; privateFunction(); &#125; // Reveal public pointers to // private functions and properties return &#123; setName: publicSetName, greeting: publicVar, getName: publicGetName &#125;; &#125;)();myRevealingModule.setName( \"Paul Kinlan\" ); The Module Pattern for Node.js123// just export what you needmodule.exports = myRevealingModule(); 1234// Usage:var myModule = require('./myRevealingModule');//module.setName... The Module Pattern for Angular1.x123456789101112131415161718192021//taskRepo.service.js&#123; const = app.module(taskManager); app.servise(taskRepo); function taskRepo($http) &#123; const db = &#123;&#125;; const get = (id) =&gt; &#123; log(`Getting task $&#123;id&#125;`); &#125; const save = (task) =&gt; &#123; log(`Save $&#123;task.nae&#125; to the db`); &#125; return &#123; get, save &#125;; &#125; taskRepo.$inject = ['$http'];&#125; The Singleton PatternIn JavaScript, Singletons serve as a shared resource namespace which isolate implementation code from the global namespace so as to provide a single point of access for functions: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455var mySingleton = (function () &#123; // Instance stores a reference to the Singleton var instance; function init() &#123; // Singleton // Private methods and variables function privateMethod()&#123; console.log( \"I am private\" ); &#125; var privateVariable = \"Im also private\"; var privateRandomNumber = Math.random(); return &#123; // Public methods and variables publicMethod: function () &#123; console.log( \"The public can see me!\" ); &#125;, publicProperty: \"I am also public\", getRandomNumber: function() &#123; return privateRandomNumber; &#125; &#125;; &#125;; return &#123; // Get the Singleton instance if one exists // or create one if it doesn't getInstance: function () &#123; if ( !instance ) &#123; instance = init(); &#125; return instance; &#125; &#125;; &#125;)();// Usage:var singleA = mySingleton.getInstance();var singleB = mySingleton.getInstance();console.log( singleA.getRandomNumber() === singleB.getRandomNumber() ); // true The Singleton Pattern for Node.jsFrom Node.js docs information about caching modules: Modules are cached after the first time they are loaded. This means (among other things) that every call to require(‘foo’) will get exactly the same object returned, if it would resolve to the same file. If you want to have a module execute code multiple times, then export a function, and call that function. 12345// repo.js// just return a function call// for singletonmodule.exports = repo(); 12// import a singletonvar require = repo(); The Singleton Pattern for Angular1.xBy default all service all singleton, because they are providers, more info here The Factory PatternFactory provide a generic interface for creating objects, where we can specify the type of factory object we wish to be created. Imagine that we have a UI factory where we are asked to create a type of UI component. Rather than creating this component directly using the new operator or via another creation constructor, we ask a Factory object for a new component instead. We inform the Factory what type of object is required (e.g Button, Panel) and it instantiates this, returning it to us for use: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162// Types.js - Constructors used behind the scenes // A constructor for defining new carsfunction Car( options ) &#123; // some defaults this.doors = options.doors || 4; this.state = options.state || \"brand new\"; this.color = options.color || \"silver\"; &#125; // A constructor for defining new trucksfunction Truck( options)&#123; this.state = options.state || \"used\"; this.wheelSize = options.wheelSize || \"large\"; this.color = options.color || \"blue\";&#125; // FactoryExample.js // Define a skeleton vehicle factoryfunction VehicleFactory() &#123;&#125; // Define the prototypes and utilities for this factory // Our default vehicleClass is CarVehicleFactory.prototype.vehicleClass = Car; // Our Factory method for creating new Vehicle instancesVehicleFactory.prototype.createVehicle = function ( options ) &#123; switch(options.vehicleType)&#123; case \"car\": this.vehicleClass = Car; break; case \"truck\": this.vehicleClass = Truck; break; //defaults to VehicleFactory.prototype.vehicleClass (Car) &#125; return new this.vehicleClass( options ); &#125;; // Create an instance of our factory that makes carsvar carFactory = new VehicleFactory();var car = carFactory.createVehicle( &#123; vehicleType: \"car\", color: \"yellow\", doors: 6 &#125; ); // Test to confirm our car was created using the vehicleClass/prototype Car // Outputs: trueconsole.log( car instanceof Car ); // Outputs: Car object of color \"yellow\", doors: 6 in a \"brand new\" stateconsole.log( car ); Abstract FactoriesIt is also useful to be aware of the Abstract Factory pattern, which aims to encapsulate a group of individual factories with a common goal. It separates the details of implementation of a set of objects from their general usage: 123456789101112131415161718192021222324252627282930313233343536373839var abstractVehicleFactory = (function () &#123; // Storage for our vehicle types var types = &#123;&#125;; return &#123; getVehicle: function ( type, customizations ) &#123; var Vehicle = types[type]; return (Vehicle ? new Vehicle(customizations) : null); &#125;, registerVehicle: function ( type, Vehicle ) &#123; var proto = Vehicle.prototype; // only register classes that fulfill the vehicle contract if ( proto.drive &amp;&amp; proto.breakDown ) &#123; types[type] = Vehicle; &#125; return abstractVehicleFactory; &#125; &#125;;&#125;)(); // Usage:abstractVehicleFactory.registerVehicle( \"car\", Car );abstractVehicleFactory.registerVehicle( \"truck\", Truck ); // Instantiate a new car based on the abstract vehicle typevar car = abstractVehicleFactory.getVehicle( \"car\", &#123; color: \"lime green\", state: \"like new\" &#125; ); // Instantiate a new truck in a similar mannervar truck = abstractVehicleFactory.getVehicle( \"truck\", &#123; wheelSize: \"medium\", color: \"neon yellow\" &#125; ); Structural Design Patterns in depthStructural design patterns are ones that focus on easing the relationship between different components of an application. They help to provide stability by ensuring that if one part of the app changes, the entire thing doesn’t need to as well. MixinsMixins allow objects to borrow (or inherit) functionality from them with a minimal amount of complexity. Imagine that we define a Mixin containing utility functions in a standard object literal as follows: 123456789101112131415var myMixins = &#123; moveUp: function()&#123; console.log( \"move up\" ); &#125;, moveDown: function()&#123; console.log( \"move down\" ); &#125;, stop: function()&#123; console.log( \"stop! in the name of love!\" ); &#125; &#125;; We can then easily extend the prototype of existing constructor functions to include this behavior using a helper such as the Underscore.js _.extend() method: 1234567891011121314151617181920212223242526// A skeleton carAnimator constructorfunction CarAnimator()&#123; this.moveLeft = function()&#123; console.log( \"move left\" ); &#125;;&#125; // A skeleton personAnimator constructorfunction PersonAnimator()&#123; this.moveRandomly = function()&#123; /*..*/ &#125;;&#125; // Extend both constructors with our Mixin_.extend( CarAnimator.prototype, myMixins );_.extend( PersonAnimator.prototype, myMixins ); // Create a new instance of carAnimatorvar myAnimator = new CarAnimator();myAnimator.moveLeft();myAnimator.moveDown();myAnimator.stop(); // Outputs:// move left// move down// stop! in the name of love! Mixins with ES612Object.assign( CarAnimator.prototype, myMixins );Object.assign( PersonAnimator.prototype, myMixins ); The Decorator PatternThe Decorator pattern isn’t heavily tied to how objects are created but instead focuses on the problem of extending their functionality. Adding new attributes to objects in JavaScript is a very straight-forward process so with this in mind, a very simplistic decorator may be implemented as follows: 12345678910111213141516171819202122232425262728293031323334353637// A vehicle constructorfunction Vehicle( vehicleType )&#123; // some sane defaults this.vehicleType = vehicleType || \"car\"; this.model = \"default\"; this.license = \"00000-000\"; &#125; // Test instance for a basic vehiclevar testInstance = new Vehicle( \"car\" );console.log( testInstance ); // Outputs:// vehicle: car, model:default, license: 00000-000 // Lets create a new instance of vehicle, to be decoratedvar truck = new Vehicle( \"truck\" ); // New functionality we're decorating vehicle withtruck.setModel = function( modelName )&#123; this.model = modelName;&#125;; truck.setColor = function( color )&#123; this.color = color;&#125;; // Test the value setters and value assignment works correctlytruck.setModel( \"CAT\" );truck.setColor( \"blue\" ); console.log( truck ); // Outputs:// vehicle:truck, model:CAT, color: blue Next example, our Decorators are overriding the MacBook() super-class objects .cost() function to return the current price of the Macbook plus the cost of the upgrade being specified. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748// The constructor to decoratefunction MacBook() &#123; this.cost = function () &#123; return 997; &#125;; this.screenSize = function () &#123; return 11.6; &#125;; &#125; // Decorator 1function memory( macbook ) &#123; var v = macbook.cost(); macbook.cost = function() &#123; return v + 75; &#125;; &#125; // Decorator 2function engraving( macbook )&#123; var v = macbook.cost(); macbook.cost = function()&#123; return v + 200; &#125;; &#125; // Decorator 3function insurance( macbook )&#123; var v = macbook.cost(); macbook.cost = function()&#123; return v + 250; &#125;; &#125; var mb = new MacBook();memory( mb );engraving( mb );insurance( mb ); // Outputs: 1522console.log( mb.cost() ); // Outputs: 11.6console.log( mb.screenSize() ); The Decorator Pattern in Angular1.xMore information about decorator method in off documentation or here 1234567891011121314151617181920212223242526272829angular.module( \"Demo\", [] );angular.module( \"Demo\" ).run( function runBlock( greeting ) &#123; console.log( greeting( \"Joanna\" ) ); &#125;); angular.module( \"Demo\" ).factory( \"greeting\", function greetingFactory() &#123; return( greeting ); // I return a greeting for the given name. function greeting( name ) &#123; return( \"Hello \" + name + \".\" ); &#125; &#125;);angular.module( \"Demo\" ).decorator( \"greeting\", function greetingDecorator( $delegate ) &#123; // Return the decorated service. return( decoratedGreeting ); // I append a new message to the existing greeting. function decoratedGreeting( name ) &#123; return( $delegate( name ) + \" How are you doing?\" ); &#125; &#125;); Sub-classingSub-classing is a term that refers to inheriting properties for a new object from a base or superclass object. In traditional object-oriented programming, a class B is able to extend another class A. Here we consider A a superclass and B a subclass of A. As such, all instances of B inherit the methods from A. B is however still able to define its own methods, including those that override methods originally defined by A. We first need a base object:1234567var Person = function( firstName, lastName )&#123; this.firstName = firstName; this.lastName = lastName; this.gender = \"male\"; &#125;; Next, we’ll want to specify a new class (object) that’s a subclass of the existing Person object: 123456789101112131415161718192021// a new instance of Person can then easily be created as follows:var clark = new Person( \"Clark\", \"Kent\" ); // Define a subclass constructor for for \"Superhero\":var Superhero = function( firstName, lastName, powers )&#123; // Invoke the superclass constructor on the new object // then use .call() to invoke the constructor as a method of // the object to be initialized. Person.apply( this, arguments ); // Finally, store their powers, a new array of traits not found in a normal \"Person\" this.powers = powers;&#125;; Superhero.prototype = Object.create( Person.prototype );var superman = new Superhero( \"Clark\", \"Kent\", [\"flight\",\"heat-vision\"] );console.log( superman ); // Outputs Person attributes as well as powers The Facade PatternThis pattern provides a convenient higher-level interface to a larger body of code, hiding its true underlying complexity. Whenever we use jQuery’s $(el).css() or $(el).animate() methods, we’re actually using a Facade - the simpler public interface that avoids us having to manually call the many internal methods in jQuery core required to get some behavior working. In a similar manner, we’re all familiar with jQuery’s $(document).ready(..). Internally, this is actually being powered by a method called bindReady(), which is doing this: 1234567891011121314151617bindReady: function() &#123; ... if ( document.addEventListener ) &#123; // Use the handy event callback document.addEventListener( \"DOMContentLoaded\", DOMContentLoaded, false ); // A fallback to window.onload, that will always work window.addEventListener( \"load\", jQuery.ready, false ); // If IE event model is used &#125; else if ( document.attachEvent ) &#123; document.attachEvent( \"onreadystatechange\", DOMContentLoaded ); // A fallback to window.onload, that will always work window.attachEvent( \"onload\", jQuery.ready ); ... FlyweightThe Flyweight pattern is a classical structural solution for optimizing code that is repetitive, slow and inefficiently shares data. It aims to minimize the use of memory in an application by sharing as much data as possible with related objects There are two ways in which the Flyweight pattern can be applied. The first is at the data-layer, where we deal with the concept of sharing data between large quantities of similar objects stored in memory. The second is at the DOM-layer where the Flyweight can be used as a central event-manager to avoid attaching event handlers to every child element in a parent container we wish to have some similar behavior. Flyweights and sharing dataEach book would thus be represented as follows, prior to any optimization using the Flyweight pattern: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455var Book = function( id, title, author, genre, pageCount,publisherID, ISBN, checkoutDate, checkoutMember, dueReturnDate,availability )&#123; this.id = id; this.title = title; this.author = author; this.genre = genre; this.pageCount = pageCount; this.publisherID = publisherID; this.ISBN = ISBN; this.checkoutDate = checkoutDate; this.checkoutMember = checkoutMember; this.dueReturnDate = dueReturnDate; this.availability = availability; &#125;; Book.prototype = &#123; getTitle: function () &#123; return this.title; &#125;, getAuthor: function () &#123; return this.author; &#125;, getISBN: function ()&#123; return this.ISBN; &#125;, // For brevity, other getters are not shown updateCheckoutStatus: function( bookID, newStatus, checkoutDate, checkoutMember, newReturnDate )&#123; this.id = bookID; this.availability = newStatus; this.checkoutDate = checkoutDate; this.checkoutMember = checkoutMember; this.dueReturnDate = newReturnDate; &#125;, extendCheckoutPeriod: function( bookID, newReturnDate )&#123; this.id = bookID; this.dueReturnDate = newReturnDate; &#125;, isPastDue: function(bookID)&#123; var currentDate = new Date(); return currentDate.getTime() &gt; Date.parse( this.dueReturnDate ); &#125;&#125;; Using thousands of book objects may overwhelm the available memory, but we can optimize our system using the Flyweight pattern to improve this. We can now separate our data into intrinsic and extrinsic states as follows: data relevant to the book object (title, author etc) is intrinsic whilst the checkout data (checkoutMember, dueReturnDate etc) is considered extrinsic. Effectively this means that only one Book object is required for each combination of book properties. it’s still a considerable quantity of objects, but significantly fewer than we had previously. The following single instance of our book meta-data combinations will be shared among all of the copies of a book with a particular title. As we can see, the extrinsic states have been removed: 1234567891011// Flyweight optimized versionvar Book = function ( title, author, genre, pageCount, publisherID, ISBN ) &#123; this.title = title; this.author = author; this.genre = genre; this.pageCount = pageCount; this.publisherID = publisherID; this.ISBN = ISBN; &#125;; Let’s now define a very basic factory. This makes sure that we only create a single copy of each unique intrinsic piece of data: 123456789101112131415161718192021222324// Book Factory singletonvar BookFactory = (function () &#123; var existingBooks = &#123;&#125;, existingBook; return &#123; createBook: function ( title, author, genre, pageCount, publisherID, ISBN ) &#123; // Find out if a particular book meta-data combination has been created before // !! or (bang bang) forces a boolean to be returned existingBook = existingBooks[ISBN]; if ( !!existingBook ) &#123; return existingBook; &#125; else &#123; // if not, let's create a new instance of the book and store it var book = new Book( title, author, genre, pageCount, publisherID, ISBN ); existingBooks[ISBN] = book; return book; &#125; &#125; &#125;; &#125;)(); Next, we need to store the states that were removed from the Book objects somewhere - luckily a manager (which we’ll be defining as a Singleton) can be used to encapsulate them: 123456789101112131415161718192021222324252627282930313233343536373839// BookRecordManager singletonvar BookRecordManager = (function () &#123; var bookRecordDatabase = &#123;&#125;; return &#123; // add a new book into the library system addBookRecord: function ( id, title, author, genre, pageCount, publisherID, ISBN, checkoutDate, checkoutMember, dueReturnDate, availability ) &#123; var book = bookFactory.createBook( title, author, genre, pageCount, publisherID, ISBN ); bookRecordDatabase[id] = &#123; checkoutMember: checkoutMember, checkoutDate: checkoutDate, dueReturnDate: dueReturnDate, availability: availability, book: book &#125;; &#125;, updateCheckoutStatus: function ( bookID, newStatus, checkoutDate, checkoutMember, newReturnDate ) &#123; var record = bookRecordDatabase[bookID]; record.availability = newStatus; record.checkoutDate = checkoutDate; record.checkoutMember = checkoutMember; record.dueReturnDate = newReturnDate; &#125;, extendCheckoutPeriod: function ( bookID, newReturnDate ) &#123; bookRecordDatabase[bookID].dueReturnDate = newReturnDate; &#125;, isPastDue: function ( bookID ) &#123; var currentDate = new Date(); return currentDate.getTime() &gt; Date.parse( bookRecordDatabase[bookID].dueReturnDate ); &#125; &#125;; &#125;)(); Flyweights and the DOMFlyweights can be used to tweak the event bubbling process further, as we will see shortly. Example 1: Centralized event handlingA stateManager name-space is used here to encapsulate our flyweight logic whilst jQuery is used to bind the initial click to a container div. The child element in the container is clicked, we make use of a target check which provides a reference to the element that was clicked, regardless of its parent. We then use this information to handle the click event without actually needing to bind the event to specific children when our page loads. 1234567891011&lt;div id=\"container\"&gt; &lt;div class=\"toggle\" href=\"#\"&gt;More Info (Address) &lt;span class=\"info\"&gt; This is more information &lt;/span&gt;&lt;/div&gt; &lt;div class=\"toggle\" href=\"#\"&gt;Even More Info (Map) &lt;span class=\"info\"&gt; &lt;iframe src=\"http://www.map-generator.net/extmap.php?name=London&amp;amp;address=london%2C%20england&amp;amp;width=500...gt;\"&lt;/iframe&gt; &lt;/span&gt; &lt;/div&gt;&lt;/div&gt; 12345678910111213141516var stateManager = &#123; fly: function () &#123; var self = this; $( \"#container\" ) .unbind() .on( \"click\", \"div.toggle\", function ( e ) &#123; self.handleClick( e.target ); &#125;); &#125;, handleClick: function ( elem ) &#123; elem.find( \"span\" ).toggle( \"slow\" ); &#125;&#125;; Example 2: For performance optimizationUnfortunately, many of us have become used to the idea of wrapping this in $() or jQuery(), which means that a new instance of jQuery is unnecessarily constructed every time, rather than simply doing this: 1234567891011$(\"div\").on( \"click\", function () &#123; console.log( \"You clicked: \" + $( this ).attr( \"id\" ));&#125;); // we should avoid using the DOM element to create a// jQuery object (with the overhead that comes with it)// and just use the DOM element itself like this: $( \"div\" ).on( \"click\", function () &#123; console.log( \"You clicked:\" + this.id );&#125;); Behavior Design Patterns in depthThe observerThe Observer is a design pattern where an object (known as a subject) maintains a list of objects depending on it (observers), automatically notifying them of any changes to state. We can now expand on what we’ve learned to implement the Observer pattern with the following components: Subject: maintains a list of observers, facilitates adding or removing observers Observer: provides a update interface for objects that need to be notified of a Subject’s changes of state ConcreteSubject: broadcasts notifications to observers on changes of state, stores the state of ConcreteObservers ConcreteObserver: stores a reference to the ConcreteSubject, implements an update interface for the Observer to ensure state is consistent with the Subject’s First, let’s model the list of dependent Observers a subject may have: 12345678910111213141516171819202122232425262728293031323334function ObserverList()&#123; this.observerList = [];&#125; ObserverList.prototype.add = function( obj )&#123; return this.observerList.push( obj );&#125;; ObserverList.prototype.count = function()&#123; return this.observerList.length;&#125;; ObserverList.prototype.get = function( index )&#123; if( index &gt; -1 &amp;&amp; index &lt; this.observerList.length )&#123; return this.observerList[ index ]; &#125;&#125;; ObserverList.prototype.indexOf = function( obj, startIndex )&#123; var i = startIndex; while( i &lt; this.observerList.length )&#123; if( this.observerList[i] === obj )&#123; return i; &#125; i++; &#125; return -1;&#125;; ObserverList.prototype.removeAt = function( index )&#123; this.observerList.splice( index, 1 );&#125;; The Subject and the ability to add, remove or notify observers on the observer list: 123456789101112131415161718function Subject()&#123; this.observers = new ObserverList();&#125; Subject.prototype.addObserver = function( observer )&#123; this.observers.add( observer );&#125;; Subject.prototype.removeObserver = function( observer )&#123; this.observers.removeAt( this.observers.indexOf( observer, 0 ) );&#125;; Subject.prototype.notify = function( context )&#123; var observerCount = this.observers.count(); for(var i=0; i &lt; observerCount; i++)&#123; this.observers.get(i).update( context ); &#125;&#125;; Full example here Differences Between The Observer And Publish/Subscribe PatternWhilst the Observer pattern is useful to be aware of, quite often in the JavaScript world, we’ll find it commonly implemented using a variation known as the Publish/Subscribe pattern. The Publish/Subscribe pattern however uses a topic/event channel which sits between the objects wishing to receive notifications (subscribers) and the object firing the event (the publisher). This event system allows code to define application specific events which can pass custom arguments containing values needed by the subscriber. The idea here is to avoid dependencies between the subscriber and publisher. Here is an example of how one might use the Publish/Subscribe if provided with a functional implementation powering publish(),subscribe() and unsubscribe() behind the scenes: 1234567891011121314151617181920212223242526272829var eventBus = (function()&#123; var topics = Object.create(&#123;&#125;); return &#123; subscribe: function(topic, listener) &#123; // Create the topic's object if not yet created if(!topics[topic]) topics[topic] = []; // Add the listener to queue var index = topics[topic].push(listener) -1; // Provide handle back for removal of topic return &#123; unsubscribe: function() &#123; delete topics[topic][index]; &#125; &#125;; &#125;, publish: function(topic, info) &#123; // If the topic doesn't exist, or there's no listeners in queue, just leave if(!topics[topic]) return; // Cycle through topics queue, fire! topics[topic].forEach(function(item) &#123; item(info != undefined ? info : &#123;&#125;); &#125;); &#125; &#125;;&#125;)(); Subscribe in order to be notified for events:123456var subscription = events.subscribe('/page/load', function(obj) &#123; // Do something now that the event has occurred&#125;);// ...sometime later where I no longer want subscription...subscription.unsubscribe(); Publishing: 123events.publish('/page/load', &#123; url: '/some/url/path' // any arguments&#125;);","categories":[],"tags":[{"name":"Patters","slug":"Patters","permalink":"http://qetr1ck-op.github.io/tags/Patters/"}]},{"title":"сусle.js fundamentals","slug":"cycle-js-fundamentals","date":"2016-02-02T14:32:47.000Z","updated":"2016-06-28T09:08:36.377Z","comments":true,"path":"2016/02/02/cycle-js-fundamentals/","link":"","permalink":"http://qetr1ck-op.github.io/2016/02/02/cycle-js-fundamentals/","excerpt":"Cycle.js is a framework where your app is described as a simple function taking an event stream as input and outputting an event stream. Cycle.js builds on RxJS and is as a reactive and functional JavaScript framework. What does that mean?","text":"Cycle.js is a framework where your app is described as a simple function taking an event stream as input and outputting an event stream. Cycle.js builds on RxJS and is as a reactive and functional JavaScript framework. What does that mean? 1.The cycle.js principle: separate logic from effectsSo cycle.js is based on Rxjs and virtual DOM. Get Rxjs from cdn.js:1https://cdnjs.cloudflare.com/ajax/libs/rxjs/4.0.7/rx.min.js Creating element when everything will mount: 1&lt;div id=\"app\"&gt;&lt;div&gt; Now create an observable timer, which will show elapsed seconds: 123456Rx.Observable.timer(0, 1000) .map(i =&gt; `Second elapsed $&#123;i&#125;`) .subsribe(text =&gt; &#123; document.querySelector('#app') .textContent = text; &#125;) So the guide principle in cycle.js is separate logic from affects. Affect is everything what change external world aka changing the DOM. Logic it’s just an event steam. 123456789//Logic (functional), in developer handsRx.Observable.timer(0, 1000) .map(i =&gt; `Second elapsed $&#123;i&#125;`)//Effects (imperative), in framework .subsribe(text =&gt; &#123; document.querySelector('#app') .textContent = text; &#125;)","categories":[{"name":"Javascript","slug":"Javascript","permalink":"http://qetr1ck-op.github.io/categories/Javascript/"}],"tags":[{"name":"Cycle.js","slug":"Cycle-js","permalink":"http://qetr1ck-op.github.io/tags/Cycle-js/"}]},{"title":"The Difference Between Throttling and Debouncing","slug":"The-Difference-Between-Throttling-and-Debouncing","date":"2016-01-11T11:14:13.000Z","updated":"2016-02-11T21:53:30.682Z","comments":true,"path":"2016/01/11/The-Difference-Between-Throttling-and-Debouncing/","link":"","permalink":"http://qetr1ck-op.github.io/2016/01/11/The-Difference-Between-Throttling-and-Debouncing/","excerpt":"One of the biggest mistakes I see when looking to optimize existing code is the absence of the debounce/throttle function.","text":"One of the biggest mistakes I see when looking to optimize existing code is the absence of the debounce/throttle function. Both of them are ways to limit the amount of JavaScript you are executing based on DOM events for performance reasons. But they are, you guessed it, different. ThrottleThrottling enforces a maximum number of times a function can be called over time. Execute this function at most once every 100 milliseconds. Say under normal circumstances you would call this function 1,000 times over 10 seconds. If you throttle it to only once per 100 milliseconds, it would only execute that function at most 100 times 12(10s * 1,000) = 10,000ms10,000ms / 100ms throttling = 100 maximum calls DebounceDebouncing enforces that a function not be called again until a certain amount of time has passed without it being called. Execute this function only if 100 milliseconds have passed without it being called. Perhaps a function is called 1,000 times in a quick burst, dispersed over 3 seconds, then stops being called. If you have debounced it at 100 milliseconds, the function will only fire once, at 3.1 seconds, once the burst is over. Each time the function is called during the burst it resets the debouncing timer. What’s the point?One major use case for these concepts is certain DOM events, like scrolling and resizing. For instance, if you attach a scroll handler to an element, and scroll that element down say 5000px, you’re likely to see 100+ events be fired. If your event handler does a bunch of work (like heavy calculations and other DOM manipulation), you may see performance issues (jank). Quick hit examples: Wait until the user stops resizing the window Don’t fire an ajax event until the user stops typing Measure the scroll position of the page and respond at most every 50ms Ensure good performance as you drag elements around in an app How to do itWith lodashDebounce and throttle: 1234567$(\"body\").on('scroll', _.throttle(function() &#123; // Do expensive things&#125;, 100));$(window).on('resize', _.debounce(function() &#123; // Do expensive things&#125;, 100)); Vanila debounce123456789101112131415161718// Returns a function, that, as long as it continues to be invoked, will not// be triggered. The function will be called after it stops being called for// N milliseconds. If `immediate` is passed, trigger the function on the// leading edge, instead of the trailing.function debounce(func, wait, immediate) &#123; var timeout; return function() &#123; var context = this, args = arguments; var later = function() &#123; timeout = null; if (!immediate) func.apply(context, args); &#125;; var callNow = immediate &amp;&amp; !timeout; clearTimeout(timeout); timeout = setTimeout(later, wait); if (callNow) func.apply(context, args); &#125;;&#125;; You’ll pass the debounce function the function to execute and the fire rate limit in milliseconds. Here’s an example usage: 12345var myEfficientFn = debounce(function() &#123; // All the taxing stuff you do&#125;, 250);window.addEventListener('resize', myEfficientFn); Vanila throttleBelow is an actual throttle function, that fires a message every 250ms by default (rather than at the end of a burst of events): 12345678910111213141516171819202122function throttle(fn, threshhold, scope) &#123; threshhold || (threshhold = 250); var last, deferTimer; return function () &#123; var context = scope || this; var now = Date.now(), args = arguments; if (last &amp;&amp; now &lt; last + threshhold) &#123; // hold on to it clearTimeout(deferTimer); deferTimer = setTimeout(function () &#123; last = now; fn.apply(context, args); &#125;, threshhold); &#125; else &#123; last = now; fn.apply(context, args); &#125; &#125;;&#125; 123$('body').on('mousemove', throttle(function (event) &#123; console.log('tick');&#125;, 1000)); DemoSee the Pen The Difference Between Throttling, Debouncing, and Neither by qetr1ck-op (@qetr1ck-op) on CodePen.","categories":[{"name":"Javascript","slug":"Javascript","permalink":"http://qetr1ck-op.github.io/categories/Javascript/"}],"tags":[{"name":"Performance","slug":"Performance","permalink":"http://qetr1ck-op.github.io/tags/Performance/"}]},{"title":"Units of measurement: 'px', 'em', 'rem' and other","slug":"Units-of-measurement-px-em-rem-and-other","date":"2015-11-11T18:17:58.000Z","updated":"2016-01-31T20:58:58.515Z","comments":true,"path":"2015/11/11/Units-of-measurement-px-em-rem-and-other/","link":"","permalink":"http://qetr1ck-op.github.io/2015/11/11/Units-of-measurement-px-em-rem-and-other/","excerpt":"I will try not only to write about variety of units, but also build a full picture - what and when better to choose.","text":"I will try not only to write about variety of units, but also build a full picture - what and when better to choose. Pixels: px Relatively to font: em Percentage, % Pixels: px Pixel px - is the most basic, absolute and final unit of measurement. The number of pixels on monitor is set in screen resolution configuration. A px is such a one pixel on the screen. All values browser eventually translated into pixels. The main advantage px is clarity and understandability. The px are not relative and don’t allow to set relationships between other dimensions. Relatively to font size: em Measurement in em are relative, they are defined by current context. 1em it’s current font size. Since the value of em is calculated to the current font size, the nested string will 1.5 times larger than parent: Percentage, % The % as the em are relative to current context measurements but there are nuances. Is works different with these properties: margin-left, line-height, width/height with position: fixed. The same example: Mixture of px and em: rem Measure rem defines font size relatively to html element size. See the Pen em vs rem by qetr1ck-op (@qetr1ck-op) on CodePen. Relatively to screen size: vw, vh, vmin, vmax The principles behind vw, vh are to represent percentage of browser viewport width / height. 1vw = 1/100 of the current viewport width, i.e. 1% of width. 10vh = 10/100 of the current viewport height, i.e. 10% of height. After first glance, it seems that vw, vh are redundant, because we already have % measurement system: Limitation of percentage measurement system: viewport height is always hard to measure, as the height of &lt;body&gt; depends on content, not on the dimension of the browser window body measurement cannot be applied to the font-size, because it relates to parent container, not to the dimension of viewport Example, backgrounds and vh: See the Pen Backgrounds and the vh unit by qetr1ck-op (@qetr1ck-op) on CodePen. Example, backgrounds and vw: See the Pen Backgrounds and the vw unit by qetr1ck-op (@qetr1ck-op) on CodePen. Image, vw: See the Pen Images and vw width by qetr1ck-op (@qetr1ck-op) on CodePen. Respectively are related to the maximum or minimum of those widths and heights, depending on which is smaller and larger. For example, if the browser was set to 1100px wide and the 700px tall, 1vmin would be 7px and 1vmax would be 11px. 1vmin = 1vw or 1vh, whichever is smaller1vmax = 1vw or 1vh, whichever is larger","categories":[],"tags":[]},{"title":"TOP 10 mistakes when you develop on AngularJS","slug":"top-10-mistakes-when-you-develop-on-angularjs","date":"2015-09-23T15:40:03.000Z","updated":"2016-10-05T20:43:06.711Z","comments":true,"path":"2015/09/23/top-10-mistakes-when-you-develop-on-angularjs/","link":"","permalink":"http://qetr1ck-op.github.io/2015/09/23/top-10-mistakes-when-you-develop-on-angularjs/","excerpt":"The top 10 mistakes when beginners start to develop on Angular 1.x","text":"The top 10 mistakes when beginners start to develop on Angular 1.x View code app Demo app MVC directory structureWhen you work with MVC / MVW frameworks it’s convenience to structure code by MVC components using the following template: But when project will rise it’s hard to use such structure of folders. You always need to open a few folder at the same time. It isn’t depend what IDE or tool you use (Sublime, VS, Vim with NerdTree) - it’s uncomfortable. To avoid this this developers often use grouping by functionality type: The structure allows more faster search for files which are related to the same feature. It may puzzled at the beginning to share js with html or even with test files. But it saves a lot of time, because it’s more natural. Not scalable ModulesAt the beginning of development all functionalities include in a single module. But manage a such type of code is inconvenient: The next most common approach is grouping objects by type: For better scalability and future re-usability - split code by feature: Minification with Dependency InjectionPattern DI in AngularJS uses out of box. DI helps to keep code clean and helps with testing process. Now AngularJS can’t resolve minificated variables. Easiest solution is: Now Angular can resolve dependency. Another way to handle DI with minification is ng-annotate module. More information on official AngularJS docs Global DependenciesOften when writing AngularJS apps there will be a dependency on an object that binds itself to the global scope. This means it’s available in any AngularJS code, but this breaks the dependency injection model. AngularJS makes it simple to encapsulate these globals into modules so they can be injected like standard AngularJS modules: Less elegant way to define angular-global variable is to do it on $rootScope: Fat controllersIt’s easy, especially when starting out, to put to much logic in the controller. Controller should never do DOM manipulation. That’s work for directives! Likewise business logic should live in services. App data should be also stored and fetched in services, except when we need bound to the $scope. Services are singletons that persist throughout the lifetime of the application, while controllers are transient between application states. If data is stored in the controller then it will need to be fetched from somewhere when it is instantiate. AngularJS works best when following the Single Responsibility Principle (SRP). If the controller is a coordinator between the view and the model, then the amount of logic it has should be minimal. This will also make testing much simpler. Service vs Factory vs ProviderWhat is service: It provides methods to keep, share and organize data across the lifetime of the Angular app Lazy loads, Angular only creates instance of a service when an application component depends on it Singleton object, application component dependent on the service work with the single instance An Angular service can be created in five different ways: service factory provider value constant The most verbose, but also the most comprehensive one is a Provider recipe. The remaining four recipe types — Value, Factory, Service and Constant — are just syntactic sugar on top of a provider recipe. Here is a great examples by Misko: In this case the injectors simply return the value. But what if you want to compute the value? So factory is a function which responsible to creating or/and modifying the value. Notice that the the factory function can ask for other dependencies If you want to be more OO and have a class? But if we want to configure service function before injection? Use provider: As a side note, service, factory, and value are all derived from provider: Always dot in VM $scope’sIn AngularJS every $scope prototypical inherits from its parent $scope till the highest level $rootScope. When looking up for primitive value, the prototype chain is not consulted. If navCtrl updated simultaneously then a prototype chain lookup is required, this won’t happen when the value is an object: Unit testing AngularJS appsJavaScript is a dynamically typed language which comes with great power of expression, but it also comes with almost no help from the compiler.For this reason we feel very strongly that any code written in JavaScript needs to come with a strong set of tests. Not to do an end-to-end testing with ProtractorProtractor uses the Jasmine test framework for defining tests. Protractor has a very robust API for different page interactions.There are other end to end test tools, but Protractor has the advantage of understanding how to work with AngularJS code, especially when it comes to $digest cycles and more. Full-Spectrum Testing with KarmaAwesome post about testing AngularJS with Karma, passage from the post: Karma is an amazing testing tool which is designed to take all the frustration out of setting up a working test runner when testing JavaScript code.Karma works by spawning up each browser that is specified within its configuration file and then running JavaScript code against those browsers to see if they pass certain tests.Communication between Karma and each of the browsers is handled with the karma service running in the terminal using socket.io.Each time a test is run, Karma records its status and then tallies up which browsers have failed for each test and which ones passed and timed out.This makes each test work 100% natively in each browser without the need to test individually.Also, since the Karma service runs on a port and keeps track of browsers by itself, you can easily hook up other browsers and devices to it just by visiting its broadcasting port.Oh and did I mention that Karma is fast? Yeah it’s really fast… Using jQueryAngularJS is a framework for building scalable apps. jQuery is a famous library for simplifying DOM manipulation, event handling, AJAX operation. AngularJS is about architecture of app, not augmenting HTML pages. Try to stop using jQuery and imperative paradigm, just let your code to extend HTML syntax in declarative style. DOM manipulation should only be done in directives, but this doesn’t mean they have to be jQuery wrappers. Always consider what features AngularJS already provides before reaching for jQuery. View code app Demo app Article which saves my day: Original post","categories":[{"name":"Javascript","slug":"Javascript","permalink":"http://qetr1ck-op.github.io/categories/Javascript/"},{"name":"Angular 1.x","slug":"Javascript/Angular-1-x","permalink":"http://qetr1ck-op.github.io/categories/Javascript/Angular-1-x/"}],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"http://qetr1ck-op.github.io/tags/Javascript/"},{"name":"Angular","slug":"Angular","permalink":"http://qetr1ck-op.github.io/tags/Angular/"}]},{"title":"Huston, do we have a problem with promises?","slug":"Huston-do-we-have-a-problem-with-promises","date":"2015-02-02T18:13:01.000Z","updated":"2016-10-05T20:43:37.318Z","comments":true,"path":"2015/02/02/Huston-do-we-have-a-problem-with-promises/","link":"","permalink":"http://qetr1ck-op.github.io/2015/02/02/Huston-do-we-have-a-problem-with-promises/","excerpt":"Many of us are using promises without really understanding them.","text":"Many of us are using promises without really understanding them. Wherefore promises?If you read the literature on promises, you’ll often find references to the pyramid of doom, with some horrible callback-y code that steadily stretches toward the right side of the screen. The whole point of promises is to give us back the language fundamentals we lost when we went async: return, throw, and the stack. But you have to know how to use promises correctly in order to take advantage of them. Rookie mistakesI’m only going to talk about the official spec, as exposed in modern browsers as window.Promise. Not all browsers have window.Promise though, so for a good polyfill, check out the cheekily-named Lie, which is about the smallest spec-compliant library out there. Rookie mistake #1: the promisey pyramid of doomThe most common bad practice is this one:12345678910111213remotedb.allDocs(&#123; include_docs: true, attachments: true&#125;).then(function (result) &#123; var docs = result.rows; docs.forEach(function(element) &#123; localdb.put(element.doc).then(function(response) &#123; alert(\"Pulled doc with id \" + element.doc._id + \" and added to local db.\"); &#125;).catch(function (err) &#123; if (err.status == 409) &#123; localdb.get(element.doc._id).then(function (resp) &#123; localdb.remove(resp._id, resp._rev).then(function (resp) &#123;// et cetera... Yes, it turns out you can use promises as if they were callbacks, and yes, it’s a lot like using a power sander to file your nails, but you can do it. A better style is this one: 123456789remotedb.allDocs(...).then(function (resultOfAllDocs) &#123; return localdb.put(...);&#125;).then(function (resultOfPut) &#123; return localdb.get(...);&#125;).then(function (resultOfGet) &#123; return localdb.put(...);&#125;).catch(function (err) &#123; console.log(err);&#125;); This is called composing promises, and it’s one of the great superpowers of promises. Each function will only be called when the previous promise has resolved, and it’ll be called with that promise’s output. More on that later. Rookie mistake #2: WTF, how do I use forEach() with promises?This is where most people’s understanding of promises starts to break down. As soon as they reach for their familiar forEach() loop (or for loop, or while loop), they have no idea how to make it work with promises. So they write something like this: 12345678// I want to remove() all docsdb.allDocs(&#123;include_docs: true&#125;).then(function (result) &#123; result.rows.forEach(function (row) &#123; db.remove(row.doc); &#125;);&#125;).then(function () &#123; // I naively believe all docs have been removed() now!&#125;); What’s the problem with this code? The problem is that the first function is actually returning undefined, meaning that the second function isn’t waiting for db.remove() to be called on all the documents. In fact, it isn’t waiting on anything, and can execute when any number of docs have been removed! The TLDR of all this is that forEach()/for/while are not the constructs you’re looking for. You want Promise.all(): 1234567db.allDocs(&#123;include_docs: true&#125;).then(function (result) &#123; return Promise.all(result.rows.map(function (row) &#123; return db.remove(row.doc); &#125;));&#125;).then(function (arrayOfResults) &#123; // All docs have really been removed() now!&#125;); What’s going on here? Basically Promise.all() takes an array of promises as input, and then it gives you another promise that only resolves when every one of those other promises has resolved. It is the asynchronous equivalent of a for-loop. Rookie mistake #3: forgetting to add .catch()Many developers forget to add a .catch() anywhere in their code. Unfortunately this means that any thrown errors will be swallowed, and you won’t even see them in your console. This can be a real pain to debug. 12345somePromise().then(function () &#123; return anotherPromise();&#125;).then(function () &#123; return yetAnotherPromise();&#125;).catch(console.log.bind(console)); // &lt;-- this is badass Rookie mistake #4: using “deferred”If you are writing that word in your code you are doing something wrong. Here’s how to avoid it. First off, most promise libraries give you a way to import promises from third-party libraries. For instance, Angular’s $q module allows you to wrap non-$q promises using $q.when(). So Angular users can wrap PouchDB promises this way: 1$q.when(db.put(doc)).then(/* ... */); // &lt;-- this is all the code you need Another strategy is to use the revealing constructor pattern, which is useful for wrapping non-promise APIs. For instance, to wrap a callback-based API like Node’s fs.readFile(), you can simply do: 12345678new Promise(function (resolve, reject) &#123; fs.readFile('myfile.txt', function (err, file) &#123; if (err) &#123; return reject(err); &#125; resolve(file); &#125;);&#125;).then(/* ... */) Rookie mistake #5: using side effects instead of returningWhat’s wrong with this code? 123456somePromise().then(function () &#123; someOtherPromise();&#125;).then(function () &#123; // Gee, I hope someOtherPromise() has resolved! // Spoiler alert: it hasn't.&#125;); Seriously, this is the one weird trick that, once you understand it, will prevent all of the errors I’ve been talking about. As I said before, the magic of promises is that they give us back our precious return and throw. But what does this actually look like in practice? What can we do here? There are three things: 1.return another promise2.return a synchronous value (or undefined)3.throw a synchronous error Return another promiseThis is a common pattern you see in the promise literature, as in the composing promises example above: 12345getUserByName('nolan').then(function (user) &#123; return getUserAccountById(user.id);&#125;).then(function (userAccount) &#123; // I got a user account!&#125;); Notice that I’m returning the second promise – that return is crucial. If I didn’t say return, then the getUserAccountById() would actually be a side effect, and the next function would receive undefined instead of the userAccount. Return a synchronous value (or undefined)Returning undefined is often a mistake, but returning a synchronous value is actually an awesome way to convert synchronous code into promisey code. For instance, let’s say we have an in-memory cache of users. We can do: 12345678getUserByName('nolan').then(function (user) &#123; if (inMemoryCache[user.id]) &#123; return inMemoryCache[user.id]; // returning a synchronous value! &#125; return getUserAccountById(user.id); // returning a promise!&#125;).then(function (userAccount) &#123; // I got a user account!&#125;); For this reason, I make it a personal habit to always return or throw from inside a then() function. I’d recommend you do the same. Throw a synchronous errorLet’s say we want to throw a synchronous error in case the user is logged out. It’s quite easy: 12345678910111213getUserByName('nolan').then(function (user) &#123; if (user.isLoggedOut()) &#123; throw new Error('user logged out!'); // throwing a synchronous error! &#125; if (inMemoryCache[user.id]) &#123; return inMemoryCache[user.id]; // returning a synchronous value! &#125; return getUserAccountById(user.id); // returning a promise!&#125;).then(function (userAccount) &#123; // I got a user account!&#125;).catch(function (err) &#123; // Boo, I got an error!&#125;); Advanced mistake #1: don’t know about Promise.resolveAs I showed above, promises are very useful for wrapping synchronous code as asynchronous code. However, if you find yourself typing this a lot: 123new Promise(function (resolve, reject) &#123; resolve(someSynchronousValue);&#125;).then(/* ... */); You can express this more succinctly using Promise.resolve(): 1Promise.resolve(someSynchronousValue).then(/* ... */); 123456//more verbose exapmlefunction somePromiseAPI() &#123; return Promise.resolve().then(function () &#123; return 'foo'; &#125;).then(/* ... */);&#125; Advanced mistake #2: catch() isn’t exactly like then(null, cb)If you’re wondering why they’re not equivalent, consider what happens if the first function throws an error: 1234567891011somePromise().then(function () &#123; throw new Error('oh noes');&#125;).catch(function (err) &#123; // I caught your error! :)&#125;);somePromise().then(function () &#123; throw new Error('oh noes');&#125;, function (err) &#123; // I didn't catch your error! :(&#125;); As it turns out, when you use the then(resolveHandler, rejectHandler) format, the rejectHandler won’t actually catch an error if it’s thrown by the resolveHandler itself. Advanced mistake #3: use promise in paralel or promises vs promise factoriesThat is, you want something like Promise.all(), but which doesn’t execute the promises in parallel. You might naïvely write something like this: 1234567function executeSequentially(promises) &#123; var result = Promise.resolve(); promises.forEach(function (promise) &#123; result = result.then(promise); &#125;); return result;&#125; The promises you pass in to executeSequentially() will still execute in parallel. The reason this happens is that you don’t want to operate over an array of promises at all. Per the promise spec, as soon as a promise is created, it begins executing. So what you really want is an array of promise factories. A promise factory is very simple, though – it’s just a function that returns a promise: 123function myPromiseFactory() &#123; return somethingThatCreatesAPromise();&#125; 1234567function executeSequentially(promiseFactories) &#123; var result = Promise.resolve(); promiseFactories.forEach(function (promiseFactory) &#123; result = result.then(promiseFactory); &#125;); return result;&#125; Why does this work? It works because a promise factory doesn’t create the promise until it’s asked to. It works the same way as a then function – in fact, it’s the same thing! Another task, create code which will download recurses from array URLs in sequence: 1234let urls = [ 'user.json', 'guest.json']; 1234567891011121314151617// begin of the chainlet chain = Promise.resolve();let results = [];// in loop add tasks in chainurls.forEach(function(url) &#123; // task are added in sequence chain = chain .then(() =&gt; httpGet(url)) .then((result) =&gt; &#123; results.push(result); &#125;);&#125;);// result of promiseschain.then(console.log.bind(console)); The same approach with parallel: 12Promise.all( urls.map(httpGet) ) .then(console.log.bind(console)); Advanced mistake #4: okay, what if I want the result of two promises?Often times, one promise will depend on another, but we’ll want the output of both promises. For instance: 12345getUserByName('nolan').then(function (user) &#123; return getUserAccountById(user.id);&#125;).then(function (userAccount) &#123; // dangit, I need the \"user\" object too!&#125;); Wanting to be good JavaScript developers and avoid the pyramid of doom, we might just store the user object in a higher-scoped variable: 1234567var user;getUserByName('nolan').then(function (result) &#123; user = result; return getUserAccountById(user.id);&#125;).then(function (userAccount) &#123; // okay, I have both the \"user\" and the \"userAccount\"&#125;); My recommended strategy: just let go of your preconceptions and embrace the pyramid: 12345getUserByName('nolan').then(function (user) &#123; return getUserAccountById(user.id).then(function (userAccount) &#123; // okay, I have both the \"user\" and the \"userAccount\" &#125;);&#125;); If the indentation ever becomes an issue, then you can do what JavaScript developers have been doing since time immemorial, and extract the function into a named function: 123456789101112131415function onGetUserAndUserAccount(user, userAccount) &#123; return doSomething(user, userAccount);&#125;function onGetUser(user) &#123; return getUserAccountById(user.id).then(function (userAccount) &#123; return onGetUserAndUserAccount(user, userAccount); &#125;);&#125;getUserByName('nolan') .then(onGetUser) .then(function () &#123; // at this point, doSomething() is done, and we are back to indentation 0&#125;); As your promise code starts to get more complex, you may find yourself extracting more and more functions into named functions. I find this leads to very aesthetically-pleasing code, which might look like this: 1234putYourRightFootIn() .then(putYourRightFootOut) .then(putYourRightFootIn) .then(shakeItAllAbout); Save my day: * [We have a problem with promises](http://pouchdb.com/2015/05/18/we-have-a-problem-with-promises.html)","categories":[{"name":"Javascript","slug":"Javascript","permalink":"http://qetr1ck-op.github.io/categories/Javascript/"},{"name":"Web Api","slug":"Javascript/Web-Api","permalink":"http://qetr1ck-op.github.io/categories/Javascript/Web-Api/"}],"tags":[{"name":"Promise","slug":"Promise","permalink":"http://qetr1ck-op.github.io/tags/Promise/"}]},{"title":"Full-screen scrolling page effects with fullPage.js","slug":"Full-screen-scrolling-page-effects-with-fullPage-js","date":"2014-12-21T09:34:48.000Z","updated":"2016-01-31T21:23:30.359Z","comments":true,"path":"2014/12/21/Full-screen-scrolling-page-effects-with-fullPage-js/","link":"","permalink":"http://qetr1ck-op.github.io/2014/12/21/Full-screen-scrolling-page-effects-with-fullPage-js/","excerpt":"A simple and easy to use jQuery plugin to create full-screen effects.","text":"A simple and easy to use jQuery plugin to create full-screen effects. Plugin is capable of: Scroll within sections using they mouse wheel scroll Scroll within sections and within sliders using the arrow keys and the pageUp and pageDown keys Use multiple callbacks Use touch events for mobile and tablet devices Add a menu linked to to the sections Support for CSS3 animations with jQuery fallback Use of anchor links (#) for each section and slides Support for scrolling inside each section Resize the sections size as well as the text when resizing the browser’s window Autoadjust itself to fit the current section/slide when resizing the browser’s window Admit some options such as the scrolling easing, the background color of the slides, the scrolling speed, loop options, callbacks and the vertical align of the text within the sections For more investigation follow Live Demo or another demo or visit https://github.com/alvarotrigo/fullPage.js#fullpagejs","categories":[{"name":"Javascript","slug":"Javascript","permalink":"http://qetr1ck-op.github.io/categories/Javascript/"}],"tags":[{"name":"Inspiration","slug":"Inspiration","permalink":"http://qetr1ck-op.github.io/tags/Inspiration/"}]},{"title":"Organizing an application using AMD with require.js","slug":"Organizing-an-application-using-AMD-with-require-js","date":"2014-12-20T10:39:53.000Z","updated":"2016-10-05T20:45:07.419Z","comments":true,"path":"2014/12/20/Organizing-an-application-using-AMD-with-require-js/","link":"","permalink":"http://qetr1ck-op.github.io/2014/12/20/Organizing-an-application-using-AMD-with-require-js/","excerpt":"RequireJS is a JavaScript file and module loader. It is optimized for in-browser use, but it can be used in other JavaScript environments","text":"RequireJS is a JavaScript file and module loader. It is optimized for in-browser use, but it can be used in other JavaScript environments What is AMD?Asynchronous Module Definitions designed to load modular code asynchronously in the browser and server. It is actually a fork of the Common.js specification. Many script loaders have built their implementations around AMD, seeing it as the future of modular JavaScript development. Example File StructureThere are many different ways to lay out your files and I believe it is actually dependent on the size and type of the project. In the example below views and templates are mirrored in file structure. 123456789101112131415161718192021222324252627282930313233343536373839/* File Structure├── imgs├── css│ └── style.css├── templates│ ├── projects│ │ ├── list.html│ │ └── edit.html│ └── users│ ├── list.html│ └── edit.html├── js│ ├── libs│ │ ├── jquery│ │ │ ├── jquery.min.js│ │ ├── backbone│ │ │ ├── backbone.min.js│ │ └── underscore│ │ │ ├── underscore.min.js│ ├── models│ │ ├── users.js│ │ └── projects.js│ ├── collections│ │ ├── users.js│ │ └── projects.js│ ├── views│ │ ├── projects│ │ │ ├── list.js│ │ │ └── edit.js│ │ └── users│ │ ├── list.js│ │ └── edit.js│ ├── router.js│ ├── app.js│ ├── main.js // Bootstrap│ ├── order.js //Require.js plugin│ └── text.js //Require.js plugin└── index.html*/ Bootstrapping your applicationUsing Require.js we define a single entry point on our index page. We should setup any useful containers that might be used by our Backbone views. Note: The data-main attribute on our single script tag tells Require.js to load the script located at “js/main.js”. It automatically appends the “.js” 12345678910111213141516&lt;!doctype html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;title&gt;Jackie Chan&lt;/title&gt; &lt;!-- Load the script \"js/main.js\" as our entry point --&gt; &lt;script data-main=\"js/main\" src=\"js/libs/require/require.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div id=\"container\"&gt; &lt;div id=\"menu\"&gt;&lt;/div&gt; &lt;div id=\"content\"&gt;&lt;/div&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; You should most always end up with quite a light weight index file. You can serve this off your server and then the rest of your site off a CDN ensuring that everything that can be cached, will be. What does the require.js look like?Our bootstrap file will be responsible for configuring Require.js and loading initially important dependencies. In the example below we configure Require.js to create a shortcut alias to commonly used scripts such as jQuery, Underscore and Backbone. Note: Modules are loaded relatively to the boot strap and always append with .js. So the module app will load app.js which is in the same directory as the bootstrap. 123456789101112131415161718192021// Filename: main.js// Require.js allows us to configure shortcut alias// There usage will become more apparent further along in the tutorial.require.config(&#123; paths: &#123; jquery: 'libs/jquery/jquery', underscore: 'libs/underscore/underscore', backbone: 'libs/backbone/backbone' &#125;&#125;);require([ // Load our app module and pass it to our definition function 'app',], function(App)&#123; // The \"app\" dependency is passed in as \"App\" App.initialize();&#125;); This awesome article saves my day.","categories":[{"name":"Javascript","slug":"Javascript","permalink":"http://qetr1ck-op.github.io/categories/Javascript/"}],"tags":[{"name":"async","slug":"async","permalink":"http://qetr1ck-op.github.io/tags/async/"}]},{"title":"Firebase and AngularJS","slug":"Firebase-and-AngularJS","date":"2014-12-10T21:45:45.000Z","updated":"2016-06-28T09:04:01.511Z","comments":true,"path":"2014/12/10/Firebase-and-AngularJS/","link":"","permalink":"http://qetr1ck-op.github.io/2014/12/10/Firebase-and-AngularJS/","excerpt":"AngularFire is the officially supported AngularJS binding for Firebase. The combination of Angular and Firebase provides a three-way data binding between your HTML, your, JavaScript, and the Firebase database.","text":"AngularFire is the officially supported AngularJS binding for Firebase. The combination of Angular and Firebase provides a three-way data binding between your HTML, your, JavaScript, and the Firebase database. Why, Who and WHAT?Firebase is developed by Google and its a rich API to store and sync data in realtime. Firebase has full-featured libraries for support all major web framework. AngularFire is the officially supported by AngularJS binding fir Firebase. The combination of Angular and Firebase provides a three-way between your Firebase data store and Angular’s bindings (i.e. JavaScript variables to DOM elements). Quick startSimply include source from CDN: 12345678&lt;!-- Angular --&gt;&lt;script src=\"https://ajax.googleapis.com/ajax/libs/angularjs/1.3.2/angular.min.js\"&gt;&lt;/script&gt;&lt;!-- Firebase --&gt;&lt;script src=\"https://cdn.firebase.com/js/client/2.0.4/firebase.js\"&gt;&lt;/script&gt;&lt;!-- AngularFire --&gt;&lt;script src=\"https://cdn.firebase.com/libs/angularfire/0.9.0/angularfire.min.js\"&gt;&lt;/script&gt; Also sources are available via Bower or Yeoman scaffolding. Next we need to include ANgularFire service by adding firebase as a module dependency in our app. And than inject dependency the $firebase into a controller, factory, or service. 123456var app = angular.module('app', ['firebase']);app.controller('MainCtrl', function($scope, $firebase) &#123; var ref = new Fireabase(\"https://&lt;your-firebase&gt;.firebaseio.com/\"); var sync = $firebase(ref);&#125;) Synchronize data with $asObject(). Thee way data-bindingKeep in mind that $firebase does not actually download any data from the Firebase server until $asArray() or $asObject() are called. The full list for $firebase methods can be found in the API documentation. Synchronizing changes from the server is pretty magical via $save(). To achieve three-way data binding simply call $bindTo() on a synchronized object and now any changes in the DOM are pushed to Angular, and then automatically to Firebase. And inversely, any changes on the server get pushed into Angular and straight to the DOM: See the Pen Synchronize data with $asObject(). Thee way data-binding by qetr1ck-op (@qetr1ck-op) on CodePen.# Synchronize Arrays with $asArray()Synchronized arrays should be used for any list of objects that will be sorted, iterated and have unique IDs. The complete list of methods can be found in the API for $FirebaseArray.The contents of this array are synchronized with a remote server, and AngularFire controls adding, removing, and ordering the elements. Because of this special arrangement, AngularFire provides the concurrency safe methods $add(), $remove(), and $save() to modify the array elements.See the Pen Synchronize Arrays with $asArray() by qetr1ck-op (@qetr1ck-op) on CodePen. Save my day: AngularFire Development Guide","categories":[{"name":"Angular 1.x","slug":"Angular-1-x","permalink":"http://qetr1ck-op.github.io/categories/Angular-1-x/"}],"tags":[{"name":"Firebase","slug":"Firebase","permalink":"http://qetr1ck-op.github.io/tags/Firebase/"}]},{"title":"Awesome terminal emulator for Windows","slug":"Awesome-terminal-emulator-for-Windows","date":"2014-12-02T19:15:37.000Z","updated":"2016-10-05T20:45:38.820Z","comments":true,"path":"2014/12/02/Awesome-terminal-emulator-for-Windows/","link":"","permalink":"http://qetr1ck-op.github.io/2014/12/02/Awesome-terminal-emulator-for-Windows/","excerpt":"Cmder is a software package created out of pure frustration over the absence of nice console emulators on Windows. It is based on amazing software, and spiced up with the Monokai color scheme and a custom prompt layout. Looking sexy from the start. Instruction to add cmder to context menu.","text":"Cmder is a software package created out of pure frustration over the absence of nice console emulators on Windows. It is based on amazing software, and spiced up with the Monokai color scheme and a custom prompt layout. Looking sexy from the start. Instruction to add cmder to context menu. Download here","categories":[{"name":"CLI","slug":"CLI","permalink":"http://qetr1ck-op.github.io/categories/CLI/"}],"tags":[]},{"title":"Browsers Layout engines","slug":"Browsers-Layout-engines","date":"2014-12-02T19:01:39.000Z","updated":"2016-10-05T20:45:59.828Z","comments":true,"path":"2014/12/02/Browsers-Layout-engines/","link":"","permalink":"http://qetr1ck-op.github.io/2014/12/02/Browsers-Layout-engines/","excerpt":"The list of popular layout engines","text":"The list of popular layout engines (the full list you may find in the end of the article): Gecko is developed by the Mozilla Foundation. Presto is developed by Opera Software for use in Opera. Development stopped as Opera transitions to Blink. Trident is developed by Microsoft for use in the Windows version of their web browser, from Internet Explorer 4 to the present time. WebKit used in Apple Safari, Chromium and Google Chrome. EdgeHTML in Microsoft Edge Blink is a 2013 fork of WebKit by Google used in Chromium, Google Chrome and Opera. Full list of Browsers Layout engines on wiki","categories":[{"name":"Web","slug":"Web","permalink":"http://qetr1ck-op.github.io/categories/Web/"}],"tags":[{"name":"Browser","slug":"Browser","permalink":"http://qetr1ck-op.github.io/tags/Browser/"}]},{"title":"git pull vs git fetch","slug":"git-pull-vs-git-fetch","date":"2014-11-24T21:46:41.000Z","updated":"2016-01-31T21:57:08.566Z","comments":true,"path":"2014/11/24/git-pull-vs-git-fetch/","link":"","permalink":"http://qetr1ck-op.github.io/2014/11/24/git-pull-vs-git-fetch/","excerpt":"What is the differences between “git pull” and “git fetch”?","text":"What is the differences between “git pull” and “git fetch”? When you use git pull, Git tries to automaticaly do your work with for you. Git will do git merge any new pulled commits into to the branch you are currently working in. git pull is what you should to do to bring a local-branch up-to-date with its remore version, while also updating your other remote-tracking branches. When you use git fetch, Git gather any commits from the target branch that do not exist in your current branch and stores them in your local repository. However, it does not merge them with your current branch. You can do git fetch in any time to update your remote-tracking branches under refs/remote/s/heads. This operation never changes any of your own local branches under refs/heads","categories":[{"name":"Git","slug":"Git","permalink":"http://qetr1ck-op.github.io/categories/Git/"}],"tags":[]},{"title":"JSONP","slug":"JSONP","date":"2014-10-29T19:44:50.000Z","updated":"2016-02-02T22:28:03.693Z","comments":true,"path":"2014/10/29/JSONP/","link":"","permalink":"http://qetr1ck-op.github.io/2014/10/29/JSONP/","excerpt":"JSONP is really simple trick to overcome XMLHttpRequest same origin domain policy - you can’t send AJAX (XMLHttpRequest) request to different domain.","text":"JSONP is really simple trick to overcome XMLHttpRequest same origin domain policy - you can’t send AJAX (XMLHttpRequest) request to different domain. So instead of using XMLHttpRequest we have to use script HTML tag to get data from another domain. And yes, it’s sound weird. Example: 123456(function() &#123;truevar script = document.createElement('script');truescript.type = 'text/javascript'truescript.src = 'http://www.someWebApiServer.com/some-data?callback=my_callback';truedocument.getElementsByTagName('head')[0].appendChild(elem)&#125;)() Notice the my_callback function over here? So when when server receives request and finds callback parameter - instead of returning plain JSON object : 1&#123;foo: bar&#125; It will return callback: 123456my_callback(&#123;foo: bar&#125;) // 'Response from another domain: with &#123;foo: bar&#125;//it's already implementedfunction my_callback(resp) &#123;trueconsole.log('Response from another domain: ' + resp);&#125; The profit is that we get automatic callback my_callback that will be triggered once we get the data. So JSONP is callback and script tags. Basic JavaScript example (simple Twitter feed using JSONP):1234567891011&lt;div id = 'twitterFeed'&gt;&lt;/div&gt;&lt;script&gt;function myCallback(dataWeGotViaJsonp)&#123; var text = ''; var len = dataWeGotViaJsonp.length; for(var i=0;i&lt;len;i++)&#123; twitterEntry = dataWeGotViaJsonp[i]; text += ' + twitterEntry['text']'; &#125; document.getElementById('twitterFeed').innerHTML = text;&#125;","categories":[{"name":"Javascript","slug":"Javascript","permalink":"http://qetr1ck-op.github.io/categories/Javascript/"}],"tags":[{"name":"XHR","slug":"XHR","permalink":"http://qetr1ck-op.github.io/tags/XHR/"}]},{"title":"git pull VS git pull --rebase","slug":"git-pull-versus-git-pull-rebase","date":"2014-10-16T19:05:58.000Z","updated":"2016-10-16T20:44:42.409Z","comments":true,"path":"2014/10/16/git-pull-versus-git-pull-rebase/","link":"","permalink":"http://qetr1ck-op.github.io/2014/10/16/git-pull-versus-git-pull-rebase/","excerpt":"","text":"Short answergit pull = git fetch + git merge git pull --rebase = git fetch + git rebaseFor more detail info how git pull and git rabase differs continue reading. Long answer: “git merge” and “git rebase”Suppose originally there were a 3 commits, A, B, C: Then developer Dan create commit D, and developer Ed created commit E: Obviously, this conflict should be resolve somehow. For this are 2 ways: git merge Both commits D and E are still here, but git create merge commit M that inherits changes from both D and E. However, this create diamond shape, which many people find confusing. git rebase Git create commit R which is identical to merge commit M. But, we get rid of commit E, like it have never existed (shown by dots). Because of this, E should be local to developer Ed and should have never pushed to any repository. Advantage of rebase is that it’s avoided, and history stays nice straight line - most developers love that! Make my day: Discussion on StackOverflow","categories":[],"tags":[{"name":"Git","slug":"Git","permalink":"http://qetr1ck-op.github.io/tags/Git/"}]},{"title":"OOP in prototype style","slug":"OOP-in-prototype-style","date":"2014-09-15T19:40:38.000Z","updated":"2016-10-05T20:49:36.444Z","comments":true,"path":"2014/09/15/OOP-in-prototype-style/","link":"","permalink":"http://qetr1ck-op.github.io/2014/09/15/OOP-in-prototype-style/","excerpt":"The main point is that one object can be prototype of another object. That means if property isn’t found in the object - than it takes from prototype object. In JavaScript this implementation is at the language level.","text":"The main point is that one object can be prototype of another object. That means if property isn’t found in the object - than it takes from prototype object. In JavaScript this implementation is at the language level. Inheritance through link __proto__Inheritance in JavaScript is realized via special property __proto__ (In specs EcmaScript the name is [[Prototype]]). In ES5 the property was available in Chrome / Firefox and Safari, but in other browser was hidden. ES6 includes __proto__ property as standard. In this article, for more efficient way I’ll use __proto__ property, but for legacy you should use Object.getPrototypeOf() If the object, for instance rabbit, has a special link __proto__ to another object animal, that mean, that all property which are searched in the rabbit, will be also searched in the animal object. We can write any object in prototype object: So, object pointed by __proto__ it is his prototype. In another words prototype it’s “Backup Storage of Properties and Methods”, which automatically used in the search. Method hasOwnPropertySimple loop for...in or loop through iterable objects (Array, Mas, Set, arguments object) can’t distinguish between the own properties and properties of his prototype For iterate only through own properties with obj.hasOwnProperty(prop): Prototype ChainIn object __proto__ can be another __proto__ object and so on. For example, the inheritance chain of three object donkey -&gt; winnie -&gt; owl: Methods to work with __proto__By historical reason we have methods to get/set __proto__ property: Object.create(proto, descriptors) creates new empty object with __proto__ object: This method only allows create new empty object. He can’t change prototype of an existing object. Create an empty collection, without prototype chain with Object.create(null): Exercise with __proto__1.1 1.2 F.prototypeProperty prototype can point on any object but it has sense, when it’s assigned to function-constructor. When project is creating via new, in his __proto__ object writes link from prototype of function-constructor. Exercises with prototype and new1.1 1.2 1.3 1.4 1.5 2.1 “Classes”. Where methods come from empty {}Lets begin with creating empty object end call method toString: It’s obviously, that { } is empty. But then who generates method toString()? Off-course this makes method toString() which is built-in Object.prototype. In details it works like this: Creating object literal obj = { } means shorthand form for obj = new Object(), were Object is built-in function-constructor for objects While new Object invokes, new object has receives obj.__proto__ = Object.prototype. obj.toString === Object.prototype.toString method will be taken from prototype object. Build-in “Classes”The same methods use in arrays Array, functions Function and other objects. Build-in methods are in Array.prototype, Function.prototype, etc. Thats why everywhere JS developers like to say that “All objects inherit from Object“. But it’s a quite incorrect. All objects inherit from Object.prototype via __proto__ link. In some cases, method can overrides. For example, “class” Array has it’s own toString, which is in Array.prototype.toString: Exercises with overriding prototype1.1 1.2 1.3 1.4 Declares own “Classes”For create “Class” you need: Declare function-constructor Write all required methods and properties in prototype Property constructorProperty constructor is in every function, even if it isn’t declare. So concept is next, the property constructor should have link to function, which creates the object: But when you overriding the prototype, property constructor disappears: So how it works: animal -&gt; Animal.prototype (new Object) -&gt; Object.prototype Prototype OOPClasses it isn’t only function-constructor with prototype, it’s also additional opportunities for OOP development. For example two “Classes” and realization of “Class inheritance”: SaveMyDay: on","categories":[{"name":"Javascript","slug":"Javascript","permalink":"http://qetr1ck-op.github.io/categories/Javascript/"},{"name":"OOP","slug":"Javascript/OOP","permalink":"http://qetr1ck-op.github.io/categories/Javascript/OOP/"}],"tags":[{"name":"OOP","slug":"OOP","permalink":"http://qetr1ck-op.github.io/tags/OOP/"}]},{"title":"Centering in CSS","slug":"Centering-in-CSS","date":"2014-09-08T19:54:09.000Z","updated":"2016-10-05T20:49:58.491Z","comments":true,"path":"2014/09/08/Centering-in-CSS/","link":"","permalink":"http://qetr1ck-op.github.io/2014/09/08/Centering-in-CSS/","excerpt":"A fast guide to help centering everything with CSS.","text":"A fast guide to help centering everything with CSS. So you want to centering ..? Horizontally Is it inline or inline-* elements(like text or links) ? Is it a block-level element? Is there are more than one block level element? Vertically Is it inline or inline-* elements(like text or links) ? Is it single line? Is it multiple line? Is it a block-level element? Do you know the height of the element? Is the element of unknown height? Both Horizontally and Vertically Is the element of fixed width and height? Is the element of unknown width and height? Horizontally Is it inline or inline-* elements(like text or links)? You can easily center inline elements horizontally, within a block-level parent element, with: 123.center-children &#123;truetext-align: center&#125; See the Pen AqsLf by qetr1ck-op (@qetr1ck-op) on CodePen. This works for inline, inline-block, inline-table, inline-flex, etc. Is it a block-level element? You can centered a block-level by give it margin-left and margin-right of auto (and it has a set width, otherwise it would be full and wouldn’t need centering). This often is doing with shorthand like this: 123.center &#123;truemargin: 0 auto;&#125; See the Pen Kxemr by qetr1ck-op (@qetr1ck-op) on CodePen. This will work no matter what the width of the block level element you’re centering, or the parent. Is there are more than one block level element? If you have more than two or more block-level elements than need to be centered horizontal in a row you should making them a different display type. Here is an example of making them inline-block or flexbox: See the Pen Centering Row of Blocks by qetr1ck-op (@qetr1ck-op) on CodePen. Vertically Is it single line? Sometimes inline / text elements can appear vertically centered with equal padding above and below them: See the Pen Centering text (kinda) with Padding by qetr1ck-op (@qetr1ck-op) on CodePen. If padding is not an option for some reason, there is a trick to making line-height equal to the height: See the Pen Centering a line with line-height by qetr1ck-op (@qetr1ck-op) on CodePen. Is it multiple lines? Equal padding on top and bottom still works for multiple lines of text, but if this isn’t enough, perhaps the element text can be a table cell, ether literally or made to behavior like one with CSS: See the Pen Centering text (kinda) with Padding by qetr1ck-op (@qetr1ck-op) on CodePen. If sometime table-like is out, perhaps you could use flex-box: See the Pen Vertical Center Multi Lines of Text with Flexbox by qetr1ck-op (@qetr1ck-op) on CodePen..If both these techniques are out, you could employ the “ghost element” term:See the Pen Ghost Centering Multi Line Text by qetr1ck-op (@qetr1ck-op) on CodePen. Is block-level element? Vertical centering block-level component. Do you know the height of element? If you know the height, you can center vertically like: See the Pen Center Block with Fixed Height by qetr1ck-op (@qetr1ck-op) on CodePen. Is it the element with unknown height? It’s still possible to vertically center it: See the Pen Center Block with Unknown Height by qetr1ck-op (@qetr1ck-op) on CodePen. Can you use flex-box? Surprise-surprise with this technique it’s so ease: See the Pen Center Block with Unknown Height with Flexbox by qetr1ck-op (@qetr1ck-op) on CodePen. Both Horizontally and VerticallyYou can combine the tehnique above in any order to get perfectly centered elements. But you can next grouped tehniques: Is the element of fixed width and height? Using negative margins equels to half of width and heigh. After you get absolutely positioned it at 50% / 50%: See the Pen Center Block with Fixed Height and Width by qetr1ck-op (@qetr1ck-op) on CodePen. Is the element of unknown width and height? If you don’t know the width and height - you can the tranform property with negative translate of 50% in both directions: See the Pen Center Block with Unknown Height and Width by qetr1ck-op (@qetr1ck-op) on CodePen. Can you use flexbox? To center in both directions with flexbox, you need to use two centering properties: See the Pen Center Block with Unknown Height and Width with Flexbox by qetr1ck-op (@qetr1ck-op) on CodePen. So now you can easy to say, that centering in CSS isn’t a big deal. Save My Day: on Css tricks css-tricks","categories":[{"name":"CSS","slug":"CSS","permalink":"http://qetr1ck-op.github.io/categories/CSS/"}],"tags":[]},{"title":"Medium-Style Page Transition","slug":"Medium-Style-Page-Transition","date":"2014-09-01T19:50:51.000Z","updated":"2016-10-05T20:51:56.035Z","comments":true,"path":"2014/09/01/Medium-Style-Page-Transition/","link":"","permalink":"http://qetr1ck-op.github.io/2014/09/01/Medium-Style-Page-Transition/","excerpt":"An article on how to achieve Medium’s next page transition effect—an effect that can be seen by clicking anywhere on the “Read Next” footer at the bottom of the page. This effect is characterized by the lower article easing upward as the current article fades up and out.","text":"An article on how to achieve Medium’s next page transition effect—an effect that can be seen by clicking anywhere on the “Read Next” footer at the bottom of the page. This effect is characterized by the lower article easing upward as the current article fades up and out. The page makes Ajax request to static json files. Page state is managed by using the PushState API and location.hash. All photos are from Unsplash. In this article, I will outline how to achieve Medium’s page transition effect—an effect that can be seen by clicking anywhere on the “Read Next” footer at the bottom of the page. This effect is characterized by the lower article easing upward as the current article fades up and out. See the animation below for an illustration of this effect. HTMLIn this demo, the page first loads with barebones HTML, which we’ll use as a template that will be filled in later with Ajax’d-in data. Below is what our &lt;body&gt; looks like on initial page load. One main &lt;article&gt; tag. Pretty simple, eh? 123456&lt;body&gt; &lt;article class='page hidden'&gt; &lt;div class='big-image'&gt;&lt;/div&gt; &lt;div class='content'&gt;&lt;/div&gt; &lt;/article&gt;&lt;/body&gt; Once the content is Ajax’d-in, the looks something like so: 1234&lt;body&gt; &lt;article class='page current'&gt;&lt;!--other HTML --&gt;&lt;/article&gt; &lt;article class='page next '&gt;&lt;!--other HTML --&gt;&lt;/article&gt;&lt;body&gt; The page currently being viewed has a class of current, and the next article has a class of next. The next article only has its large image being shown at the bottom of the page, which, when clicked on, brings it into focus. CSSThe styles in this demo which control the article transitions are both applied dynamically via jQuery’s css() method, as well as by applying classes to the &lt;article&gt; elements using jQuery’s addClass() method: 1234567891011121314151617article.page.hidden &#123; display: none&#125;article.page.content-hidden .content &#123; display: none&#125;article.fade-up-out &#123; opacity: 0; transform: scale(0.8) translate3d(0, -10%, 0); transition: all 450ms cubic-bezier(0.165, 0.840, 0.440, 1.000);&#125;article.easing-upward &#123; transition: all 450ms cubic-bezier(0.165, 0.840, 0.440, 1.000);&#125; JavaScriptBefore getting into the Javascript code, I want to first outline the algorithm used to transition the next article upward, and transition the current article up and away. So, when user click on next article: Disable scroll on the page Fade current article to opacity of 0, a scale of .8 and move it upward by 10% Show the article content, give it smooth transition, then move it upward to the top of the window After 500ms: Non-Closure Example: 123456function nonClosure() &#123; //encapsulation var date = new Date(); //Varible lost after function returns return date.getMilliseconds();&#125; Closure function:123456789function trueClosure() &#123; //encapsulation var date = new Date(); //Varible stays around even after function returns //nested function (!) return function() &#123; return date.getMilliseconds(); &#125;&#125; Closure function example2:123456789101112function trueClosure() &#123; //encapsulation var date = new Date(); //Varible stays around even after function returns //nested function (!) function getTime() &#123; return date.getMilliseconds(); &#125; return &#123; getTime: getTime &#125;&#125; Animation Code12345678910111213141516171819202122232425 ArticleAnimator.animatePage = function(callback)&#123; var self = this; var translationValue = this.$next.get(0).getBoundingClientRect().top; this.canScroll = false; this.$current.addClass('fade-up-out'); this.$next.removeClass('content-hidden next') .addClass('easing-upward') .css(&#123; \"transform\": \"translate3d(0, -\"+ translationValue +\"px, 0)\" &#125;); setTimeout(function()&#123; scrollTop(); self.$next.removeClass('easing-upward') self.$current.remove(); self.$next.css(&#123; \"transform\": \"\" &#125;); self.$current = self.$next.addClass('current'); self.canScroll = true; self.currentPostIndex = self.nextPostIndex( self.currentPostIndex ); callback(); &#125;, self.animationDuration + 300 );&#125; Throughout the CSS and JavaScript code in order to achieve fluid animation I’m using transform: translate3d(x, y, z) to move DOM elements. By doing this, we hardware accelarate the DOM elements movement. This method is preferred over animating an element using top / left or transform: translateX(x) / translateY(y), which are not hardware accelarated by default.","categories":[{"name":"CSS","slug":"CSS","permalink":"http://qetr1ck-op.github.io/categories/CSS/"}],"tags":[]},{"title":"Article Intro Effects Examples","slug":"Article-Intro-Effects-Examples","date":"2014-08-19T09:46:59.000Z","updated":"2016-01-31T20:58:58.444Z","comments":true,"path":"2014/08/19/Article-Intro-Effects-Examples/","link":"","permalink":"http://qetr1ck-op.github.io/2014/08/19/Article-Intro-Effects-Examples/","excerpt":"Most of the effects we tried are highly experimental; animating large images can become a bit sluggish, also because a couple of transitions happening at the same time. The effect gets triggered when scrolling begins or when the button is clicked.","text":"Most of the effects we tried are highly experimental; animating large images can become a bit sluggish, also because a couple of transitions happening at the same time. The effect gets triggered when scrolling begins or when the button is clicked. The images in the demos are from amazing Unsplash, a fantastic place to find high-quality public domain photos. You can see an example here The first effect pushes the image to the top together with the title, and a new title element slides in with the content. The second demo shows the effect that fades out the image at the bottom and fades in the resting content. We do this by using a pseudo element with a linear gradient. The third effect slices the main image into two where the first half moves up and the second one slides down, giving space for the title to enlarge. The forth effect cuts away the image and pushes the title to the side. The fifth effect is similar to the previous one but here we fix the image to the side and allow the content to flow on the right hand side The next demo moves the image up and reveals a grid where the current main image will scale up into the grid. This could be a great idea for showing related posts right in the header. The last effect is an attempt to imitate the cool effect - the fullscreen image becomes a top bar and the content slides in. SaveMyDay: on tympanus.net","categories":[{"name":"CSS","slug":"CSS","permalink":"http://qetr1ck-op.github.io/categories/CSS/"}],"tags":[]},{"title":"Canvas-off icon navigation with an animated border effect","slug":"Canvas-off-icon-navigation-with-an-animated-border-effect","date":"2014-08-11T18:11:48.000Z","updated":"2016-10-05T20:53:28.542Z","comments":true,"path":"2014/08/11/Canvas-off-icon-navigation-with-an-animated-border-effect/","link":"","permalink":"http://qetr1ck-op.github.io/2014/08/11/Canvas-off-icon-navigation-with-an-animated-border-effect/","excerpt":"","text":"The MarkupThe HTML structure for our menu will consist of a nav element that will contain a trigger anchor and an unordered list with the menu items which will consist of icons: 123456789&lt;nav id=\"bt-menu\" class=\"bt-menu\"&gt; [&lt;span&gt;Menu&lt;/span&gt;](#)* [Zoom](#)* [Refresh](#)* [Lock](#)* [Sound](#)* [Favorite](#)&lt;/nav&gt; The CSSLet’s use the border-box box-sizing: 12345*,*:after,*::before &#123; box-sizing: border-box;&#125; And let’s set some styles for the body and the main container: 1234567body &#123; background: #04a466;&#125;.container &#123; padding: 80px;&#125; The padding will help providing some space around our content so that when the border appears, we guarantee that there is enough space around. The main menu element will have position fixed so that, no matter where we are in the page, the border is always around the viewport. We set an initial border style which we will transition to a bigger border. Setting the initial height to 0 will make sure that the menu does not cover anything initially. The “backward” or closing height transition will have a delay of 0.3s: 123456789101112.bt-menu &#123; position: fixed; top: 0; left: 0; width: 100%; height: 0; border-width: 0px; border-style: solid; border-color: #333; background-color: rgba(0,0,0,0); transition: border-width 0.3s, background-color 0.3s, height 0s 0.3s;&#125; When we open the menu, we’ll set the height to 100% (but we won’t transition that property) and the border will animate to 90px on the left side and 30px on all the other sides. The background color will be semi-transparent using an RGBA value: 123456.bt-menu.bt-menu-open &#123; height: 100%; border-width: 30px 30px 30px 90px; background-color: rgba(0,0,0,0.3); transition: border-width 0.3s, background-color 0.3s;&#125; Now we have to use a little trick. We will add another element using JavaScript which will server as a dummy container covering the whole page except the border. This will allow us to distinguish where we are clicking in order to close the whole thing. We don’t want the menu to close when clicking on the border but only when clicking in the space between: 1234.bt-overlay &#123; position: absolute; width: 100%;&#125; When we open the menu, this element will have full height: 123.bt-menu-open .bt-overlay &#123; height: 100%;&#125; Let’s style that little trigger element. We’ll give it a fixed position and we’ll show it in the top left corner of the page: 123456789.bt-menu-trigger &#123; position: fixed; top: 15px; left: 20px; display: block; width: 50px; height: 50px; cursor: pointer;&#125; The trigger anchor itself will serve as a container and the span will be the middle line of our hamburger menu icon. So we position it in the middle by setting the top to 50% and giving it a negative top margin of half of its height: 12345678910111213.bt-menu-trigger span &#123; position: absolute; top: 50%; left: 0; display: block; width: 100%; height: 4px; margin-top: -2px; background-color: #fff; font-size: 0px; user-select: none; transition: background-color 0.3s;&#125; When opening the menu, we will make a cross out of the icon. The other two lines will be created by pseudo-elements and when the menu is open, the middle line will disappear: 123.bt-menu-open .bt-menu-trigger span &#123; background-color: transparent;&#125; Now, let’s create the two other lines. The pseudo-elements will be positioned absolutely and their height is going to be the same like of their parent by setting it to 100%: 12345678910.bt-menu-trigger span:before,.bt-menu-trigger span:after &#123; position: absolute; left: 0; width: 100%; height: 100%; background: #fff; content: ''; transition: transform 0.3s;&#125; For positioning them correctly, we’ll use translateY: 1234567.bt-menu-trigger span:before &#123; transform: translateY(-250%);&#125;.bt-menu-trigger span:after &#123; transform: translateY(250%);&#125; The cross will be formed when opening the menu by setting the translateY to 0 and rotating the pseudo-elements accordingly: 1234567.bt-menu-open .bt-menu-trigger span:before &#123; transform: translateY(0) rotate(45deg);&#125;.bt-menu-open .bt-menu-trigger span:after &#123; transform: translateY(0) rotate(-45deg);&#125; The unordered list with our icons will also have a fixed position and we’ll set it to the left side of the window: 12345678910.bt-menu ul &#123; position: fixed; top: 75px; left: 0; margin: 0; padding: 0; width: 90px; list-style: none; backface-visibility: hidden;&#125; Let’s set the list items and the anchors to display: block and give them full width: 123456.bt-menu ul li,.bt-menu ul li a &#123; display: block; width: 100%; text-align: center;&#125; Each list item will be hidden initially and the opacity will be 0. The “backward” transition of the visibility will be delayed until all the other transitions of the transform and the opacity are finished: 123456.bt-menu ul li &#123; padding: 16px 0; opacity: 0; visibility: hidden; transition: transform 0.3s, opacity 0.2s, visibility 0s 0.3s;&#125; Now we will transform each of the list items differently so that they are all placed in the middle and to the left until they are hidden (-100% on the Y axis): 12345678910111213141516171819.bt-menu ul li:first-child &#123; transform: translate3d(-100%,200%,0);&#125;.bt-menu ul li:nth-child(2) &#123; transform: translate3d(-100%,100%,0);&#125;.bt-menu ul li:nth-child(3) &#123; transform: translate3d(-100%,0,0);&#125;.bt-menu ul li:nth-child(4) &#123; transform: translate3d(-100%,-100%,0);&#125;.bt-menu ul li:nth-child(5) &#123; transform: translate3d(-100%,-200%,0);&#125; When opening the menu, the list items will become visible (instantly, because we are not setting a transition for it) and they will fade in. They will also move to their original positions by setting the transform3d to 0 for all axes: 123456.bt-menu.bt-menu-open ul li &#123; visibility: visible; opacity: 1; transition: transform 0.3s, opacity 0.3s; transform: translate3d(0,0,0);&#125; Now, let’s style the anchors. We will use an icon font and include the font reference and the icon classes in another CSS which will be provided by a service like Fontastic or the IcoMoon app. By setting the font size of the anchor to 0 and make it transparent, we’ll hide the text: 1234567.bt-menu ul li a &#123; display: block; outline: none; color: transparent; text-decoration: none; font-size: 0px;&#125; We’ll reset the font size for the pseudo-element which contains the icon. We’ll need to use a pixel-based value because the main element has a font-size of 0 so ems won’t work here: .bt-menu ul li a:before { color: #04a466; font-size: 48px; transition: color 0.2s;} On hover we’ll make them white: 1234.bt-menu ul li a:hover:before,.bt-menu ul li a:focus:before &#123; color: #fff;&#125; And last, but not least, we want the icons to be smaller on mobile screens: 12345@media screen and (max-height: 31.125em) &#123; .bt-menu ul li a:before &#123; font-size: 32px; &#125;&#125; The JavascriptOur script is pretty straightforward; when we click on the trigger anchor, we toggle the class bt-menu-open and bt-menu-close on the nav element. When we click on the overlay, we will close the menu. We’ll also add some touch support: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647(function() &#123; // http://stackoverflow.com/a/11381730/989439 function mobilecheck() &#123; var check = false; (function(a)&#123;if(/(android|ipad|playbook|silk|bb\\d+|meego).+mobile|avantgo|bada\\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\\.(browser|link)|vodafone|wap|windows (ce|phone)|xda|xiino/i.test(a)||/1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\\-(n|u)|c55\\/|capi|ccwa|cdm\\-|cell|chtm|cldc|cmd\\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\\-s|devi|dica|dmob|do(c|p)o|ds(12|\\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\\-|_)|g1 u|g560|gene|gf\\-5|g\\-mo|go(\\.w|od)|gr(ad|un)|haie|hcit|hd\\-(m|p|t)|hei\\-|hi(pt|ta)|hp( i|ip)|hs\\-c|ht(c(\\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\\-(20|go|ma)|i230|iac( |\\-|\\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\\/)|klon|kpt |kwc\\-|kyo(c|k)|le(no|xi)|lg( g|\\/(k|l|u)|50|54|\\-[a-w])|libw|lynx|m1\\-w|m3ga|m50\\/|ma(te|ui|xo)|mc(01|21|ca)|m\\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\\-2|po(ck|rt|se)|prox|psio|pt\\-g|qa\\-a|qc(07|12|21|32|60|\\-[2-7]|i\\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\\-|oo|p\\-)|sdk\\/|se(c(\\-|0|1)|47|mc|nd|ri)|sgh\\-|shar|sie(\\-|m)|sk\\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\\-|v\\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\\-|tdg\\-|tel(i|m)|tim\\-|t\\-mo|to(pl|sh)|ts(70|m\\-|m3|m5)|tx\\-9|up(\\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\\-|your|zeto|zte\\-/i.test(a.substr(0,4)))check = true&#125;)(navigator.userAgent||navigator.vendor||window.opera); return check; &#125; function init() &#123; var menu = document.getElementById( 'bt-menu' ), trigger = menu.querySelector( 'a.bt-menu-trigger' ), // event type (if mobile, use touch events) eventtype = mobilecheck() ? 'touchstart' : 'click', resetMenu = function() &#123; classie.remove( menu, 'bt-menu-open' ); classie.add( menu, 'bt-menu-close' ); &#125;, closeClickFn = function( ev ) &#123; resetMenu(); overlay.removeEventListener( eventtype, closeClickFn ); &#125;; var overlay = document.createElement('div'); overlay.className = 'bt-overlay'; menu.appendChild( overlay ); trigger.addEventListener( eventtype, function( ev ) &#123; ev.stopPropagation(); ev.preventDefault(); if( classie.has( menu, 'bt-menu-open' ) ) &#123; resetMenu(); &#125; else &#123; classie.remove( menu, 'bt-menu-close' ); classie.add( menu, 'bt-menu-open' ); overlay.addEventListener( eventtype, closeClickFn ); &#125; &#125;); &#125; init();&#125;)(); View DemoView demo SaveMyDay: on tympanus.net","categories":[{"name":"Javascript","slug":"Javascript","permalink":"http://qetr1ck-op.github.io/categories/Javascript/"},{"name":"CSS","slug":"Javascript/CSS","permalink":"http://qetr1ck-op.github.io/categories/Javascript/CSS/"}],"tags":[]},{"title":"Maybe, You don't need jQuery","slug":"Maybe-you-don-t-need-jQuery","date":"2014-08-10T15:08:20.000Z","updated":"2016-02-02T22:28:03.694Z","comments":true,"path":"2014/08/10/Maybe-you-don-t-need-jQuery/","link":"","permalink":"http://qetr1ck-op.github.io/2014/08/10/Maybe-you-don-t-need-jQuery/","excerpt":"Do you really need to use jQuery methods instead of vanila Javascript","text":"Do you really need to use jQuery methods instead of vanila Javascript When should I use jQuery Do you need a quick prototype or proof of concept? Do you use jQuety plugin?2.1 jQuery Plugins, jQuery Widgets, Twitter Bootstrap, etc… Do you use a Library or Fremework than depends on jQuery?3.1 Backbone.js, Ember.js, etc… Do any of your browser not “Cut the mustard” (come up to expectations, reach the required standard) ? Featured not supported Netievly in &lt;= IE8 Alternative Libraries Zepto.js Min.js Native Selectors12345//jQuery:$('#datepicker');$('input');$('.date');$('input.date'); 123456//Native :document.getElementById('datepicker');document.getElementsByTagName('input');document.getElementsByClassName('.date');document.querySelectorAll('input.date');document.querySelector('input.date'); Each1234//Each jQuery:$('input.date').each(function(el, i) &#123; $(el).text('Hello ' + i);&#125;) 123456789101112131415161718192021222324252627282930//Native #1: var nodes = document.querySelectorAll('input.date');for (var i = 0; i &lt; nodes.length; i++) &#123; nodes[i].innerText = 'Hello ' + i;&#125;//Each Native #2: var nodes = document.querySelectorAll('input.date'), elems = [].slice.call(nodes);elems.forEach(function(el, i) &#123; el.innerText('Hello ' + i);&#125;);//Each Native #3:var nodes = document.querySelectorAll('input.date');[].forEach.call(nodes, function(el, i) &#123; el.innerText('Hello ' + i);&#125;);//Each Native #4: function $$(selector) &#123; return [].slice.call(selector)&#125;$$('input.date').forEach(function(el, i) &#123; el.innerText('Hello ' + i);&#125;); Index(eq)1234//Index(eq) jQuery:$(div.date).eq(3); //return $ object$(div.date).get(3);$(div.date)[3]; 12//Index Native:document.querySelectorAll('input.date')[3] First, Last12345678910111213//First, Last jQuery:var $dates = $('.dates');$dates.first(); //return $ object$dates.eq(0); //return $ object$dates.get(0);$dates[0];$dates.last(); //return $ object$dates.eq(-1); //return $ object$dates.get(-1);$dates[$dates.length - 1]; 12345678910//First, Last Native:var dates = document.querySelectorAll('.dates');dates.firstElementChild;dates[0];document.querySelector('.dates');dates.lastChilddate[date.length - 1];[].pop.call(date); Is/Matches12//jQuery \"is\":$('#widget').is('.active'); 12345678910//Native \"match\":document.getElentById('widget').matches('.active');//matches polyfil;if (Element &amp;&amp; !Element.prototype.matches) &#123; var proto = Element.prototype; proto.matches = proto.matchesSelector || proto.mozMatchesSelector || proto.msMatchesSelector || proto.oMatchesSelector || proto.webkitMatchesSelector;&#125; Filter12345//Filter jQuery:var dates = $(.dates);dates.filter('[pattern]');dates.filter('.active'); 123456//Filter Native:var dates = [].slice.call(document.querySelectorAll('.dates'));dates = dates.filter(function(el, i) &#123; el.matches('.active')&#125;); Find123//Find jQuery:$('#widget').find('.favorites');$('ul').find('.favorites'); 12//Find Native:document.getElementById('widget').querySelectorAll('.favorites'); Next, Prev1234//Next, Prev jQuery:var elem = $('#widget'), prev = elem.prev(), next = elem.next(); 1234//Next, Prev Native:var elem = document.getElementById('widget'), prev = elem.previousElemntSibling, next = elem.nextElemntSibling; Closest1$('#widget').closest('.active'); 12345678910111213141516//Closest Native:closest(document.getElementById('widget'), '.active');function closest(elem, selector) &#123; var matchesSelector = elem.matches || elem.webkitMatchesSelector || elem.mozMatchesSelector || elem.msMatchesSelector; while (elem) &#123; if (matchesSelector.bind(elem)(selector)) &#123; return elem; &#125; else &#123; elem = elem.parentElement; &#125; &#125; return false;&#125; ClassesClass manipulation in &lt;=IE9 12document.querySelector('.widget').className += ' active';document.querySelector('.widget').className = ' '; For polyfill ClassList use this one. HTML text1234567//jQuery:var $widget = $('#widget');$widget.html('&lt;b&gt;Hello from jQuery!&lt;/b&gt;'); //Setter$widget.html(); //Getter$widget.text('Bye from jQuery!'); $widget.text(); 1234567//Native:var widget = document.getElementById('widget');widget.innerHTML = '**Hello from Native!**' //Setterwidget.innerHTML; //Getterwidget.textContent = 'Bye from Native!';widget.textContent; Append &amp; Prepend123//jQuery:$('#widget').append('&lt;div&gt;Hello from jQuery!&lt;/div&gt;');$('#widget').append('&lt;div&gt;Bye from jQuery!&lt;/div&gt;'); 1234567//Native:var widget = document.getElementById('widget'), appendEl = document.createElement('div'), prependdEl = document.createElement('div');widget.appendChild(appendEl);widget.insertBefore(prependEl, appendEl.children[0]); Or you can use polifil for modern methods like prepend, append, etc…1&lt;script src=\"https://cdn.polyfill.io/v1/polyfill.js?features=Element.prototype.append,Element.prototype.after\"&gt;&lt;/script&gt; Remove123456//jQuery:var $widget = $('#widget');$widget.empty();$widget.html('');$widget.remove(); 1234567//Native:var widget = document.getElementById('widget');widget.innerHTML = '';widget.parentNode.removeChild(widget);while (widget.lastChild) widget.removeChild(widget.lastChild); CSS123456789//jQuery:var $widget = $('#widget');$widget.css('color', 'aquamarine');$widget.css(&#123; fontSize: '2em', '-webkit-transform': 'rotate(45deg)', 'transition': 'all .5s easy-in' &#125;); 12345//Native:var widget = document.getElementById('widget');widget.css.color = 'aquamarine';widget.css[fontSize varible] = '2em'; Attributes and Property12345678910111213//jQuery:var $widget = $('#search-main'), $toggle = $('#toogle-checkbox'), $link = $('#link-awesome');$widget.attr('placeholder', 'Search Here ...');$widget.attr('placeholder');$toggle.prop('checked', true);$toggle.prop('checked');$link.attr('href'); // .pages/about.html$link.prop('href'); // http://domain.com/pages/about.html 12345678910111213//Native:var widget = document.getElementById('widget'), toogle = document.getElementById('toogle-checkbox'), link = document.getElementById('toogle-checkbox');widget.setAttribute('placeholder', 'Search Here ...');widget.setAttribute();toogle.checked = true;toogle.checked;link.getAttribute('href'); // .pages/about.htmllink.href; // http://domain.com/pages/about.html Value12345//jQuery:var $widget = $('#search-main');$widget.val('Hello, new value!');$widget.val(); 12345//Native:var widget = document.getElementById('search-main');widget.value = 'Hello, new value!'$widget.value; Height &amp; Width123456//jQuery:var $container = $('#container');$container.width();$container.innerWidth();$container.outerWidth(); 123456//Native:var container = document.getElementById('search-main');container.clientWidth;container.offsetWidth;box.getBoundingClientRect().width; Bind and Unbind12345678910111213//jQuery:$('#foo-btn').click(function() &#123;&#125;);$('#foo-btn').on('click', function() &#123;&#125;);$('#foo-btn').bind('click', function() &#123;&#125;);$(.btn-active).on('click', function() &#123;&#125;);//unbindvar el = $('#bar-btn');el.off();el.off('click');el.off('click', nameOfCallback); 1234567891011121314151617Native:var btn = document.getElementById('foo-btn'); btnsActive = document.querySelectorAll('.foo-active'), cachingCallback = function()&#123;&#125;;btn.addEventListener('click', function() &#123;&#125;);[].forEach.call(btnsActive, function(el) &#123; el.addEventListener('click', cachingCallback);&#125;)//unbindbtn.removeEventListener('click', nameOfCallback);[].forEach.call(btnsActive, function(el) &#123; el.removeEventListener('click', nameOfCallback);&#125;) Delegation12//jQuery:$('#menu').on('click', 'li' function() &#123;&#125;); 123456789//Native:document.getElementById('menu').addEventListener('click', function(ev) &#123; if (ev.target.tagName != 'LI') return; //or if (ev.target.matches(.active)) &#123; //... &#125;&#125;); Prevent Default &amp; Stop #Propation123456//jQuery:$('submit-form').on('click', function(ev) &#123; ev.preventDefault(); ev.stopPropation();&#125;); 12345//Native:document.getElementById('#submit-form').addEventListener('click', function(ev) &#123; ev.preventDefault(); ev.stopPropation();&#125;); Trigger1234567//jQuery:$('menu').on('click', function(ev, arg1, arg2) &#123; console.log(ev, arg1, arg2);&#125;);$('menu').trigger('click');$('menu').trigger('click', ['arg1', 'arg2']); 123456789101112//Native:document.getElementById('#menu').addEventListener('click', function(ev, arg1, arg2) &#123; console.log(ev, arg1, arg2)&#125;);var event = new Event('click');document.getElementById('#menu').dispatchEvent(event);var event = new CustomEvent('click', &#123; detail: ['arg1', 'arg2']&#125;);document.getElementById('#menu').dispatchEvent(event); DOM Ready12345678//jQuery:$(document).ready(function() &#123; //DOM is ready&#125;);$(function() &#123; //DOM is ready&#125;) 12345678910111213141516&lt;!--Native #1:--&gt;&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;script&gt; //DOM is ready &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;[/html] 1234//Native #2:document.addEventListener('DOMContentLoaded', function() &#123; //DOM is ready&#125;) Ajax Get123456789101112//jQuery #1:$.get('url', function(data) &#123; console.log(data);&#125;);$.get( 'url', &#123;name: 'foo'&#125;, function(data) &#123; console.log(date); &#125;) 123456789//jQuery #2:$.ajax(&#123; type: 'GET', url: 'url', data: &#123;name: 'foo'&#125;, success: function(data) &#123; console.log(date); &#125;&#125;) 123456789//Native:var xhr = new XMLHttRequest();xhr.open('GET', 'url' + 'name=foo', true);xhr.onload = function() &#123; if (this.status === 200) console.log(this.responseText);&#125;;xhr.send(); Ajax Post123456789101112jQuery #1:$.post('url', function(data) &#123; console.log(data);&#125;);$.post( 'url', &#123;name: 'foo'&#125;, function(data) &#123; console.log(date); )[/javascript] 123456789//jQuery #2:$.ajax(&#123; type: 'POST', url: 'url', data: &#123;name: 'foo'&#125;, success: function(data) &#123; console.log(date); &#125;&#125;) 12345678910//Native #1:var xhr = new XMLHttRequest();xhr.open('POST', 'url', true);xhr.setRequestHeader('Content-type', 'application/x-www-form-urlencoded')xhr.onload = function() &#123; if (this.status === 200) console.log(this.responseText);&#125;;xhr.send('name=bob&amp;age=26'); 12345678910111213141516171819202122232425262728293031323334353637&lt;!--Native #2:--&gt;&lt;form enctype=\"multipart/form-data\" method=\"post\" name=\"fileinfo\"&gt; &lt;label&gt;Your email address:&lt;/label&gt; &lt;input type=\"email\" autocomplete=\"on\" autofocus name=\"userid\" placeholder=\"email\" required size=\"32\" maxlength=\"64\" /&gt; &lt;label&gt;Custom file label:&lt;/label&gt; &lt;input type=\"text\" name=\"filelabel\" size=\"12\" maxlength=\"32\" /&gt; &lt;label&gt;File to stash:&lt;/label&gt; &lt;input type=\"file\" name=\"file\" required /&gt; &lt;input type=\"submit\" value=\"Stash the file!\" /&gt;&lt;/form&gt;&lt;div id=\"output\"&gt;&lt;/div&gt;var form = document.forms.namedItem(\"fileinfo\");form.addEventListener('submit', function(ev) &#123; var oOutput = document.getElementById(\"output\"), oData = new FormData(document.forms.namedItem(\"fileinfo\")); oData.append(\"CustomField\", \"This is some extra data\"); var oReq = new XMLHttpRequest(); oReq.open(\"POST\", \"stash.php\", true); oReq.onload = function(oEvent) &#123; if (oReq.status == 200) &#123; oOutput.innerHTML = \"Uploaded!\"; &#125; else &#123; oOutput.innerHTML = \"Error \" + oReq.status + \" occurred uploading your file.\"; &#125; &#125;; oReq.send(oData); ev.preventDefault();&#125;, false); JSONP123456//jQuery #1:$.getJSON('http://domain.io/jsonp?callback=?', function(data) &#123; console.log(data);&#125;); 12345678//jQuery #2:$.ajax(&#123; url: 'url', dataTepe: 'jsonp', success: function(data) &#123; console.log(date); &#125;&#125;) 12345678//Native:function jsonpCallback(data) &#123; console.log(data)&#125;var script = document.creatElement('script');script.src = 'http://exampleDomain.io/jsonp?callback=jsonpCallback';document.head.appendChils(script); Micro-LibraryReqwest on link Each, Grep, Map12345678910111213141516//jQuery:$.each(arr, function(el) &#123; console.log(el.name + ' ' + el.id);&#125;)arr = $.grep(arr.function(el) &#123; return el.matches('Script')&#125;)arr = $.map(arr, function(el) &#123; return &#123; nickname: el.name, secretCode: el.age, age: Date.now() &#125;;&#125;); 12345678910111213141516//Native:arr.forEach(function(el) &#123; console.log(el.name + ' ' + el.id);&#125;);arr = arr.filter(function(el) &#123; return el.matches('Script')&#125;);arr = arr.map(function(el) &#123; return &#123; nickname: el.name, secretCode: el.age, age: Date.now() &#125;;&#125;); Or you can use Undersore or Low-Dash _.each. in Array1var arr = ['foo', 'bar', 'baz']; 1console.log('Found Bar: ' + !!~arr.inArray('bar')); 12//Native:console.log('Found Bar: ' + !!~arr.indexOf('bar')); Trim12//jQuery:$.trim(' look at me, I\"m padded! '); 12//Native:' look at me, I\"m padded! '.trim(); Save my day: YOU MIGHT NOT NEED JQUERY","categories":[{"name":"Javascript","slug":"Javascript","permalink":"http://qetr1ck-op.github.io/categories/Javascript/"},{"name":"jQuery","slug":"Javascript/jQuery","permalink":"http://qetr1ck-op.github.io/categories/Javascript/jQuery/"}],"tags":[]},{"title":"Performance: JavaScript loops","slug":"Performance-JavaScript-loops","date":"2014-08-06T17:38:48.000Z","updated":"2016-02-03T21:44:37.459Z","comments":true,"path":"2014/08/06/Performance-JavaScript-loops/","link":"","permalink":"http://qetr1ck-op.github.io/2014/08/06/Performance-JavaScript-loops/","excerpt":"Is it faster to use the native forEach or just loop with for?","text":"Is it faster to use the native forEach or just loop with for? Types of methods for test: forEach for loop, simple for loop, cached length for loop, reverse for loop, cached length, callback $.each for … in for loop, reverse decrement other crazy loops Is it faster to use the native forEach or just loop with for? Obviously, the most faster loop is for with cashed array length. But in my case it was ordinary for loop :) Also I was confused that Array.forEach method is slowest more than 89% from classic for loop… Screenshot from jsperf: SaveMyDay: on jsperf.com","categories":[{"name":"Javascript","slug":"Javascript","permalink":"http://qetr1ck-op.github.io/categories/Javascript/"}],"tags":[{"name":"Perforamance","slug":"Perforamance","permalink":"http://qetr1ck-op.github.io/tags/Perforamance/"}]},{"title":"CSS Transforms","slug":"CSS-Transforms","date":"2014-08-03T19:13:20.000Z","updated":"2016-01-31T20:58:58.507Z","comments":true,"path":"2014/08/03/CSS-Transforms/","link":"","permalink":"http://qetr1ck-op.github.io/2014/08/03/CSS-Transforms/","excerpt":"So what are transforms and transitions? At their most basic level, transforms move or change the appearance of an element, while transitions make the element smoothly and gradually change from one state to another.","text":"So what are transforms and transitions? At their most basic level, transforms move or change the appearance of an element, while transitions make the element smoothly and gradually change from one state to another. How to use transforms 2D examples 3D examples 3D Transform image slider How to use transforms There are two categories of transform - 2D transforms and 3D transforms. 2D transforms are more widely supported, whereas 3D transforms are only in newer browers. 2D examples 123456789101112131415161718192021222324252627282930313233343536//don't forget about prefixes#skew &#123; -webkit-transform:skew(35deg); -moz-transform:skew(35deg); -ms-transform:skew(35deg); -o-transform:skew(35deg); transform:skew(35deg);&#125;#scale &#123; -webkit-transform:scale(1,0.5); -moz-transform:scale(1,0.5); -ms-transform:scale(1,0.5); -o-transform:scale(1,0.5); transform:scale(1,0.5);&#125;#rotate &#123; -webkit-transform:rotate(45deg); -moz-transform:rotate(45deg); -ms-transform:rotate(45deg); -o-transform:rotate(45deg); transform:rotate(45deg);&#125;#translate &#123; -webkit-transform:translate(10px, 20px); -moz-transform:translate(10px, 20px); -ms-transform:translate(10px, 20px); -o-transform:translate(10px, 20px); transform:translate(10px, 20px);&#125;.thumbnail &#123; -webkit-transition: all .5s ease-in; -moz-transition: all .5s ease-in; -o-transition: all .5s ease-in; transition: all .5s ease-in;&#125; See the Pen CSS Transforms: 2D examples by qetr1ck-op (@qetr1ck-op) on CodePen.3D examples and hadle onTransitionEnd3D CSS transforms are similar to 2D CSS transforms. The basic properties are translate3d, scale3d, rotateX, rotateY and rotateZ. translate3d and scale3d take three arguments for x,y and z, whereas the rotates just take an angle. Here are some examples:123456789101112131415161718192021#rotateX&#123;-webkit-transform:rotateX(180deg); -moz-transform:rotateX(180deg); -ms-transform:rotateX(180deg); -o-transform:rotateX(180deg); transform:rotateX(180deg);&#125;#rotateY&#123;-webkit-transform:rotateY(180deg); -moz-transform:rotateY(180deg); -ms-transform:rotateY(180deg); -o-transform:rotateY(180deg); transform:rotateY(180deg);&#125;#rotateZ&#123;-webkit-transform:rotateZ(180deg); -moz-transform:rotateZ(180deg); -ms-transform:rotateZ(180deg); -o-transform:rotateZ(180deg); transform:rotateZ(180deg);&#125;123456$('.thumbnail').on('transitionend webkitTransitionEnd MSTransitionEnd', function(e) &#123; //transitionend fires for each property transitioned if (e.originalEvent.propertyName != 'transform') return; alert('webkitTransitionEnd')&#125;);See the Pen CSS Transforms: 3D example and transtionEnd by qetr1ck-op (@qetr1ck-op) on CodePen. 3D Transform image slider Note that because of the way a cube works, the image is moved out towards the screen, and is bigger than it should be. You should move it back by half the width of an image to make sure it is normal size. See the Pen CSS Transforms: 3D Transform image slider by qetr1ck-op (@qetr1ck-op) on CodePen. SaveMyDay: on css3.bradshawenterprises.com","categories":[{"name":"CSS","slug":"CSS","permalink":"http://qetr1ck-op.github.io/categories/CSS/"}],"tags":[]},{"title":"Bootstrap 3: Components","slug":"Bootstrap3-Components","date":"2014-08-02T13:59:51.000Z","updated":"2016-10-05T20:54:11.048Z","comments":true,"path":"2014/08/02/Bootstrap3-Components/","link":"","permalink":"http://qetr1ck-op.github.io/2014/08/02/Bootstrap3-Components/","excerpt":"Set of standart components from popular library.","text":"Set of standart components from popular library. Icons Dropdowns Buttons groups Input groups Navs Pagination Labels and Badges Thumbnails Alerts Progress Bars Icons Use them in buttons, button groups for a toolbar, navigation, or prepended form inputs. See the Pen Bootstrap Components: Icons Examples by qetr1ck-op (@qetr1ck-op) on CodePen. Dropdowns Wrap the dropdown’s trigger and the dropdown menu within .dropdown, or another element that declares position: relative;. Then add the menu’s HTML: Via data attributes or JavaScript, the dropdown plugin toggles hidden content (dropdown menus) by toggling the .open class on the parent list item. When opened, the plugin also adds .dropdown-backdrop as a click area for closing dropdown menus when clicking outside the menu. Call the dropdowns via JavaScript: $(&#39;.dropdown-toggle&#39;).dropdown() or use data-toggle=&quot;dropdown&quot;. Full list Dropdown methods See the Pen yoehq by qetr1ck-op (@qetr1ck-op) on CodePen. Buttons group Group a series of buttons together on a single line with the button group. Control via JavaScript: $(&#39;.btn&#39;).button() Full list methods See the Pen Bootstrap Components: Buttons Group by qetr1ck-op (@qetr1ck-op) on CodePen. Input groups Extend form controls by adding text or buttons before, after, or on both sides of any text-based input. Use .input-group with an .input-group-addon to prepend or append elements to a single .form-control. See the Pen Bootstrap: Components - Input groups by qetr1ck-op (@qetr1ck-op) on CodePen. Navs Navs available in Bootstrap have shared markup, starting with the base .nav class, as well as shared states. Swap modifier classes to switch between each style. Navs via JavaScript: $(&#39;#myTab a&#39;).tab() Full list methods See the Pen Bootstrap: Copmonents - Navs by qetr1ck-op (@qetr1ck-op) on CodePen. Pagination Provide pagination links for your site or app with the multi-page pagination component, or the simpler pager alternative. Simple pagination inspired by Rdio, great for apps and search results. The large block is hard to miss, easily scalable, and provides large click areas. See the Pen Bootstrap: Components - Pagination by qetr1ck-op (@qetr1ck-op) on CodePen. Labels and Badges Add any of the below mentioned modifier classes to change the appearance of a label. See the Pen Bootstrap: Components - Labels and Badges by qetr1ck-op (@qetr1ck-op) on CodePen. Thumbnails With a bit of extra markup, it’s possible to add any kind of HTML content like headings, paragraphs, or buttons into thumbnails. See the Pen Bootstrap: Components - Thumbnail by qetr1ck-op (@qetr1ck-op) on CodePen. Alerts Provide contextual feedback messages for typical user actions with the handful of available and flexible alert messages. Full list methods See the Pen Bootstrap: Components - Alerts by qetr1ck-op (@qetr1ck-op) on CodePen. Progress Bars Provide up-to-date feedback on the progress of a work-flow or action with simple yet flexible progress bars. See the Pen Bootstrap: Components - Progress Bar by qetr1ck-op (@qetr1ck-op) on CodePen.","categories":[{"name":"CSS","slug":"CSS","permalink":"http://qetr1ck-op.github.io/categories/CSS/"}],"tags":[{"name":"Bootstrap","slug":"Bootstrap","permalink":"http://qetr1ck-op.github.io/tags/Bootstrap/"}]},{"title":"Reading files in JavaScript with File API","slug":"Reading-files-in-JavaScript-with-File-API","date":"2014-08-02T12:39:09.000Z","updated":"2016-02-03T21:44:37.475Z","comments":true,"path":"2014/08/02/Reading-files-in-JavaScript-with-File-API/","link":"","permalink":"http://qetr1ck-op.github.io/2014/08/02/Reading-files-in-JavaScript-with-File-API/","excerpt":"Reading files in Javascript with File API","text":"Reading files in Javascript with File API OverviewUsing File API or file-reader interfaces on the client side code can be checked as to whether the MIME type of the uploaded file to its expansion, or set limits on the size. This spec provides an API for representing file objects in web applications: A FileList interface, which represents an array of individually selected files from the underlying system. The user interface for selection can be invoked via input type=&quot;file&quot; multiple A File interface, which includes readonly informational attributes about a file such as its name, MIME type, and the date of the last modification A Blob interface, which represents immutable raw binary data, and allows access to ranges of bytes within the Blob object as a separate Blob. A FileReader interface, which provides methods to read a File or a Blob, and an event model to obtain the results of these reads. A URL scheme for use with binary data such as files, so that they can be referenced within web applications. Check for the File API support.123456// Check for the various File API support.if (window.File &amp;&amp; window.FileReader &amp;&amp; window.FileList &amp;&amp; window.Blob) &#123; // Great success! All the File APIs are supported.&#125; else &#123; alert('The File APIs are not fully supported in this browser.');&#125; Using form input for selectingThe most straightforward way to load a file is to use a standard input type=&quot;file&quot; element. JavaScript returns the list of selected File objects as a FileList. Here’s an example that uses the multiple attribute to allow selecting several files at once: 1234567891011121314151617181920&lt;input type=\"file\" id=\"files\" name=\"files[]\" multiple /&gt;&lt;output id=\"list\"&gt;&lt;/output&gt;&lt;script&gt; function handleFileSelect(evt) &#123; var files = evt.target.files; // FileList object // files is a FileList of File objects. List some properties. var output = []; for (var i = 0, f; f = files[i]; i++) &#123; output.push('&lt;li&gt;**', escape(f.name), '** (', f.type || 'n/a', ') - ', f.size, ' bytes, last modified: ', f.lastModifiedDate ? f.lastModifiedDate.toLocaleDateString() : 'n/a', '&lt;/li&gt;'); &#125; document.getElementById('list').innerHTML = ''; &#125; document.getElementById('files').addEventListener('change', handleFileSelect, false);&lt;/script&gt; See the Pen Using form input for selecting by qetr1ck-op (@qetr1ck-op) on CodePen. Using drag and drop for selectingAnother technique for loading files is native drag and drop from the desktop to the browser. We can modify the previous example slightly to include drag and drop support: 12345678910111213141516171819202122232425262728293031323334&lt;div id=\"drop_zone\"&gt;Drop files here&lt;/div&gt;&lt;output id=\"list\"&gt;&lt;/output&gt;&lt;script&gt; function handleFileSelect(evt) &#123; evt.stopPropagation(); evt.preventDefault(); var files = evt.dataTransfer.files; // FileList object. // files is a FileList of File objects. List some properties. var output = []; for (var i = 0, f; f = files[i]; i++) &#123; output.push('&lt;li&gt;**', escape(f.name), '** (', f.type || 'n/a', ') - ', f.size, ' bytes, last modified: ', f.lastModifiedDate ? f.lastModifiedDate.toLocaleDateString() : 'n/a', '&lt;/li&gt;'); &#125; document.getElementById('list').innerHTML = ''; &#125; function handleDragOver(evt) &#123; evt.stopPropagation(); evt.preventDefault(); evt.dataTransfer.dropEffect = 'copy'; // Explicitly show this is a copy. &#125; // Setup the dnd listeners. var dropZone = document.getElementById('drop_zone'); dropZone.addEventListener('dragover', handleDragOver, false); dropZone.addEventListener('drop', handleFileSelect, false);&lt;/script&gt; See the Pen Using drag and drop for selecting by qetr1ck-op (@qetr1ck-op) on CodePen. Reading filesNow comes the fun part! After you’ve obtained a File reference, instantiate a FileReader object to read its contents into memory. When the load finishes, the reader’s onload event is fired and its result attribute can be used to access the file data. FileReader includes four options for reading a file, asynchronously: FileReader.readAsBinaryString(Blob|File) - The result property will contain the file/blob’s data as a binary string. Every byte is represented by an integer in the range [0..255] FileReader.readAsText(Blob|File, opt_encoding) - The result property will contain the file/blob’s data as a text string. By default the string is decoded as ‘UTF-8’. Use the optional encoding parameter can specify a different format. FileReader.readAsDataURL(Blob|File) - The result property will contain the file/blob’s data encoded as a data URL. FileReader.readAsArrayBuffer(Blob|File) - The result property will contain the file/blob’s data as an ArrayBuffer object. Once one of these read methods is called on your FileReader object, the onloadstart, onprogress, onload, onabort, onerror, and onloadend can be used to track its progress. The example below filters out images from the user’s selection, calls reader.readAsDataURL() on the file, and renders a thumbnail by setting the src attribute to a data URL: 123456789101112131415161718192021222324252627282930313233343536373839404142&lt;style&gt; .thumb &#123; height: 75px; border: 1px solid #000; margin: 10px 5px 0 0; &#125;&lt;/style&gt;&lt;input type=\"file\" id=\"files\" name=\"files[]\" multiple /&gt;&lt;output id=\"list\"&gt;&lt;/output&gt;&lt;script&gt; function handleFileSelect(evt) &#123; var files = evt.target.files; // FileList object // Loop through the FileList and render image files as thumbnails. for (var i = 0, f; f = files[i]; i++) &#123; // Only process image files. if (!f.type.match('image.*')) &#123; continue; &#125; var reader = new FileReader(); // Closure to capture the file information. reader.onload = (function(theFile) &#123; return function(e) &#123; // Render thumbnail. var span = document.createElement('span'); span.innerHTML = ['![]()'].join(''); document.getElementById('list').insertBefore(span, null); &#125;; &#125;)(f); // Read in the image file as a data URL. reader.readAsDataURL(f); &#125; &#125; document.getElementById('files').addEventListener('change', handleFileSelect, false);&lt;/script&gt; See the Pen sJpmy by qetr1ck-op (@qetr1ck-op) on CodePen. Monitoring the progress of a readOne of the nice things that we get for free when using async event handling is the ability to monitor the progress of the file read; useful for large files, catching errors, and figuring out when a read is complete. The onloadstart and onprogress events can be used to monitor the progress of a read. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788&lt;style&gt; #progress_bar &#123; margin: 10px 0; padding: 3px; border: 1px solid #000; font-size: 14px; clear: both; opacity: 0; -moz-transition: opacity 1s linear; -o-transition: opacity 1s linear; -webkit-transition: opacity 1s linear; &#125; #progress_bar.loading &#123; opacity: 1.0; &#125; #progress_bar .percent &#123; background-color: #99ccff; height: auto; width: 0; &#125;&lt;/style&gt;&lt;input type=\"file\" id=\"files\" name=\"file\" /&gt;&lt;button onclick=\"abortRead();\"&gt;Cancel read&lt;/button&gt;&lt;div id=\"progress_bar\"&gt;&lt;div class=\"percent\"&gt;0%&lt;/div&gt;&lt;/div&gt;&lt;script&gt; var reader; var progress = document.querySelector('.percent'); function abortRead() &#123; reader.abort(); &#125; function errorHandler(evt) &#123; switch(evt.target.error.code) &#123; case evt.target.error.NOT_FOUND_ERR: alert('File Not Found!'); break; case evt.target.error.NOT_READABLE_ERR: alert('File is not readable'); break; case evt.target.error.ABORT_ERR: break; // noop default: alert('An error occurred reading this file.'); &#125;; &#125; function updateProgress(evt) &#123; // evt is an ProgressEvent. if (evt.lengthComputable) &#123; var percentLoaded = Math.round((evt.loaded / evt.total) * 100); // Increase the progress bar length. if (percentLoaded &lt; 100) &#123; progress.style.width = percentLoaded + '%'; progress.textContent = percentLoaded + '%'; &#125; &#125; &#125; function handleFileSelect(evt) &#123; // Reset progress indicator on new file selection. progress.style.width = '0%'; progress.textContent = '0%'; reader = new FileReader(); reader.onerror = errorHandler; reader.onprogress = updateProgress; reader.onabort = function(e) &#123; alert('File read cancelled'); &#125;; reader.onloadstart = function(e) &#123; document.getElementById('progress_bar').className = 'loading'; &#125;; reader.onload = function(e) &#123; // Ensure that the progress bar displays 100% at the end. progress.style.width = '100%'; progress.textContent = '100%'; setTimeout(\"document.getElementById('progress_bar').className='';\", 2000); &#125; // Read in the image file as a binary string. reader.readAsBinaryString(evt.target.files[0]); &#125; document.getElementById('files').addEventListener('change', handleFileSelect, false);&lt;/script&gt; See the Pen Monitoring the progress of a read by qetr1ck-op (@qetr1ck-op) on CodePen. Example: drag and drop files and foldersExample: drag and drop files and folders SaveMyDay: on html5rocks.com","categories":[{"name":"Javascript","slug":"Javascript","permalink":"http://qetr1ck-op.github.io/categories/Javascript/"}],"tags":[{"name":"File API","slug":"File-API","permalink":"http://qetr1ck-op.github.io/tags/File-API/"}]},{"title":"NodeList vs Array in Javascript","slug":"NodeList-vs-Array-in-Javascript","date":"2014-07-30T19:39:40.000Z","updated":"2016-10-05T20:55:19.550Z","comments":true,"path":"2014/07/30/NodeList-vs-Array-in-Javascript/","link":"","permalink":"http://qetr1ck-op.github.io/2014/07/30/NodeList-vs-Array-in-Javascript/","excerpt":"Essentially, a NodeList is what you get when you call any method such as elem.getElemetsByTagName(), elem.querySelectorAll() and so on.","text":"Essentially, a NodeList is what you get when you call any method such as elem.getElemetsByTagName(), elem.querySelectorAll() and so on. We should note here that NodeLists aren’t exactly part of the JavaScript but they are instead part of the DOM APIs the browsers provide through JavaScript. 12345678910111213141516var myList = document.querySelectorAll('.story-item');console.log(myList)[ &lt;div class=\"story-item\"&gt;…&lt;/div&gt; , &lt;div class=\"story-item\"&gt;…&lt;/div&gt; , […] , &lt;div class=\"story-item\"&gt;..&lt;/div&gt; ,]//basic array actionsconsole.log(myList.length) // 7console.log(myList[2]) // &lt;div class=\"story-item\"&gt;..&lt;/div&gt; So far, myList has been talking and walking like an array so we can probably assume that it’s an array of some sorts. However, it all goes to hell when you try to call any of the basic array methods: 123myList.slice(2) // indexed from 0TypeError: Result of expression 'myList.slice' [undefined] is not a function. Wait, what happened? Well, this is where the between NodeLists and arrays in JavaScript start to surface. Let’s see what is distinguish array and NodeList: 12345console.log(myList.constructor.prototype) // \"[object NodeListConstructor]\"var surelyArray = ['foo', 'bar'];console.log(surelyArray.constructor.prototype) //\"function Array() &#123; [native code] &#125;\" So those two elements, myList and surelyArray are definitely constructed by different constructors so it’s no wonder that they don’t share the same methods. While arrays are essentially a collection of elements held in memory and are part of the JavaScript, NodeLists are live references to actual DOM elements. Let’s see a quick way to convert a NodeList into an array: 12345678910111213//borrowing the slice() method from the Array’s prototypevar myArray = Array.prototype.slice.call(myList, 0);console.log(myArray.constructor.prototype) //\"function Array() &#123; [native code] &#125;\"//call pop methodmyArray.pop() //&lt;div class=\"story-item\"&gt;…&lt;/div&gt;//Internet Explorer 9 cannot handle calling slice() on NodeListsvar myIEArray = [];for (var i = 0; i &lt; myList.length; ++i) &#123; myIEArray.push(myList[i]); &#125;console.log(myIEArray.constructor.prototype) //\"function Array() &#123; [native code] &#125;\" One thing is worth mentioning though; when you convert your NodeList into an array, you are no longer dealing with a live NodeList but instead an array of DOM nodes.","categories":[{"name":"Javascript","slug":"Javascript","permalink":"http://qetr1ck-op.github.io/categories/Javascript/"}],"tags":[]},{"title":"Operator typeof, [[Class]], instanceof,  Duck Typing and Polymorphism","slug":"Operator-typeof-Class-instanceof-Duck-Typing-and-Polymorphism","date":"2014-07-29T19:01:59.000Z","updated":"2016-02-02T22:28:03.705Z","comments":true,"path":"2014/07/29/Operator-typeof-Class-instanceof-Duck-Typing-and-Polymorphism/","link":"","permalink":"http://qetr1ck-op.github.io/2014/07/29/Operator-typeof-Class-instanceof-Duck-Typing-and-Polymorphism/","excerpt":"How to properly get instance of object.","text":"How to properly get instance of object. Operator typeofOperator typeof return type of argument. He has two syntax: typeof x and typeof(x). 1234567891011121314typeof undefined // \"undefined\" typeof 0 // \"number\" typeof true // \"boolean\" typeof \"foo\" // \"string\" typeof &#123;&#125; // \"object\" typeof [] // \"object\" typeof new Date // \"object\" typeof null // \"object\" typeof function()&#123;&#125; // \"function\" typeof operator works great with primitive types, except null, as well as functions. But ordinary objects, arrays, and date for typeof all look the same, they are of type ‘object’. That’s why we can’t distinguish them using typeof. [[Class]] for objects12345678var date = new Date, arr = [1,2];console.log(&#123;&#125;.toString.call(date)); //[object Object]console.log(&#123;&#125;.toString.call(arr)); //[object Array]console.log((&#123;&#125;.toString.call(date)).slice(8,-1)); //Objectconsole.log((&#123;&#125;.toString.call(arr)).slice(8,-1)); //Array We use this method because the internal implementation of the Object toString returns the standard [[Class]]. Other objects (Date, Array, etc.) toString her and for this purpose will not work. This method can give the type only for embedded objects. For user constructors always [[Class]] = &quot;Object&quot;: 12345678function Animal(name) &#123; this.name = name;&#125;var animal = new Animal(\"Винни-пух\");var type = &#123;&#125;.toString.call( animal );console.log(type); //[object Object] Duck Typing«If it looks like a duck, swims like a duck and quacks like a duck, then it probably is a duck (who cares what it really is)» Meaning duck typing - to verify the methods and properties, regardless of the type of object. 12345678910111213//check if array has method splitvar x = [1,2,3];if (x.splice) &#123; alert('Array');&#125;//check if date has method getTimevar z = new Date();if (z.getTime) &#123; alert('Date!');&#125; To check who created the object or his prototype, is the operator: 1234567891011121314151617181920//check custom objectsfunction Animal(name) &#123; this.name = name;&#125;var animal = new Animal(\"Bee\");console.log( animal instanceof Animal ); // trueconsole.log( Object.getPrototypeOf(animal) == Animal.prorotype ); // trueconsole.log( animal.contstructor.prototype == Animal.prorotype ); // true//also works for inner objectsvar d = new Date(); console.log( d instanceof Date ); // trueconsole.log( Object.getPrototypeOf(d) == Date.prorotype ); // trueconsole.log( d.contstructor.prototype == Date.prorotype ); // truefunction f() &#123; &#125;console.log( f instanceof Function ); // trueconsole.log( Object.getPrototypeOf(f) == Function.prorotype ); // trueconsole.log( f.contstructor.prototype == Function.prorotype ); // true PolymophismPolymorphic functions, ie, those which are differently treated arguments, depending on their type. For example, the output may have a different format numbers and dates. In example we use type checking to create a polymorphic function sayHi. It will work in three modes: No arguments: outputs &quot;Hello&quot;. With an argument, which is not an array: displays &quot;Hello&quot; + string argument With an argument, which is an array - &quot;Hello&quot; + arr[i] 123456789101112131415161718function sayHi(who) &#123; if (!arguments.length) &#123; console.log('Hello'); return; &#125; if ( &#123;&#125;.toString.call(who) == '[object Array]' ) &#123; for(var i=0; i&lt;who.length; i++) sayHi(who[i]); return; &#125; console.log('Hello, ' + who);&#125;sayHi(); // HellosayHi(\"Bob\"); // Hello, BobsayHi( [\"Bob\", [\"Sam\", \"Din\"] ] ); // Hello Bob..Sam..Din SaveMyDay: on learn.javascript.ru","categories":[{"name":"Javascript","slug":"Javascript","permalink":"http://qetr1ck-op.github.io/categories/Javascript/"}],"tags":[{"name":"OOP","slug":"OOP","permalink":"http://qetr1ck-op.github.io/tags/OOP/"}]},{"title":"Performance: JavaScript adding text to a node","slug":"Performance-Javascript-adding-text-to-a-node","date":"2014-07-25T20:10:14.000Z","updated":"2016-02-02T22:28:03.709Z","comments":true,"path":"2014/07/25/Performance-Javascript-adding-text-to-a-node/","link":"","permalink":"http://qetr1ck-op.github.io/2014/07/25/Performance-Javascript-adding-text-to-a-node/","excerpt":"What is the most reasonable approach? jQuery’s .html() with previously encoded text Query’s .text() innerHTML with previously encoded text innerText / textContent document.createTextNode once per element document.createTextNode once per test run","text":"What is the most reasonable approach? jQuery’s .html() with previously encoded text Query’s .text() innerHTML with previously encoded text innerText / textContent document.createTextNode once per element document.createTextNode once per test run Link on jsPerf","categories":[{"name":"Javascript","slug":"Javascript","permalink":"http://qetr1ck-op.github.io/categories/Javascript/"},{"name":"jQuery","slug":"Javascript/jQuery","permalink":"http://qetr1ck-op.github.io/categories/Javascript/jQuery/"}],"tags":[{"name":"Performance","slug":"Performance","permalink":"http://qetr1ck-op.github.io/tags/Performance/"}]},{"title":"Got 15 minutes and want to learn Git?","slug":"Got-15-minutes-and-want-to-learn-Git","date":"2014-07-19T06:56:12.000Z","updated":"2016-10-05T20:56:02.243Z","comments":true,"path":"2014/07/19/Got-15-minutes-and-want-to-learn-Git/","link":"","permalink":"http://qetr1ck-op.github.io/2014/07/19/Got-15-minutes-and-want-to-learn-Git/","excerpt":"","text":"Initialize a GitGit allows groups of people to work on the same documents (often code) at the same time, and without stepping on each other’s toes. It’s a distributed version control system. Our terminal prompt below is currently in directory we decided to name “octobox”. To initialize a Git repository here, type the following command: 1git init Checking the StatusGood job! As Git just told us, our “octobox” directory now has an empty repository in /.git/. The repository is a hidden directory where Git operates.Next up, let’s type the git status command to see what the current state of our project is: 1git status Tip:It’s healthy to run git status often. Sometimes things change and you don’t notice it. Adding ChangesGood, it looks like our Git repository is working properly. Notice how Git says octocat.txt is “untracked”? That means Git sees that octocat.txt is a new file. To tell Git to start tracking changes made to octocat.txt, we first need to add it to the staging area by using git add. 123456git add octocat.txtgit add *.txtgit add --allgit add docs/*.txtgit add docs/git add . staged: Files are ready to be committed. unstaged: Files with changes that have not been prepared to be commited. untracked: Files aren’t tracked by Git yet. This usually indicates a newly created file. deleted: File has been deleted and is waiting to be removed from Git. Checking for ChangesGood job! Git is now tracking our octocat.txt file. Let’s run git status again to see where we stand: 1git status You can use git reset filename to remove a file or files from the staging area. CommittingNotice how Git says changes to be committed? The files listed here are in the Staging Area, and they are not in our repository yet. We could add or remove files from the stage before we store them in the repository. To store our staged changes we run the commit command with a message describing what we’ve changed. Let’s do that now by typing: 1git commit -m \"Add new file\" Staging Area:A place where we can group files together before we commit them to Git. CommitA commit is a snapshot of our repository. This way if we ever need to look back at the changes we’ve made (or if someone else does), we will see a nice timeline of all changes. HistorySo we’ve made a few commits. Now let’s browse them to see what we changed. Fortunately for us, there’s git log. Think of Git’s log as a journal that remembers all the changes we’ve committed so far, in the order we committed them. Try running it now: 1git log Use git log --summary to see more information for each commit. Remote RepositoriesTo push our local repo to the GitHub server we’ll need to add a remote repository. This command takes a remote name and a repository URL, which in your case is https://github.com/try-git/try_git.git. 1git remote add origin url Git doesn’t care what you name your remotes, but it’s typical to name your main one origin. Pushing RemotelyThe push command tells Git where to put our commits when we’re ready, and boy we’re ready. So let’s push our local changes to our origin repo (on GitHub). The name of our remote is origin and the default local branch name is master. The -u tells Git to remember the parameters, so that next time we can simply run git push and Git will know what to do. Go ahead and push it! 1git push -u origin master Pulling RemotelyLet’s pretend some time has passed. We’ve invited other people to our github project who have pulled your changes, made their own commits, and pushed them. We can check for changes on our GitHub repository and pull down any new changes by running: 1git pull origin master DifferencesUh oh, looks like there has been some additions and changes to the octocat family. Let’s take a look at what is different from our last commit by using the git diff command. In this case we want the diff of our most recent commit, which we can refer to using the HEAD pointer. 1git diff HEAD The HEAD is a pointer that holds your position within all your different commits. By default HEAD points to your most recent commit. Staged DifferencesAnother great use for diff is looking at changes within files that have already been staged. Remember, staged files are files we have told git that are ready to be committed. Good, now go ahead and run git diff with the –staged option to see the changes you just staged. You should see that octodog.txt was created. 1git diff --staged Using ‘git diff’ gives you a good overview of changes you have made and lets you add files or directories one at a time and commit them separately. Resetting the StageSo now that octodog is part of the family, octocat is all depressed. Since we love octocat more than octodog, we’ll turn his frown around by removing octodog.txt. You can unstage files by using the git reset command. Go ahead and remove octofamily/octodog.txt. 1git reset octofamily/octodog.txt UndoFiles can be changed back to how they were at the last commit by using the command: git checkout -- &lt;target&gt;. Go ahead and get rid of all the changes since the last commit for octocat.txt 1git checkout -- octocat.txt So you may be wondering, why do I have to use this ‘–’ thing? This way if you happen to have a branch named octocat.txt, it will still revert the file, instead of switching to the branch of the same name. Branching OutWhen developers are working on a feature or bug they’ll often create a copy (aka. branch) of their code they can make separate commits to. Then when they’re done they can merge this branch back into their main master branch. We want to remove all these pesky octocats, so let’s create a branch called clean_up, where we’ll do all the work: 1git branch clean_up Switching BranchesGreat! Now if you type git branch you’ll see two local branches: a main branch named master and your new branch named clean_up. You can switch branches using the git checkout &lt;branch&gt;command. Try it now to switch to the clean_up branch: 1git checkout clean_up Branches are what naturally happens when you want to work on multiple features at the same time. You wouldn’t want to end up with a master branch which has Feature A half done and Feature B half done. Removing All The ThingsOk, so you’re in the clean_up branch. You can finally remove all those pesky octocats by using the git rm command which will not only remove the actual files from disk, but will also stage the removal of the files for us: 1git rm '*.txt' This will recursively remove all folders and files from the given directory: Commiting Branch ChangesNow that you’ve removed all the cats you’ll need to commit your changes. Feel free to run git status to check the changes you’re about to commit. 1git commit -m 'Remove all cats' Switching Back to masterGreat, you’re almost finished with the cat… er the bug fix, you just need to switch back to the master branch so you can copy (or merge) your changes from the clean_up branch back into the master branch. Go ahead and checkout the master branch: 1git checkout master Preparing to MergeAlrighty, the moment has come when you have to merge your changes from the clean_up branch into the master branch. Take a deep breath, it’s not that scary. We’re already on the master branch, so we just need to tell Git to merge the clean_up branch into it: 1git merge clean_up Merge Conflicts can occur when changes are made to a file at the same time. A lot of people get really scared when a conflict happens, but fear not! They aren’t that scary, you just need to decide which code to keep how conflicts are presented. Keeping Things CleanCongratulations! You just accomplished your first successful bugfix and merge. All that’s left to do is clean up after yourself. Since you’re done with the clean_up branch you don’t need it anymore. You can use git branch -d branch name to delete a branch. Go ahead and delete the clean_up branch now: 1git branch -d clean_up What if you have been working on a feature branch and you decide you really don’t want this feature anymore? You might decide to delete the branch since you’re scrapping the idea. You’ll notice that git branch -d bad_feature doesn’t work. This is because -d won’t let you delete something that hasn’t been merged.You can either add the --force (-f) The Final PushHere we are, at the last step. I’m proud that you’ve made it this far, and it’s been great learning Git with you. All that’s left for you to do now is to push everything you’ve been working on to your remote repository, and you’re done! Save My Day: Try Git","categories":[{"name":"Git","slug":"Git","permalink":"http://qetr1ck-op.github.io/categories/Git/"}],"tags":[{"name":"Git","slug":"Git","permalink":"http://qetr1ck-op.github.io/tags/Git/"}]},{"title":"Bootstrap 3: CSS","slug":"Bootstrap3-CSS","date":"2014-07-17T17:10:04.000Z","updated":"2016-10-05T20:56:36.221Z","comments":true,"path":"2014/07/17/Bootstrap3-CSS/","link":"","permalink":"http://qetr1ck-op.github.io/2014/07/17/Bootstrap3-CSS/","excerpt":"A detailed look for implementation of UI popular library.","text":"A detailed look for implementation of UI popular library. Overview Mobile First Typography and links Normalize.css Grid System Media query Stacked-to-horizontal Fluid container Offseting columns Grid System Examples Typography Headings Body copy Inline text elements Transformation clases Alignment classes Blockquotes Lists Codes User input Basic block Varible Sample output Typography Examples Tables Basic example Bordered table Hover rows Condensed table Contextual classes Responsive tables Table Examples Forms Basic example Inline form Horizontal form Input focus Validates states and Icon Control sizing and Help text Form Examples Buttons Options Sizes Horizontal form Active state Disabled state Buttons Examples Images Responsive image Image shapes Helper classes Contextual colors Contextual backgrounds Close icon Carets Quick floats Center content blocks Clearfix Showing and hiding content Mobile First To ensure proper rendering and touch zooming, add the viewport meta tag: 1&lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1\"&gt; You can disable zooming capabilities on mobile devices by adding: 1&lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no\"&gt; Typography and links Bootstrap sets basic global display, typography, and link styles. Specifically, we: Set background-color: #fff; on the body Use the @font-family-base, @font-size-base, and @line-height - base attributes as our typographic base Set the global link color via @link-color and apply link underlines only on :hover These styles can be found within scaffolding.less. Normalize.css For improved cross-browser rendering, Bootstrap uses Normalize.css, a project by Nicolas Gallagher and Jonathan Neal. Media queries Bootstrap includes a responsive, mobile first fluid grid system that appropriately scales up to 12 columns as the device or viewport size increases. Here’s how the Bootstrap grid system works: Rows must be placed within a .container (fixed-width) or .container-fluid (full-width) for proper alignment and padding. Use rows to create horizontal groups of columns. Content should be placed within columns, and only columns may be immediate children of rows. Predefined grid classes like .row and .col-xs-4 are available for quickly making grid layouts. Less mixins can also be used for more semantic layouts. Columns create gutters (gaps between column content) via padding. That padding is offset in rows for the first and last column via negative margin on .rows. The negative margin is why the examples below are outdented. It’s so that content within grid columns is lined up with non-grid content. Grid columns are created by specifying the number of twelve available columns you wish to span. For example, three equal columns would use three .col-xs-4. If more than 12 columns are placed within a single row, each group of extra columns will, as one unit, wrap onto a new line. Grid classes apply to devices with screen widths greater than or equal to the breakpoint sizes, and override grid classes targeted at smaller devices. Therefore, e.g. applying any .col-md-* class to an element will not only affect its styling on medium devices but also on large devices if a .col-lg-* class is not present. Initial grid system implementation: 123456789101112/* Extra small devices (phones, less than 768px) *//* No media query since this is the default in Bootstrap */@media (min-width: @screen-xs-min) &#123; ... &#125;/* Small devices (tablets, 768px and up) */@media (min-width: @screen-sm-min) &#123; ... &#125;/* Medium devices (desktops, 992px and up) */@media (min-width: @screen-md-min) &#123; ... &#125;/* Large devices (large desktops, 1200px and up) */@media (min-width: @screen-lg-min) &#123; ... &#125; Using a single set of .col-md-* grid classes, you can create a basic grid system that starts out stacked on mobile devices and tablet devices (the extra small to small range) before becoming horizontal on desktop (medium) devices. Place grid columns in any .row. Stacked-to-horizontal 123456789101112131415161718192021222324252627&lt;div class=\"row\"&gt; &lt;div class=\"col-md-1\"&gt;.col-md-1&lt;/div&gt; &lt;div class=\"col-md-1\"&gt;.col-md-1&lt;/div&gt; &lt;div class=\"col-md-1\"&gt;.col-md-1&lt;/div&gt; &lt;div class=\"col-md-1\"&gt;.col-md-1&lt;/div&gt; &lt;div class=\"col-md-1\"&gt;.col-md-1&lt;/div&gt; &lt;div class=\"col-md-1\"&gt;.col-md-1&lt;/div&gt; &lt;div class=\"col-md-1\"&gt;.col-md-1&lt;/div&gt; &lt;div class=\"col-md-1\"&gt;.col-md-1&lt;/div&gt; &lt;div class=\"col-md-1\"&gt;.col-md-1&lt;/div&gt; &lt;div class=\"col-md-1\"&gt;.col-md-1&lt;/div&gt; &lt;div class=\"col-md-1\"&gt;.col-md-1&lt;/div&gt; &lt;div class=\"col-md-1\"&gt;.col-md-1&lt;/div&gt;&lt;/div&gt;&lt;div class=\"row\"&gt; &lt;div class=\"col-md-8\"&gt;.col-md-8&lt;/div&gt; &lt;div class=\"col-md-4\"&gt;.col-md-4&lt;/div&gt;&lt;/div&gt;&lt;div class=\"row\"&gt; &lt;div class=\"col-md-4\"&gt;.col-md-4&lt;/div&gt; &lt;div class=\"col-md-4\"&gt;.col-md-4&lt;/div&gt; &lt;div class=\"col-md-4\"&gt;.col-md-4&lt;/div&gt;&lt;/div&gt;&lt;div class=\"row\"&gt; &lt;div class=\"col-md-6\"&gt;.col-md-6&lt;/div&gt; &lt;div class=\"col-md-6\"&gt;.col-md-6&lt;/div&gt;&lt;/div&gt; Fluid container Turn any fixed-width grid layout into a full-width layout by changing your outermost .container to .container-fluid. 12345&lt;html class=\"container-fluid\"&gt; &lt;div class=\"row\"&gt; ... &lt;/div&gt;&lt;/div&gt; Offseting columns 1234567891011&lt;div class=\"row\"&gt; &lt;div class=\"col-md-4\"&gt;.col-md-4&lt;/div&gt; &lt;div class=\"col-md-4 col-md-offset-4\"&gt;.col-md-4 .col-md-offset-4&lt;/div&gt;&lt;/div&gt;&lt;div class=\"row\"&gt; &lt;div class=\"col-md-3 col-md-offset-3\"&gt;.col-md-3 .col-md-offset-3&lt;/div&gt; &lt;div class=\"col-md-3 col-md-offset-3\"&gt;.col-md-3 .col-md-offset-3&lt;/div&gt;&lt;/div&gt;&lt;div class=\"row\"&gt; &lt;div class=\"col-md-6 col-md-offset-3\"&gt;.col-md-6 .col-md-offset-3&lt;/div&gt;&lt;/div&gt; Move columns to the right using .col-md-offset-* classes. These classes increase the left margin of a column by * columns. For example, .col-md-offset-4 moves .col-md-4 over four columns: Grid System Examples See the Pen Bootstrap CSS: Grids by qetr1ck-op (@qetr1ck-op) on CodePen. Headings and Secondary Text All HTML headings, h1 through h6, are available. .h1 through .h6 classes are also available, for when you want to match the font styling of a heading but still want your text to be displayed inline. Create lighter, secondary text in any heading with a generic small tag or the .small class. 123456&lt;h1&gt;h1. Bootstrap heading &lt;small&gt;Secondary text&lt;/small&gt;&lt;/h1&gt;&lt;h2&gt;h2. Bootstrap heading &lt;small&gt;Secondary text&lt;/small&gt;&lt;/h2&gt;&lt;h3&gt;h3. Bootstrap heading &lt;small&gt;Secondary text&lt;/small&gt;&lt;/h3&gt;&lt;h4&gt;h4. Bootstrap heading &lt;small&gt;Secondary text&lt;/small&gt;&lt;/h4&gt;&lt;h5&gt;h5. Bootstrap heading &lt;small&gt;Secondary text&lt;/small&gt;&lt;/h5&gt;&lt;h6&gt;h6. Bootstrap heading &lt;small&gt;Secondary text&lt;/small&gt;&lt;/h6&gt; Body copy Bootstrap’s global default font-size is 14px, with a line-height of 1.428. This is applied to the body and all paragraphs. In addition, p (paragraphs) receive a bottom margin of half their computed line-height (10px by default). Make a paragraph stand out by adding .lead. 1&lt;p class=\"lead\"&gt;...&lt;/p&gt; Inline text elements See the Pen Inline text element by qetr1ck-op (@qetr1ck-op) on CodePen. Alignment classes Easily realign text to components with text alignment classes. 12345&lt;p class=\"text-left\"&gt;Left aligned text.&lt;/p&gt;&lt;p class=\"text-center\"&gt;Center aligned text.&lt;/p&gt;&lt;p class=\"text-right\"&gt;Right aligned text.&lt;/p&gt;&lt;p class=\"text-justify\"&gt;Justified text.&lt;/p&gt;&lt;p class=\"text-nowrap\"&gt;No wrap text.&lt;/p&gt; Transformation clases Transform text in components with text capitalization classes 123&lt;p class=\"text-lowercase\"&gt;Lowercased text.&lt;/p&gt;&lt;p class=\"text-uppercase\"&gt;Uppercased text.&lt;/p&gt;&lt;p class=\"text-capitalize\"&gt;Capitalized text.&lt;/p&gt; Abbreviations Stylized implementation of HTML’s abbr element for abbreviations and acronyms to show the expanded version on hover. Abbreviations with a title attribute have a light dotted bottom border and a help cursor on hover, providing additional context on hover. 1&lt;abbr title=\"attribute\"&gt;attr&lt;/abbr&gt; Blockquotes For quoting blocks of content from another source within your document. Add a footer for identifying the source. Add .blockquote-reverse for a blockquote with right-aligned content. 12345678&lt;blockquote&gt; &lt;p&gt;Lorem ipsum dolor sit amet, consectetur adipiscing elit. Integer posuere erat a ante.&lt;/p&gt; &lt;footer&gt;Someone famous in &lt;cite title=\"Source Title\"&gt;Source Title&lt;/cite&gt;&lt;/footer&gt;&lt;/blockquote&gt;&lt;blockquote class=\"blockquote-reverse\"&gt; ...&lt;/blockquote&gt; Lists 12345678910111213141516&lt;ol&gt; &lt;li&gt;...&lt;/li&gt;&lt;/ol&gt;&lt;ul class=\"list-unstyled\"&gt; &lt;li&gt;...&lt;/li&gt;&lt;/ul&gt;&lt;ul class=\"list-inline\"&gt; &lt;li&gt;...&lt;/li&gt;&lt;/ul&gt;&lt;dl class=\"dl-horizontal\"&gt; &lt;dt&gt;...&lt;/dt&gt; &lt;dd&gt;...&lt;/dd&gt;&lt;/dl&gt; Codes Wrap inline snippets of code with code. 1For example, `&amp;lt;section&amp;gt;` should be wrapped as inline. User Input Use the kbd to indicate input that is typically entered via keyboard. 1To switch directories, type &lt;kbd&gt;cd&lt;/kbd&gt; followed by the name of the directory. Basic block Use &amp;lt;pre&amp;gt; for multiple lines of code. Be sure to escape any angle brackets in the code for proper rendering. 1&lt;pre&gt;&amp;lt;p&amp;gt;Sample text here...&amp;lt;/p&amp;gt;&lt;/pre&gt; You may optionally add the .pre-scrollable class, which will set a max-height of 350px and provide a y-axis scrollbar. Varible For indicating variables use the &amp;lt;var&amp;gt; tag. 1&lt;var&gt;y&lt;/var&gt; = &lt;var&gt;m&lt;/var&gt;&lt;var&gt;x&lt;/var&gt; + &lt;var&gt;b&lt;/var&gt; Sample output For indicating blocks sample output from a program use the &amp;lt;samp&amp;gt; tag. 1&lt;samp&gt;This text is meant to be treated as sample output from a computer program.&lt;/samp&gt; Typography Examples See the Pen Bootstrap CSS: Typography by qetr1ck-op (@qetr1ck-op) on CodePen. Basic example For basic styling—light padding and only horizontal dividers—add the base class .table to any table. 123&lt;table class=\"table\"&gt; ...&lt;/table&gt; Bordered table Add .table-bordered for borders on all sides of the table and cells. 123&lt;table class=\"table table-bordered\"&gt; ...&lt;/table&gt; Hover rows Add .table-hover to enable a hover state on table rows within a tbody. 123&lt;table class=\"table table-hover\"&gt; ...&lt;/table&gt; Condensed table Add .table-condensed to make tables more compact by cutting cell padding in half. 123&lt;table class=\"table table-condensed\"&gt; ...&lt;/table&gt; Contextual classes Use contextual classes to color table rows or individual cells: 123456789101112131415&lt;!-- On rows --&gt;&lt;tr class=\"active\"&gt;...&lt;/tr&gt;&lt;tr class=\"success\"&gt;...&lt;/tr&gt;&lt;tr class=\"warning\"&gt;...&lt;/tr&gt;&lt;tr class=\"danger\"&gt;...&lt;/tr&gt;&lt;tr class=\"info\"&gt;...&lt;/tr&gt;&lt;!-- On cells (`td` or `th`) --&gt;&lt;tr&gt; &lt;td class=\"active\"&gt;...&lt;/td&gt; &lt;td class=\"success\"&gt;...&lt;/td&gt; &lt;td class=\"warning\"&gt;...&lt;/td&gt; &lt;td class=\"danger\"&gt;...&lt;/td&gt; &lt;td class=\"info\"&gt;...&lt;/td&gt;&lt;/tr&gt; Responsive tables Create responsive tables by wrapping any .table in .table-responsive to make them scroll horizontally on small devices (under 768px). When viewing on anything larger than 768px wide, you will not see any difference in these tables. 12345&lt;div class=\"table-responsive\"&gt; &lt;table class=\"table\"&gt; ... &lt;/table&gt;&lt;/div&gt; Table Examples See the Pen Bootstrap CSS: Tables by qetr1ck-op (@qetr1ck-op) on CodePen. Basic example Individual form controls automatically receive some global styling. All textual input, textarea, and select elements with .form-control are set to width: 100%; by default. Wrap labels and controls in .form-group for optimum spacing. 1234567891011121314151617181920&lt;form role=\"form\"&gt; &lt;div class=\"form-group\"&gt; &lt;label for=\"exampleInputEmail1\"&gt;Email address&lt;/label&gt; &lt;input type=\"email\" class=\"form-control\" id=\"exampleInputEmail1\" placeholder=\"Enter email\"&gt; &lt;/div&gt; &lt;div class=\"form-group\"&gt; &lt;label for=\"exampleInputPassword1\"&gt;Password&lt;/label&gt; &lt;input type=\"password\" class=\"form-control\" id=\"exampleInputPassword1\" placeholder=\"Password\"&gt; &lt;/div&gt; &lt;div class=\"form-group\"&gt; &lt;label for=\"exampleInputFile\"&gt;File input&lt;/label&gt; &lt;input type=\"file\" id=\"exampleInputFile\"&gt; &lt;/div&gt; &lt;div class=\"checkbox\"&gt; &lt;label&gt; &lt;input type=\"checkbox\"&gt; Check me out &lt;/label&gt; &lt;/div&gt; &lt;button type=\"submit\" class=\"btn btn-default\"&gt;Submit&lt;/button&gt;&lt;/form&gt; Inline form Add .form-inline to your form for left-aligned and inline-block controls. This only applies to forms within viewports that are at least 768px wide. For these inline forms, you can hide the labels using the .sr-only class. 12345678910111213141516171819202122&lt;form class=\"form-inline\" role=\"form\"&gt; &lt;div class=\"form-group\"&gt; &lt;label class=\"sr-only\" for=\"exampleInputEmail2\"&gt;Email address&lt;/label&gt; &lt;input type=\"email\" class=\"form-control\" id=\"exampleInputEmail2\" placeholder=\"Enter email\"&gt; &lt;/div&gt; &lt;div class=\"form-group\"&gt; &lt;div class=\"input-group\"&gt; &lt;div class=\"input-group-addon\"&gt;@&lt;/div&gt; &lt;input class=\"form-control\" type=\"email\" placeholder=\"Enter email\"&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=\"form-group\"&gt; &lt;label class=\"sr-only\" for=\"exampleInputPassword2\"&gt;Password&lt;/label&gt; &lt;input type=\"password\" class=\"form-control\" id=\"exampleInputPassword2\" placeholder=\"Password\"&gt; &lt;/div&gt; &lt;div class=\"checkbox\"&gt; &lt;label&gt; &lt;input type=\"checkbox\"&gt; Remember me &lt;/label&gt; &lt;/div&gt; &lt;button type=\"submit\" class=\"btn btn-default\"&gt;Sign in&lt;/button&gt;&lt;/form&gt; Horizontal form Use Bootstrap’s predefined grid classes to align labels and groups of form controls in a horizontal layout by adding .form-horizontal to the form. Doing so changes .form-groups to behave as grid rows, so no need for .row. 12345678910111213141516171819202122232425262728&lt;form class=\"form-horizontal\" role=\"form\"&gt; &lt;div class=\"form-group\"&gt; &lt;label for=\"inputEmail3\" class=\"col-sm-2 control-label\"&gt;Email&lt;/label&gt; &lt;div class=\"col-sm-10\"&gt; &lt;input type=\"email\" class=\"form-control\" id=\"inputEmail3\" placeholder=\"Email\"&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=\"form-group\"&gt; &lt;label for=\"inputPassword3\" class=\"col-sm-2 control-label\"&gt;Password&lt;/label&gt; &lt;div class=\"col-sm-10\"&gt; &lt;input type=\"password\" class=\"form-control\" id=\"inputPassword3\" placeholder=\"Password\"&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=\"form-group\"&gt; &lt;div class=\"col-sm-offset-2 col-sm-10\"&gt; &lt;div class=\"checkbox\"&gt; &lt;label&gt; &lt;input type=\"checkbox\"&gt; Remember me &lt;/label&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=\"form-group\"&gt; &lt;div class=\"col-sm-offset-2 col-sm-10\"&gt; &lt;button type=\"submit\" class=\"btn btn-default\"&gt;Sign in&lt;/button&gt; &lt;/div&gt; &lt;/div&gt;&lt;/form&gt; Input focus Bootstrap remove the default outline styles on some form controls and apply a box-shadow in its place for :focus: Validation states Bootstrap includes validation styles for error, warning, and success states on form controls. To use, add .has-warning, .has-error, or .has-success to the parent element. Any .control-label, .form-control, and .help-block within that element will receive the validation styles. You can also add optional feedback icons with the addition of .has-feedback and the right icon. Control sizing and help text Set heights using classes like .input-lg, and set widths using grid column classes like .col-lg-*. Wrap inputs in grid columns, or any custom parent element, to easily enforce desired widths. See the Pen Bootstrap CSS: Forms by qetr1ck-op (@qetr1ck-op) on CodePen. Options Use any of the available button classes to quickly create a styled button: 1234567891011121314151617181920&lt;!-- Standard button --&gt;&lt;button type=\"button\" class=\"btn btn-default\"&gt;Default&lt;/button&gt;&lt;!-- Provides extra visual weight and identifies the primary action in a set of buttons --&gt;&lt;button type=\"button\" class=\"btn btn-primary\"&gt;Primary&lt;/button&gt;&lt;!-- Indicates a successful or positive action --&gt;&lt;button type=\"button\" class=\"btn btn-success\"&gt;Success&lt;/button&gt;&lt;!-- Contextual button for informational alert messages --&gt;&lt;button type=\"button\" class=\"btn btn-info\"&gt;Info&lt;/button&gt;&lt;!-- Indicates caution should be taken with this action --&gt;&lt;button type=\"button\" class=\"btn btn-warning\"&gt;Warning&lt;/button&gt;&lt;!-- Indicates a dangerous or potentially negative action --&gt;&lt;button type=\"button\" class=\"btn btn-danger\"&gt;Danger&lt;/button&gt;&lt;!-- Deemphasize a button by making it look like a link while maintaining button behavior --&gt;&lt;button type=\"button\" class=\"btn btn-link\"&gt;Link&lt;/button&gt; Sizes Fancy larger or smaller buttons? Add .btn-lg, .btn-sm, or .btn-xs for additional sizesCreate block level buttons—those that span the full width of a parent— by adding .btn-block. 123456789101112131415&lt;button type=\"button\" class=\"btn btn-primary btn-lg\"&gt;Large button&lt;/button&gt;&lt;button type=\"button\" class=\"btn btn-default btn-lg\"&gt;Large button&lt;/button&gt;&lt;button type=\"button\" class=\"btn btn-primary\"&gt;Default button&lt;/button&gt;&lt;button type=\"button\" class=\"btn btn-default\"&gt;Default button&lt;/button&gt;&lt;button type=\"button\" class=\"btn btn-primary btn-sm\"&gt;Small button&lt;/button&gt;&lt;button type=\"button\" class=\"btn btn-default btn-sm\"&gt;Small button&lt;/button&gt;&lt;button type=\"button\" class=\"btn btn-primary btn-xs\"&gt;Extra small button&lt;/button&gt;&lt;button type=\"button\" class=\"btn btn-default btn-xs\"&gt;Extra small button&lt;/button&gt;&lt;!-- Block level button --&gt;&lt;button type=\"button\" class=\"btn btn-primary btn-lg btn-block\"&gt;Block level button&lt;/button&gt;&lt;button type=\"button\" class=\"btn btn-default btn-lg btn-block\"&gt;Block level button&lt;/button&gt; Active state Buttons will appear pressed (with a darker background, darker border, and inset shadow) when active. For button elements, this is done via :active. For a elements, it’s done with .active. However, you may use .active on button should you need to replicate the active state programmatically. Disabled state Make buttons look unclickable by fading them back 50%. Add the disabled attribute to button or .disabled class to a: 12345&lt;button type=\"button\" class=\"btn btn-lg btn-primary\" disabled=\"disabled\"&gt;Primary button&lt;/button&gt;&lt;button type=\"button\" class=\"btn btn-default btn-lg\" disabled=\"disabled\"&gt;Button&lt;/button&gt;&lt;!-- Anchors elements --&gt;&lt;a href=\"#\" class=\"btn btn-primary btn-lg disabled\" role=\"button\"&gt;Primary link&lt;/a&gt;&lt;a href=\"#\" class=\"btn btn-default btn-lg disabled\" role=\"button\"&gt;Link&lt;/a&gt; See the Pen Bootstrap CSS: Buttons by qetr1ck-op (@qetr1ck-op) on CodePen. Responsive images Images in Bootstrap 3 can be made responsive-friendly via the addition of the .img-responsive class. This applies max-width: 100%; and height: auto; to the image so that it scales nicely to the parent element. 1&lt;img src=\"...\" class=\"img-responsive\" alt=\"Responsive image\"&gt; Images shapes Add classes to an img element to easily style images in any project: 123&lt;img src=\"...\" alt=\"...\" class=\"img-rounded\"&gt;&lt;img src=\"...\" alt=\"...\" class=\"img-circle\"&gt;&lt;img src=\"...\" alt=\"...\" class=\"img-thumbnail\"&gt; See the Pen Images shapes by qetr1ck-op (@qetr1ck-op) on CodePen. Contextual colors Convey meaning through color with a handful of emphasis utility classes: text-muted, text-primary, text-success, text-info, text-warning, text-danger: 123456&lt;p class=\"text-muted\"&gt;...&lt;/p&gt;&lt;p class=\"text-primary\"&gt;...&lt;/p&gt;&lt;p class=\"text-success\"&gt;...&lt;/p&gt;&lt;p class=\"text-info\"&gt;...&lt;/p&gt;&lt;p class=\"text-warning\"&gt;...&lt;/p&gt;&lt;p class=\"text-danger\"&gt;...&lt;/p&gt; Contextual backgrounds Similar to the contextual text color classes, easily set the background of an element to any contextual class. Anchor components will darken on hover, just like the text classes. 12345&lt;p class=\"bg-primary\"&gt;...&lt;/p&gt;&lt;p class=\"bg-success\"&gt;...&lt;/p&gt;&lt;p class=\"bg-info\"&gt;...&lt;/p&gt;&lt;p class=\"bg-warning\"&gt;...&lt;/p&gt;&lt;p class=\"bg-danger\"&gt;...&lt;/p&gt; Close icon Use the generic close icon for dismissing content like modal and alert. 1&lt;button type=\"button\" class=\"close\"&gt;&lt;span aria-hidden=\"true\"&gt;&amp;times;&lt;/span&gt;&lt;span class=\"sr-only\"&gt;Close&lt;/span&gt;&lt;/button&gt; Carets Use carets to indicate drop-down functionality and direction. 1&lt;span class=\"caret\"&gt;&lt;/span&gt; Quick floats 12&lt;div class=\"pull-left\"&gt;...&lt;/div&gt;&lt;div class=\"pull-right\"&gt;...&lt;/div&gt; Center content blocks Set an element to display: block and center via margin 1&lt;div class=\"center-block\"&gt;...&lt;/div&gt; Clearfix Easily clear floats by adding .clearfix to the parent element. 12&lt;!-- Usage as a class --&gt;&lt;div class=\"clearfix\"&gt;...&lt;/div&gt; Showing and hiding content Force an element to be shown or hidden (including for screen readers) with the use of .show and .hidden classes. 12&lt;div class=\"show\"&gt;...&lt;/div&gt;&lt;div class=\"hidden\"&gt;...&lt;/div&gt; Helper Classes Examples See the Pen Helper Classes by qetr1ck-op (@qetr1ck-op) on CodePen. The materials which save my day: Bootstrap Official Site","categories":[{"name":"CSS","slug":"CSS","permalink":"http://qetr1ck-op.github.io/categories/CSS/"}],"tags":[{"name":"Bootstrap","slug":"Bootstrap","permalink":"http://qetr1ck-op.github.io/tags/Bootstrap/"}]},{"title":"Deferred and promise in jQuery","slug":"Deferred-and-promise-in-jQuery","date":"2014-07-14T18:17:26.000Z","updated":"2016-01-31T20:58:58.511Z","comments":true,"path":"2014/07/14/Deferred-and-promise-in-jQuery/","link":"","permalink":"http://qetr1ck-op.github.io/2014/07/14/Deferred-and-promise-in-jQuery/","excerpt":"How handle async code with jQuery via promises and creating own promise via deffered.","text":"How handle async code with jQuery via promises and creating own promise via deffered. So in which cases are Promises useful?AJAX request handler spaghetti? 1234567891011121314151617$.ajax(&#123; type: 'GET', url: 'http://www.html5rocks.com/en/tutorials/file/xhr2/', success: function(response) &#123; var insertDiv1 = $('&lt;div&gt;&lt;/div&gt;'); insertDiv1.html($(response).find('section').html()); $.ajax(&#123; type: 'GET', url: 'http://www.html5rocks.com/en/tutorials/audio/scheduling/', success: function(response) &#123; var insertDiv2 = $('&lt;div&gt;&lt;/div&gt;'); insertDiv2.html($(response).find('section').html()); $('body').append(insertDiv1, insertDiv2); &#125; &#125;); &#125;&#125;); Why we need Deferred and Promises?Let’s do a step back in time. A time without iPod or Xbox or Facebook. If you wanted to catch a mouseclick, you did it with element.onclick = someFunction; This became a problem when another part of the code also wanted to listen to this click. This was not possible, because you could only assign one function. This was solved at the time with the addEventListener function. With this, you can add as many listener functions as you want. Now we have a similar problem with Ajax calls. This time it’s not the events, but the fact that Ajax supports only one callback function. Not only the jQuery $.ajax() call, but also the underlying XMLHttpRequest object. Deferred and promise are part of jQuery since version 1.5 and they help in handling asynchronous functions like Ajax. A typical $.ajax() call looked like this: 12345$.ajax(&#123; url: \"/myServerScript\", success: mySuccessFunction, error: myErrorFunction&#125;); Since version 1.5, the returned object implements the CommonJS Promises/A interface. CommonJS is a initiative to define common and independent interfaces API’s. Promises/A is one such interface. The advantage is that these are not jQuery specific. For example, if you work with Node.js, there is a good chance you’ll program with this same interface. The way of assigning callbacks with Promises: 123456var promise = $.ajax(&#123; url: \"/myServerScript\"&#125;);promise.done(mySuccessFunction);promise.fail(myErrorFunction); You can combine the done() and fail() functions in one then() function: 12345var promise = $.ajax(&#123; url: \"/myServerScript\"&#125;);promise.then(mySuccessFunction, myErrorFunction); The advantages of promises are: You can call the done() and fail() functions more times, with different callbacks. Maybe you have a callback function that stops an animation, one that does a new Ajax call and another function that shows the received data to the visitor: 12345678var promise = $.ajax(&#123; url: \"/myServerScript\"&#125;);promise.done(myStopAnimationFunction);promise.done(myOtherAjaxFunction);promise.done(myShowInfoFunction);promise.fail(myErrorFunction); You can combine promises. Sometimes you need to do two simultaneous Ajax calls and you want to execute a function when both are successfully finished. To do this, you use the new $.when() function: 123456var promise1 = $.ajax(\"/myServerScript1\");var promise2 = $.ajax(\"/myServerScript2\");$.when(promise1, promise2).done(function(xhrObject1, xhrObject2) &#123; // Handle both XHR objects&#125;); Since jQuery 1.8, you can chain the then() function sequentially. In the code below, first promise1 is run and when resolved successfully, getStuff is run, returning a promise and when this is resolved successfully, the anonymous function is executed: 123456789var promise1 = $.ajax(\"/myServerScript1\");function getStuff() &#123; return $.ajax(\"/myServerScript2\");&#125;promise1.then(getStuff).then(function(myServerScript2Data)&#123; // Both promises are resolved&#125;); Every callback function receives the result of the previous asynchronous function, in the case of Ajax, that would be the returned data. So what is a deferred and what is the difference with a promise?As you have seen above, a promise is an object that is returned from an asynchronous function. You need a deferred when you write such a function yourself. A deferred object has a resolve() functions for a successful result and to execute the functions assigned with done(). The reject() function is for a failed result and executes the functions assigned with fail(). You can give parameters to both the resolve() and reject() functions and they will be passed on to the functions registered with done() and fail(). The promise object does not have resolve() or reject() functions. This is because you give the promise away to other scripts and you don’t want them to resolve or reject the promise. Below is a simple script that illustrates how it works: 123456789101112131415161718$('#result').html('waiting...');var promise = wait();promise.done(result);function result() &#123; $('#result').html('done');&#125;function wait() &#123; var deferred = $.Deferred(); // (!) setTimeout(function() &#123; deferred.resolve(); &#125;, 2000); return deferred.promise();&#125; The wait() function is the function returning a promise. This will be resolved with a setTimeout of two seconds. Instead of setTimeout, everything can be used that is asynchronous, like animations, Web workers etcetera. It should be clear that inside the wait() function, we use the deferred object, but we return the limited promise object. Save My Day: Deferred and promise in jQuery An introduction to jQuery Deferred / Promise and the design pattern in general","categories":[{"name":"jQuery","slug":"jQuery","permalink":"http://qetr1ck-op.github.io/categories/jQuery/"}],"tags":[]},{"title":"JavaScript Promises","slug":"JavaScript-Promises","date":"2014-07-13T10:43:08.000Z","updated":"2016-10-05T20:57:11.122Z","comments":true,"path":"2014/07/13/JavaScript-Promises/","link":"","permalink":"http://qetr1ck-op.github.io/2014/07/13/JavaScript-Promises/","excerpt":"","text":"Promises arrive in JavaScript!Here’s how you create a promise: 12345678910var promise = new Promise(function(resolve, reject) &#123; // do a thing, possibly async, then… if (/* everything turned out fine */) &#123; resolve(\"Stuff worked!\"); &#125; else &#123; reject(Error(\"It broke\")); &#125;&#125;); The promise constructor takes one argument, a callback with two parameters, resolve and reject. Do something within the callback, perhaps async, then call resolve if everything worked, otherwise call reject. Here’s how you use that promise: 12345promise.then(function(res) &#123;trueconsole.log(res) //Stuff worked!&#125;, function(err) &#123;trueconsole.log(err) //Error!&#125;); then takes two arguments, a callback for a success case, and another for the failure case. Both are optional, so you can add a callback for the success or failure case only. Promisifying XMLHttpRequestOld APIs will be updated to use promises, if it’s possible in a backwards compatible way. XMLHttpRequest is a prime candidate, but in the mean time let’s write a simple function to make a GET request: 123456789101112131415161718192021222324252627282930function get(url) &#123; // Return a new promise. return new Promise(function(resolve, reject) &#123; // Do the usual XHR stuff var req = new XMLHttpRequest(); req.open('GET', url); req.onload = function() &#123; // This is called even on 404 etc // so check the status if (req.status == 200) &#123; // Resolve the promise with the response text resolve(req.response); &#125; else &#123; // Otherwise reject with the status text // which will hopefully be a meaningful error reject(Error(req.statusText)); &#125; &#125;; // Handle network errors req.onerror = function() &#123; reject(Error(\"Network Error\")); &#125;; // Make the request req.send(); &#125;);&#125; Now let’s use it:12345get('story.json').then(function(response) &#123; console.log(\"Success!\", response);&#125;, function(error) &#123; console.error(\"Failed!\", error);&#125;); Chainingthen isn’t the end of the story, you can chain then&quot;s together to transform values or run additional async actions one after another: 12345678910var promise = new Promise(function(resolve, reject) &#123; resolve(1);&#125;promise.then(function(val) &#123; console.log(val); // 1 return val + 2;&#125;).then(function(val) &#123; console.log(val); // 3&#125;); As a practical example, let’s go back to: 12345get('story.json').then(function(response) &#123; return JSON.parse(response);&#125;).then(function(response) &#123; console.log(\"Yey JSON!\", response);&#125;); getJSON still returns a promise, one that fetches a url then parses the response as JSON. 123function getJSON(url) &#123; return get(url).then(JSON.parse);&#125; Error handlingAs we saw earlier, then takes two arguments, one for success, one for failure (or fulfill and reject, in promises-speak): 12345get('story.json').then(function(response) &#123; console.log(\"Success!\", response);&#125;, function(error) &#123; console.log(\"Failed!\", error);&#125;); You can also use catch: 12345get('story.json').then(function(response) &#123; console.log(\"Success!\", response);&#125;).catch(function(error) &#123; console.log(\"Failed!\", error);&#125;); With our story and chapters, we can use catch to display an error to the user: 123456789getJSON('story.json').then(function(story) &#123; return getJSON(story.chapterUrls[0]);&#125;).then(function(chapter1) &#123; addHtmlToPage(chapter1.html);&#125;).catch(function() &#123; addTextToPage(\"Failed to show chapter\");&#125;).then(function() &#123; document.querySelector('.spinner').style.display = 'none';&#125;); Creating a sequenceBut how can we loop through the story.chapter urls and fetch them in order? 12345678910111213getJSON('story.json').then(function(story) &#123; addHtmlToPage(story.heading); // TODO: for each url in story.chapterUrls, fetch &amp; display&#125;).then(function() &#123; // And we're all done! addTextToPage(\"All done\");&#125;).catch(function(err) &#123; // Catch any error that happened along the way addTextToPage(\"Argh, broken: \" + err.message);&#125;).then(function() &#123; // Always hide the spinner document.querySelector('.spinner').style.display = 'none';&#125;); This doesn’t work: 1234567story.chapterUrls.forEach(function(chapterUrl) &#123; // Fetch chapter getJSON(chapterUrl).then(function(chapter) &#123; // and add it to the page addHtmlToPage(chapter.html); &#125;);&#125;); We want to turn our chapterUrls array into a sequence of promises. We can do that using then: 123456789101112// Start off with a promise that always resolvesvar sequence = Promise.resolve();// Loop through our chapter urlsstory.chapterUrls.forEach(function(chapterUrl) &#123; // Add these actions to the end of the sequence sequence = sequence.then(function() &#123; return getJSON(chapterUrl); &#125;).then(function(chapter) &#123; addHtmlToPage(chapter.html); &#125;);&#125;); We can tidy up the above code using array.reduce: 123456789// Loop through our chapter urlsstory.chapterUrls.reduce(function(sequence, chapterUrl) &#123; // Add these actions to the end of the sequence return sequence.then(function() &#123; return getJSON(chapterUrl); &#125;).then(function(chapter) &#123; addHtmlToPage(chapter.html); &#125;);&#125;, Promise.resolve()); Let’s put it all together… 1234567891011121314151617181920212223getJSON('story.json').then(function(story) &#123; addHtmlToPage(story.heading); return story.chapterUrls.reduce(function(sequence, chapterUrl) &#123; // Once the last chapter's promise is done… return sequence.then(function() &#123; // …fetch the next chapter return getJSON(chapterUrl); &#125;).then(function(chapter) &#123; // and add it to the page addHtmlToPage(chapter.html); &#125;); &#125;, Promise.resolve());&#125;).then(function() &#123; // And we're all done! addTextToPage(\"All done\");&#125;).catch(function(err) &#123; // Catch any error that happened along the way addTextToPage(\"Argh, broken: \" + err.message);&#125;).then(function() &#123; // Always hide the spinner document.querySelector('.spinner').style.display = 'none';&#125;); But we can do better. At the moment our page is downloading like this: Browsers aren’t pretty good at downloading multiple things at once, so we’re losing performance by downloading chapters one after the other. What we want to do is download them all at the same time, then process them when they’ve all arrived. Thankfully there’s an API for this: 123Promise.all(arrayOfPromises).then(function(arrayOfResults) &#123; //...&#125;); Promise.all takes an array of promises and creates a promise that fulfills when all of them successfully complete. You get an array of results (whatever the promises fulfilled to) in the same order as the promises you passed in. 12345678910111213141516171819202122getJSON('story.json').then(function(story) &#123; addHtmlToPage(story.heading); // Take an array of promises and wait on them all return Promise.all( // Map our array of chapter urls to // an array of chapter json promises story.chapterUrls.map(getJSON) );&#125;).then(function(chapters) &#123; // Now we have the chapters jsons in order! Loop through… chapters.forEach(function(chapter) &#123; // …and add to the page addHtmlToPage(chapter.html); &#125;); addTextToPage(\"All done\");&#125;).catch(function(err) &#123; // catch any error that happened so far addTextToPage(\"Argh, broken: \" + err.message);&#125;).then(function() &#123; document.querySelector('.spinner').style.display = 'none';&#125;); Depending on connection, this can be seconds faster than loading one-by-one:","categories":[{"name":"Javascript","slug":"Javascript","permalink":"http://qetr1ck-op.github.io/categories/Javascript/"}],"tags":[{"name":"XHR","slug":"XHR","permalink":"http://qetr1ck-op.github.io/tags/XHR/"},{"name":"Promises","slug":"Promises","permalink":"http://qetr1ck-op.github.io/tags/Promises/"}]},{"title":"Class manipulation in Javascript, jQuery and AngularJS","slug":"Class-manipulation-in-Javascript-jQuery-and-AngularJS","date":"2014-07-02T20:24:37.000Z","updated":"2016-06-28T09:02:29.166Z","comments":true,"path":"2014/07/02/Class-manipulation-in-Javascript-jQuery-and-AngularJS/","link":"","permalink":"http://qetr1ck-op.github.io/2014/07/02/Class-manipulation-in-Javascript-jQuery-and-AngularJS/","excerpt":"In this article, I would like to create short reference for how add/remove/toogle/… class in pure Javascript and with freemework.","text":"In this article, I would like to create short reference for how add/remove/toogle/… class in pure Javascript and with freemework. Javascript className Property className has value of HTML-atribute class: 1&lt;body class=\"class1 class2\"&gt;&lt;/body&gt; 1234567console.log(document.body.className);//class1 class2document.body.className += ' class3';console.log(document.body.className);//class1 class2 class3 classList Property classList gives convenient interface for work with certain classes. elem.classList.contains(cls) - return true/false if element has class cls elem.classList.add/remove(cls) - adding/removing class cls elem.classList.toogle(cls) - if element has class cls, remove it, else add class cls jQueryThese methods inspect and manpulate classes assigned to elements: $(elem).hasClass(cls) - return true/false if element has class cls $(elem).addClass/removeClass(cls) - adding/removing class cls $(elem).toogleClass(cls) - if element has class(es) cls, remove it, else add class(es) cls AngularJS ng-class ng-class accepts an “expression” that must evaluate to one of the following: a string of space-delimited class names an array of class names a map/object of class names to boolean values See the Pen AngularJS, ng-class example by qetr1ck-op (@qetr1ck-op) on CodePen. ng-style ng-style accepts an “expression” that must evaluate to: an map/object of CSS style names to CSS values See the Pen AngularJS, ng-style example by qetr1ck-op (@qetr1ck-op) on CodePen.","categories":[{"name":"Javascript","slug":"Javascript","permalink":"http://qetr1ck-op.github.io/categories/Javascript/"}],"tags":[]},{"title":"CLI in Windows, useful commands","slug":"CLI-in-Windows-useful-commands","date":"2014-06-14T07:22:15.000Z","updated":"2016-10-05T20:57:37.847Z","comments":true,"path":"2014/06/14/CLI-in-Windows-useful-commands/","link":"","permalink":"http://qetr1ck-op.github.io/2014/06/14/CLI-in-Windows-useful-commands/","excerpt":"The command line lets you communicate directly with your computer and instruct it to perform various tasks. For this you have to use specific commands","text":"The command line lets you communicate directly with your computer and instruct it to perform various tasks. For this you have to use specific commands 12345678910111213141516171819202122232425262728293031323334353637383940414243#helpc:\\&gt;command /?#Path working directoryc:\\&gt;pwd#Computer name (hostname)c:\\&gt;hostname#dirc:\\&gt;dir#List files (size, time, reverse)c:\\&gt;ls -lSr#change to drivec:\\&gt;f:#change to folderf:\\&gt;cd folder#change to root drivef:\\&gt;cd \\#make a directoryc:\\&gt;md#remove a directoryc:\\&gt;rd#remove a file/sc:\\&gt;rm namec:\\&gt;rm -rf dir_namec:\\&gt;rm *#copy a file/sc:\\&gt;cp file.txt dir_name#movec:\\&gt;mv file.txt dir_name #open explorer windowc:\\&gt;start . 123456789#create filecopy con myfile.txttouch myfile.txt#read filec:\\&gt;more file_name#find filesc:\\&gt;find . -name \"*.txt\" 12345678910#Pipes And Redirection#The | takes the output from the command on the left, and \"pipes\" it to the command on the right.c:\\&gt;cat file_name | less#The &gt; takes the output of the command on the left, then writes itc:\\&gt;cat file_name &gt; file_name2The &gt;&gt; takes the output of the command on the left, then appends itc:\\&gt;cat file_name &gt;&gt; file_name2 123#Environment variablec:\\&gt;envc:\\&gt;env | grep subl 12345678#How To Launch Git Bash from DOS Command Line?#x64start \"\" \"%SYSTEMDRIVE%\\Program Files (x86)\\Git\\bin\\sh.exe\" --login#x86start \"\" \"%ProgramFiles%\\Git\\bin\\sh.exe\" --login#aliasdoskey subl=\"C:\\Program Files\\Sublime Text 3\\sublime_text.exe\" $* Save my day: The Command Line Crash Course","categories":[{"name":"CLI","slug":"CLI","permalink":"http://qetr1ck-op.github.io/categories/CLI/"}],"tags":[]},{"title":"Prevent CSS Caching in Wordpress","slug":"Prevent-CSS-Caching","date":"2014-06-02T16:50:42.000Z","updated":"2016-06-28T09:04:39.680Z","comments":true,"path":"2014/06/02/Prevent-CSS-Caching/","link":"","permalink":"http://qetr1ck-op.github.io/2014/06/02/Prevent-CSS-Caching/","excerpt":"If you update your WordPress theme’s style.css, you may have noticed that you have to “force-reload” your site in your browser to see the changes. This is because your browser keeps a copy of the CSS cached on your hard drive.","text":"If you update your WordPress theme’s style.css, you may have noticed that you have to “force-reload” your site in your browser to see the changes. This is because your browser keeps a copy of the CSS cached on your hard drive. Depending on how your server is set up, it may not check for a new version of the stylesheet for a couple hours, or longer! And even if you force-reload to see the changes, visitors who have previously accessed your site may still get the old CSS. One way to solve this is to “version” your CSS file, by adding: [html] [/html] Save my day:Mark postCss-tricks","categories":[{"name":"CSS","slug":"CSS","permalink":"http://qetr1ck-op.github.io/categories/CSS/"}],"tags":[]},{"title":"Difference of HTTP and HTTPS","slug":"Difference-of-HTTP-and-HTTPS","date":"2014-05-31T03:00:36.000Z","updated":"2016-10-05T20:58:01.085Z","comments":true,"path":"2014/05/31/Difference-of-HTTP-and-HTTPS/","link":"","permalink":"http://qetr1ck-op.github.io/2014/05/31/Difference-of-HTTP-and-HTTPS/","excerpt":"Hyper Text Transfer Protocol Secure (HTTPS) is a secure version of the Hyper Text Transfer Protocol (HTTP). HTTPS allows secure e-commerce transactions, such as on-line banking.","text":"Hyper Text Transfer Protocol Secure (HTTPS) is a secure version of the Hyper Text Transfer Protocol (HTTP). HTTPS allows secure e-commerce transactions, such as on-line banking. When a user connects to a website via HTTPS, the website encrypts the session with a Digital Certificate called as a Secure Sockets Layer (SSL), sometimes called Transport Layer Security (TLS) to send the information back. Secure Sockets Layer uses a cryptographic system that encrypts data with two keys. Web browsers show a padlock icon to indicate that the website is secure, as it also displays https:// in the address bar. When a SSL Digital Certificate is installed on a web site, users can see a padlock icon at the bottom area of the navigator. When an Extended Validation Certificates is installed on a web site, users with the latest versions of browser will see the green address bar at the URL area of the navigator. [caption id=”” align=”aligncenter” width=”1040”]SSL accepted in Chrome[/caption] Why Is A SSL Certificate Required?With booming Internet trends and fraud, most will not submit their private details on the web unless they know that the information they provide is securely transmitted and not accessible for anyone to view. Save my day: HTTP and HTTPS","categories":[{"name":"HTTP","slug":"HTTP","permalink":"http://qetr1ck-op.github.io/categories/HTTP/"}],"tags":[]},{"title":"Function Invocation Patterns in JavaScript","slug":"Function-Invocation-Patterns-Scope-of-this-and-Function-Object-Literal-in-JavaScript","date":"2014-05-29T02:47:57.000Z","updated":"2016-10-05T20:58:33.889Z","comments":true,"path":"2014/05/29/Function-Invocation-Patterns-Scope-of-this-and-Function-Object-Literal-in-JavaScript/","link":"","permalink":"http://qetr1ck-op.github.io/2014/05/29/Function-Invocation-Patterns-Scope-of-this-and-Function-Object-Literal-in-JavaScript/","excerpt":"Describe different approaches to define and call functions","text":"Describe different approaches to define and call functions Function object are created with function literals: 123456// Create function declaration// in it that adds two numbersfunction add(a, b) &#123; return a + b;&#125;; Function literal has four parts. The first part is the reserved word function. The optional second part is the function’s name. The function can use its name to call itself recursively. The name can also be used by debuggers and development tools to identify the function. If a function is not given a name it is said to be anonymous. The third part is the set of parameters of the function, wrapped in parentheses. Within the parentheses is a set of zero or more parameter names, separated by commas. These names will be defined as variables in the function. Unlike ordinary variables, instead of being initialized to undefined, they will be initialized to the arguments supplied when the function is invoked. The fourth part is a set of statements wrapped in curly braces. These statements are the body of the function. They are executed when the function is invoked. In addition to the declared parameters, everyfunction receives two additional parameters: this and arguments. The this parameter is very important in object oriented programming, and its value is determined bythe invocation pattern. There are four patterns of invocation in JavaScript: method invocation pattern function invocation pattern constructor invocation pattern apply, binding invocation pattern The patterns differ how this will initialize. Method invocation patternWhen a function is stored as a property of an object, we call it a method. When a method is invoked, this is bound to that object. If an invocation expression contains a refinement (that is, a . dot expression or[subscript] expression), it isinvoked as a method: 12345678910var myObject = &#123; value: 0, increment: function (inc) &#123; this.value += typeof inc === 'number' ? inc : 1; &#125;&#125;;myObject.increment( );console.log(myObject.value); // 1myObject.increment(2);console.log(myObject.value); // 3 The binding of this to the object happens at invocationtime. This very late binding makes functions that use this highly reusable. Methodsthat get their object context from this are called public methods. Function invocation patternWhen a function is invoked with this pattern, this is bound to the global object orundefined`.This was a mistake in the design of the language. Had the language been designed correctly, when the inner function is invoked, this would still be bound to the this variable of the outer function. 1234567891011121314151617181920function outer() &#123; console.log('outer context ' + this); function inner() &#123; console.log('inner context ' + this); &#125; inner();&#125;outer();//outer context[object Window]//inner context[object Window][/javascript][javascript]function func() &#123; \"use strict\"; console.log(this); &#125;func();// undefined (expect IE&lt;10) A consequence of this error is that a method cannot use an inner function to help it do its work because the inner function does not share the method access to the object as its this is bound to the wrong value. Fortunately, there is an easy workaround. If the method defines a variable and assigns it the value of this, the inner function will have access to this through that variable. By convention, the name of that variable is that Constructor invocation patternJavaScript is a prototype inheritance language. That means that objects can inherit properties directly from other objects. Constructor can be any function, which is called with directive new 12345678910function Animal(name) &#123; this.name = name; this.canWalk = true; //public method this.sayHi = function() &#123; console.log(this.name + ', says Hi!'); &#125;&#125;var animal = new Animal('bamby'); How it works: Automatically is creating new, empty object Special keyword this gets a reference to ^- object Function is invoking. Usually, it modifies this, adds methods and properties Return this, if return object, than will be return object rather than this The Apply/Call Invocation PatternThe apply method lets us choose the value of this. The apply method takes two parameters. The first is the value that should be bound to this. The second is an array ofparameters. Call func.apply(context, [a, b ...]) or func.call(context, (a, b ...)) - the same as a normal call func(a, b ...), but with an another context. 123456789101112var user = &#123; firstName: \"Bobby\", surname: \"Singler\"&#125;;function getName(a, b) &#123; console.log( this[a] + ' ' + this[b] );&#125;getName.apply(user, ['firstName', 'surname']) // \"Bobby Singler\", this - our contextgetName('firstName', 'surname') // undefined undefined, this, will be window Invoke apply/call with null or undefined: 1234567891011121314function f() &#123; console.log(this);&#125;//if call with null or undefined, this = window f.call(null); // windowfunction f() &#123; \"use strict\" console.log(this);&#125;//in strict mode, this = null f.call(null); // null Save My Day:learn.javascript.ruCrockfords JavaScript: The Good Parts","categories":[{"name":"Javascript","slug":"Javascript","permalink":"http://qetr1ck-op.github.io/categories/Javascript/"},{"name":"Pattern","slug":"Javascript/Pattern","permalink":"http://qetr1ck-op.github.io/categories/Javascript/Pattern/"}],"tags":[]},{"title":"Fluid three column layout with positioning, floats, tables and flexbox","slug":"Fluid-three-column-layout-with-positioning-floats-tables-and-flexbox","date":"2014-04-18T08:09:46.000Z","updated":"2016-01-31T20:58:58.512Z","comments":true,"path":"2014/04/18/Fluid-three-column-layout-with-positioning-floats-tables-and-flexbox/","link":"","permalink":"http://qetr1ck-op.github.io/2014/04/18/Fluid-three-column-layout-with-positioning-floats-tables-and-flexbox/","excerpt":"In Web world, fluid layout with 3 column is the most flexible and customizable layout. Mixing percentages and pixels for specify width of column allows create differents layouts, for different task.","text":"In Web world, fluid layout with 3 column is the most flexible and customizable layout. Mixing percentages and pixels for specify width of column allows create differents layouts, for different task. In article sumbols mean: Here sumbol % define, that column width is given in persantage of layout width; px- column width in static pixels; ∞ - column occupies all remain width space. Using positioningTo control position layout relative to the parent element layers, necessary establish for parent property - position: relative. And for child element set position: absolute, conrols fluid element with right/left, width in some cases used margin-right/left. See the Pen Three column fluid layout with positionig by qetr1ck-op (@qetr1ck-op) on CodePen. FloatsFor this approach I used float in combinatition with properties margin and width. In some case used nested or additional div.wrap, because we can’t use in the same time for onу HTML element margin in px and %. See the Pen Fluid three column layout using floats by qetr1ck-op (@qetr1ck-op) on CodePen. Table columnsActually, it’s convinient to use table when you want to create column with same height. Width of column calculated automatcaly based on their content so I just need to specify the require width. Remain columns would streach to avaible width of table. See the Pen Fluid three column layout using table by qetr1ck-op (@qetr1ck-op) on CodePen. Flex boxMost layout or if you want grid system use one of next methods: positioning, tables, and most popular - inline-blocks or float. All this methods have pretty significaте problems and limetations. For for achive bunch of three column layout Flex boxes are super ease. In generaly I used for parents : display: flex and for children flex: 1 it’s shorthand for flex-grow, flex-shrink and flex-basis In furture post I should discover this literally one of the most promosing feature of web disign. See the Pen Fluid three column layout with flexbox by qetr1ck-op (@qetr1ck-op) on CodePen. This resources Save My Day: htmlbook.ru css-tricks.com Solved by Flexbox","categories":[{"name":"CSS","slug":"CSS","permalink":"http://qetr1ck-op.github.io/categories/CSS/"}],"tags":[]},{"title":"Original effects with CSS transition","slug":"Original-effects-with-CSS3-transition","date":"2014-04-01T11:48:05.000Z","updated":"2016-02-02T22:28:03.709Z","comments":true,"path":"2014/04/01/Original-effects-with-CSS3-transition/","link":"","permalink":"http://qetr1ck-op.github.io/2014/04/01/Original-effects-with-CSS3-transition/","excerpt":"The power of CSS3 is enormous and in this post I create appearing effect of “Sign In Form” using differn style in each example.","text":"The power of CSS3 is enormous and in this post I create appearing effect of “Sign In Form” using differn style in each example. Actually, now transition property of CSS supporting almost in all browsers, just in some case you need to use prefix -webkit, -moz, -ms, -o. You may check it on Can I use… Awesome and simple CSS3 Transition generator (and not only). More about transition-timing-funtion with example. If you look closely you may see that in all example firstly I hide “Sign In Form” with transform: scale, rotate, translateX/Y and add transition. Than I use different value of transform, transition-delay, opacity for show original transition CSS effects. Example 1See the Pen CSS3 transition effects example 1 by qetr1ck-op (@qetr1ck-op) on CodePen. In first example I used transition for base elements with different timestamps and time function. Also I used transform: translateY property that push “Sign In Form” and child elements from current position. When you click on main section, you can see delay property that emulate animation. In this example I added a transition-delay: ...s which make transition effect start a bit later. Example 2See the Pen CSS3 transition effects example 2 by qetr1ck-op (@qetr1ck-op) on CodePen. In second example I used new div.content, you can see it in HTML mark-up. For “Sign In Form” I applied transform: translate(...px, ...px) rotate(...deg) for children used only translate. Of course added transition for elements. Translate transformation in order move elements in place. The “Sign In Form” will also be rotated. The each elements of the description will come with a little delay. Example 3See the Pen CSS3 transition effects example 3 by qetr1ck-op (@qetr1ck-op) on CodePen. In third example I used the translate and transforms: rotate to bring up content. Than I just need to reset transform: translateX(0px) rotate(0deg) and add transition-delay: ...s. Example 4Here in four example I performed zoom out for main block and zoom in for “Sign In Form” with rotation effect. All thanks to transform: scale and rotate. See the Pen CSS3 transition effects example 4 by qetr1ck-op (@qetr1ck-op) on CodePen. Example 5In this example I used transform: translateX() and transition timing function ease-in-out. Transition effect make the “Sign In Form” slide from right, with pushing effect for main container. See the Pen CSS3 transition effects example 5 by qetr1ck-op (@qetr1ck-op) on CodePen. Example 6 In sixth example I performed that “Sign In Form” comes from the front, zooming out until its original size: transform: scale(from 10 to 1). And inputs will slide from bottom, used transform: translateY. See the Pen CSS3 transition effects example 6 by qetr1ck-op (@qetr1ck-op) on CodePen. Example 7In this seven example the idea is to rotate the image to center and scale it down: transform: rotate(0deg)-&gt;(720deg) scale(1)-&gt;(0). Then the “Sign In Form” comes from up with description content following. transform: translateY()). Also Added delay for the “Sign In Form” elements transition-delay: ..s. This will show us the rotating main block first and then the description will come into. In the reverse transition, everything will disappear immediately and image will rotate back. See the Pen CSS3 transition effects example 7 by qetr1ck-op (@qetr1ck-op) on CodePen. Example 8In eighth example I used an animation which recreate a bounce effect. The “Sign In Form” will bounce in from top. animation: bounceY 0.9 linear. 1animation: bounceY 0.9 linear See the Pen CSS3 transition effects example 8 by qetr1ck-op (@qetr1ck-op) on CodePen.","categories":[{"name":"CSS","slug":"CSS","permalink":"http://qetr1ck-op.github.io/categories/CSS/"}],"tags":[]},{"title":"Fluid two-column layout with float and flexbox","slug":"Fluid-two-column-layout-with-float-and-flexbox","date":"2014-03-31T17:49:09.000Z","updated":"2016-01-31T20:58:58.512Z","comments":true,"path":"2014/03/31/Fluid-two-column-layout-with-float-and-flexbox/","link":"","permalink":"http://qetr1ck-op.github.io/2014/03/31/Fluid-two-column-layout-with-float-and-flexbox/","excerpt":"Two-column layout allows effective use browser space. Layout doesn’t require hard work and it can used with combining colomn in pixels or percentage.","text":"Two-column layout allows effective use browser space. Layout doesn’t require hard work and it can used with combining colomn in pixels or percentage. There are several approach for formation such layout, but the quickest and easiest is compine margin and float. For left side bar with static width For left layer with width 20% Left column Right column float: left width: 20% margin-left: 21% For left layer with width 200px float: left width: 200px margin-left: 210px For right side bar: For right layer with width 20% Left column Right column margin-right: 21% float: right, width: 20% For right layer with width 200px float: right width: 200px margin-left: 210px See the Pen oAtih by qetr1ck-op (@qetr1ck-op) on CodePen. With display: flexSee the Pen Two-column layout with Flexbox by qetr1ck-op (@qetr1ck-op) on CodePen. Make my day: fluid 2 column layout awesome checkboxes","categories":[{"name":"CSS","slug":"CSS","permalink":"http://qetr1ck-op.github.io/categories/CSS/"}],"tags":[]},{"title":"Form pop-up with inputs navigation","slug":"Form-pop-up-with-inputs-navigation","date":"2014-03-30T18:41:30.000Z","updated":"2016-10-05T21:00:10.146Z","comments":true,"path":"2014/03/30/Form-pop-up-with-inputs-navigation/","link":"","permalink":"http://qetr1ck-op.github.io/2014/03/30/Form-pop-up-with-inputs-navigation/","excerpt":"Modal pop-up confirm with “corect” navigation through inputs.","text":"Modal pop-up confirm with “corect” navigation through inputs. Main functional requirements are: When submitting a form OK / Enter - the callback function must be called with the value of the field Clicking on Cancel or press the Esc should be call the function callback. Esc key to close the form should always, even if the message input field is not in focus. Form should do modal affect, all other element on page must be unlclickable. Form always centered in middle, height of form has no matter When form appears input field in focus and user have possibility use Tab / Tab-Shift for switch only inputs in the form. See the Pen xuizw by qetr1ck-op (@qetr1ck-op) on CodePen. Make my day: Forms: method and event “submit”","categories":[{"name":"Javascript","slug":"Javascript","permalink":"http://qetr1ck-op.github.io/categories/Javascript/"},{"name":"Forms","slug":"Javascript/Forms","permalink":"http://qetr1ck-op.github.io/categories/Javascript/Forms/"}],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"http://qetr1ck-op.github.io/tags/Javascript/"},{"name":"Forms","slug":"Forms","permalink":"http://qetr1ck-op.github.io/tags/Forms/"}]},{"title":"Git and GitHub, Git versus Subversion","slug":"git-vs-github","date":"2014-03-29T15:24:17.000Z","updated":"2016-10-05T21:00:42.136Z","comments":true,"path":"2014/03/29/git-vs-github/","link":"","permalink":"http://qetr1ck-op.github.io/2014/03/29/git-vs-github/","excerpt":"How GitHub is connected to Git and basic difference Git and Svn.","text":"How GitHub is connected to Git and basic difference Git and Svn. Git and GiHub The difference Git and GiHub So Git and GitHub are parts of one complex system, which complement each other: Git is the name of VCS (version control system) wrote by Linus Torvalds. There are always series of commits(snapshots). You see a path of this snapshots, in which order they were created. You create branch for new features and use snapshot for revert changes. GitHub is website on which you can publish your Git repositories and collaborate with other people. The difference Git is not better than Subversion. But is also not worst. It’s different: The key difference is that Git is a decentralized. With Git you can do practically anything off-line, cause everyone has their own repository. For example: I have a server at home and a Laptop on the road. SVN simply doesn’t work well here. With SVN, I can’t have local source control if I’m not connected to the repository (Yes, I know about SVK or about ways to copy the repo). With Git, that’s the default mode anyway. With command git commit you commit locally, whereas git push origin master - you push the master branch to the remote branch named origin. Making branches and merging between branches is Git way. Everybody who likes your changes can pull them into their project, including the official maintainers. It’s trivial to fork a project, modify it, and still keep merging in the bug-fixes from the HEAD branch. Git is perfectly suited for Open Source projects: just fork it, commit your changes to your own Fork, and then ask the original project maintainer to pull your changes. On the other hand Git adds complexity. Two modes of creating repositories, checkout vs. clone, commit vs. push… You have to know which commands work locally and which work with “the server”. Make my day:understanding-the-basics-of-git-and-githubDiscussion on StackOverflow","categories":[],"tags":[{"name":"Git","slug":"Git","permalink":"http://qetr1ck-op.github.io/tags/Git/"},{"name":"GitHub","slug":"GitHub","permalink":"http://qetr1ck-op.github.io/tags/GitHub/"}]},{"title":"Web Services, WSDL, SOAP envelope with JavaScript","slug":"web-services-WSDL-SOAP-envelope-with-JavaScript","date":"2014-03-17T20:18:22.000Z","updated":"2016-01-31T20:58:58.519Z","comments":true,"path":"2014/03/17/web-services-WSDL-SOAP-envelope-with-JavaScript/","link":"","permalink":"http://qetr1ck-op.github.io/2014/03/17/web-services-WSDL-SOAP-envelope-with-JavaScript/","excerpt":"The main concept of Web Services is to exchange data between two devices using standardized protocols and messages.","text":"The main concept of Web Services is to exchange data between two devices using standardized protocols and messages. What is Web Service and WSDL? SOAP protocol Example of SOAP envelope Create/receive SOAP request/response. Helpers $.soap What is Web Service and WSDL? The W3C defines a Web services: a software system designed to support machine-to-machine interaction over network. Other systems interact with the Web service in a manner prescribed by its description using SOAP messages, REST, or using HTTP with an XML serialization with other Web-related standards And for be little clear about WSDL (Web Services Description Language) - describes services as collection of network endpoints or ports in XML format. Exchange messages usually accomplished by protocol HTTP. However, it should be noted that it is still used, but very rarely, protocol - SMTP (Simple Mail Transfer Protocol). SOAP protocol Protocol SOAP transfers messages or small amount of information. SOAP messages formatted in XML and are typically send using HTTP. Some time ago SOAP was spelled as Simply Object Access Protocol. But time passed and everybody saws that protocol isn’t simple and nothingness in common with access to objects. Example of SOAP envelope The SOAP message has 3 parts: envelope, head, body. Body contains all response/request data. Also can say that head isn’t required and in modern apps doesn’t used. Example of SOAP XML: What here have happened? In the beginning I created SOAP envelope, which call service with URN (Uniform Resource Name). Then calling method getProductByHash. SOAP response of web-service have next view, only body tag: Create/receive SOAP request/response. Helpers To create soap envelope I use my soap helper module: Example creating SOAP request from soap helper as JS object: Loggin result in chrome log: Once I’ve obtained object with properties which I need to use to create XML SOAP Request. It’s time to use xml helper module with whole bunch of useful methods: Next creating XHR object, 2 callbacks and send request via POST method Parse XML into JSON object Fetch response value $.soap This script uses $.ajax to send a SOAP envelope. It can take XML DOM, XML string or JSON as input and the response can be returned as either XML DOM, XML string or JSON too. Example: Full $.soap documentation.","categories":[{"name":"Javascript","slug":"Javascript","permalink":"http://qetr1ck-op.github.io/categories/Javascript/"}],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"http://qetr1ck-op.github.io/tags/Javascript/"},{"name":"SOAP","slug":"SOAP","permalink":"http://qetr1ck-op.github.io/tags/SOAP/"},{"name":"Web","slug":"Web","permalink":"http://qetr1ck-op.github.io/tags/Web/"},{"name":"WSDL","slug":"WSDL","permalink":"http://qetr1ck-op.github.io/tags/WSDL/"}]},{"title":"Data URIs","slug":"Data-URIs","date":"2014-02-11T10:48:12.000Z","updated":"2016-02-11T21:53:30.681Z","comments":true,"path":"2014/02/11/Data-URIs/","link":"","permalink":"http://qetr1ck-op.github.io/2014/02/11/Data-URIs/","excerpt":"Did you know that you don’t have to link to an external image file when using an &lt;img&gt; element in HTML, or declaring a background-image in CSS? You can embed the image data directly into the document with data URIs.","text":"Did you know that you don’t have to link to an external image file when using an &lt;img&gt; element in HTML, or declaring a background-image in CSS? You can embed the image data directly into the document with data URIs. Why would you do this?The biggest reason: it saves HTTP Requests. Other than pure document size, this is the #1 factor concerning how fast a page loads. Less = better. The format, to be specific: 1data:[&lt;mime type&gt;][;charset=&lt;charset&gt;][;base64],&lt;encoded data&gt; 1234567li &#123; background: url(data:image/gif;base64,R0lGODlhEAAQAMQAAORHHOVSKudfOulrSOp3WOyDZu6QdvCchPGolfO0o/XBs/fNwfjZ0frl3/zy7////wAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACH5BAkAABAALAAAAAAQABAAAAVVICSOZGlCQAosJ6mu7fiyZeKqNKToQGDsM8hBADgUXoGAiqhSvp5QAnQKGIgUhwFUYLCVDFCrKUE1lBavAViFIDlTImbKC5Gm2hB0SlBCBMQiB0UjIQA7) no-repeat left center; padding: 5px 0 5px 25px;&#125; 1&lt;img width=\"16\" height=\"16\" alt=\"star\" src=\"data:image/gif;base64,R0lGODlhEAAQAMQAAORHHOVSKudfOulrSOp3WOyDZu6QdvCchPGolfO0o/XBs/fNwfjZ0frl3/zy7////wAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACH5BAkAABAALAAAAAAQABAAAAVVICSOZGlCQAosJ6mu7fiyZeKqNKToQGDsM8hBADgUXoGAiqhSvp5QAnQKGIgUhwFUYLCVDFCrKUE1lBavAViFIDlTImbKC5Gm2hB0SlBCBMQiB0UjIQA7\" /&gt; How do you get the code?Use this online conversion tool. It’s the nicest one I have found. Here’s a drag and drop one. Save my day: css-tricks.com","categories":[{"name":"Javascript","slug":"Javascript","permalink":"http://qetr1ck-op.github.io/categories/Javascript/"}],"tags":[]},{"title":"What is event bubbling and capturing?","slug":"What-is-event-bubbling-and-capturing","date":"2014-02-02T17:55:10.000Z","updated":"2016-06-28T09:06:13.087Z","comments":true,"path":"2014/02/02/What-is-event-bubbling-and-capturing/","link":"","permalink":"http://qetr1ck-op.github.io/2014/02/02/What-is-event-bubbling-and-capturing/","excerpt":"Event bubbling and capturing are two ways of event propagation in the HTML DOM API","text":"Event bubbling and capturing are two ways of event propagation in the HTML DOM API When an event occurs in an element inside another element, and both elements have registered a handle for that event. The event propagation mode determines in which order the elements receive the event. With bubbling, the event is first captured and handled by the innermost element and then propagated to outer elements. With capturing, the event is first captured by the outermost element and propagated to the inner elements. Capturing is also called trickling, which helps remember the propagation order: trickle down, bubble up Back in the old days, Netscape advocated event capturing, while Microsoft promoted event bubbling. Both are part of the W3C Document Object Model Events standard (2000). IE &lt; 9 uses only event bubbling, whereas IE9+ and all major browsers support both. We can use the addEventListener(type, listener, useCapture) to register event handlers for in either bubbling (default) or capturing mode. To use the capturing model pass the third argument as true. See the Pen Events “capturing” and “bubbling” by qetr1ck-op (@qetr1ck-op) on CodePen. What to use? It depends on what you want to do. There is no better. The difference is the order of the execution of the event handlers. Most of the time it will be fine to fire event handlers in the bubbling phase but it can also be necessary to fire them earlier. On the other hand, the performance of event bubbling may be slightly lower for complex DOMs.","categories":[{"name":"Javascript","slug":"Javascript","permalink":"http://qetr1ck-op.github.io/categories/Javascript/"}],"tags":[{"name":"Performance","slug":"Performance","permalink":"http://qetr1ck-op.github.io/tags/Performance/"}]}]}